[{"id":"047a0157ce631e99397979ea9f68fcda","title":"meta","content":"11.12写在前面此博客记录本人近期的学习情况\n个人情况简介：\n中国矿业大学大四，已保研，最近一个月有两次考试，一个报告作业\n每天在实验室学习，准备寒假去北京实习。\n","slug":"000meta","date":"2021-11-12T06:22:18.000Z","categories_index":"学习规划","tags_index":"","author_index":"YFR718"},{"id":"a3f5b417ccee185425acbc3a549133c3","title":"LeetCode做题记录","content":"刷题汇总\n\n\n\n题号\n题目\n算法\n最优解\n时间复杂度\n\n\n\n\n1\n两数之和\n哈希\n:green_heart:\n$$\n\n\n2\n两数相加\n模拟\n:green_heart:\n\n\n\n3\n无重复字符的最长子串\n\n\n\n\n\n4\n\n\n\n\n\n\n5\n\n\n\n\n\n\n6\n\n\n\n\n\n\n7\n\n\n\n\n\n\n8\n\n\n\n\n\n\n9\n\n\n\n\n\n\n10\n\n\n\n\n\n\n11\n\n\n\n\n\n\n12\n\n\n\n\n\n\n13\n\n\n\n\n\n\n14\n\n\n\n\n\n\n15\n\n\n\n\n\n\n16\n\n\n\n\n\n\n17\n\n\n\n\n\n\n18\n\n\n\n\n\n\n19\n\n\n\n\n\n\n20\n\n\n\n\n\n\n21\n\n\n\n\n\n\n22\n\n\n\n\n\n\n23\n\n\n\n\n\n\n24\n\n\n\n\n\n\n25\n\n\n\n\n\n\n26\n\n\n\n\n\n\n27\n\n\n\n\n\n\n28\n\n\n\n\n\n\n29\n\n\n\n\n\n\n30\n\n\n\n\n\n\n31\n\n\n\n\n\n\n32\n\n\n\n\n\n\n33\n\n\n\n\n\n\n34\n\n\n\n\n\n\n35\n\n\n\n\n\n\n36\n\n\n\n\n\n\n37\n\n\n\n\n\n\n38\n\n\n\n\n\n\n39\n\n\n\n\n\n\n40\n\n\n\n\n\n\n41\n\n\n\n\n\n\n42\n\n\n\n\n\n\n43\n\n\n\n\n\n\n44\n\n\n\n\n\n\n45\n\n\n\n\n\n\n46\n\n\n\n\n\n\n47\n\n\n\n\n\n\n48\n\n\n\n\n\n\n49\n\n\n\n\n\n\n50\n\n\n\n\n\n\n51\n\n\n\n\n\n\n52\n\n\n\n\n\n\n53\n\n\n\n\n\n\n54\n\n\n\n\n\n\n55\n\n\n\n\n\n\n56\n\n\n\n\n\n\n57\n\n\n\n\n\n\n58\n\n\n\n\n\n\n59\n\n\n\n\n\n\n60\n\n\n\n\n\n\n61\n\n\n\n\n\n\n62\n\n\n\n\n\n\n63\n\n\n\n\n\n\n64\n\n\n\n\n\n\n65\n\n\n\n\n\n\n66\n\n\n\n\n\n\n67\n\n\n\n\n\n\n68\n\n\n\n\n\n\n69\n\n\n\n\n\n\n70\n\n\n\n\n\n\n71\n\n\n\n\n\n\n72\n\n\n\n\n\n\n73\n\n\n\n\n\n\n74\n\n\n\n\n\n\n75\n\n\n\n\n\n\n76\n\n\n\n\n\n\n77\n\n\n\n\n\n\n78\n\n\n\n\n\n\n79\n\n\n\n\n\n\n80\n\n\n\n\n\n\n81\n\n\n\n\n\n\n82\n\n\n\n\n\n\n83\n\n\n\n\n\n\n84\n\n\n\n\n\n\n85\n\n\n\n\n\n\n86\n\n\n\n\n\n\n87\n\n\n\n\n\n\n88\n\n\n\n\n\n\n89\n\n\n\n\n\n\n90\n\n\n\n\n\n\n91\n\n\n\n\n\n\n92\n\n\n\n\n\n\n93\n\n\n\n\n\n\n94\n\n\n\n\n\n\n95\n\n\n\n\n\n\n96\n\n\n\n\n\n\n97\n\n\n\n\n\n\n98\n\n\n\n\n\n\n\n算法分类对应题目分类","slug":"l0000","date":"2021-11-05T13:51:29.000Z","categories_index":"LeetCode","tags_index":"","author_index":"YFR718"},{"id":"71dcb878b30b2fb16e5265f7515744d5","title":"疑难杂症队列","content":"Java\n整理笔记，等待发布\n尚硅谷整理的Java学习\n书5.7跳过\n\nLinux\n笔记整理，待发布\nshell编程笔记整理，待发布\n\n算法\nleetcode每日三道题\nACwing课程学习\n\nHadoop\nP88 job提交源码\nP89 切片源码\nP97 、98自定义分区\nP100~102\nP104 Combiner\nP107 OutPutFormat\nP101 源码解析\n\n\n","slug":"1-疑难杂症队列","date":"2021-11-04T05:27:30.000Z","categories_index":"学习规划","tags_index":"","author_index":"YFR718"},{"id":"48cef2b791e9d295ce08181b40c69797","title":"J6.反射、新特性","content":"","slug":"J6-反射、新特性","date":"2021-11-12T02:31:21.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"01fff90b5efe5feea841a371989c0208","title":"J5.IO、网络编程","content":"","slug":"J5-IO、网络编程","date":"2021-11-12T02:31:03.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"17a1842201d75578952b4d3c155b8146","title":"J4.集合、泛型","content":"","slug":"J4-集合、泛型","date":"2021-11-12T02:30:35.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"d0396f84e2a9cf009e1f2a35f0f836dd","title":"常用类、枚举、注解","content":"1. Java常用类1.1 字符串相关的类StringString的特性\n\nString类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。\nString是一个final类，代表不可变的字符序列。\n字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。\nString对象的字符内容是存储在一个字符数组value[]中的。\n\nString对象的创建\nString str = \"hello\";\n\n//本质上this.value = new char[0];\nString s1 = new String(); \n\n//this.value = original.value;\nString s2 = new String(String original); \n\n//this.value = Arrays.copyOf(value, value.length);\nString s3 = new String(char[] a); \nString s4 = new String(char[] a,int startIndex,int count);\n字符串对象是如何存储的结论：\n\n常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。\n只要其中有一个是变量，结果就在堆中\n如果拼接的结果调用intern()方法，返回值就在常量池中\n\nString使用陷阱\n\nString s1 = “a”;说明：在字符串常量池中创建了一个字面量为”a”的字符串。\ns1 = s1 + “b”;说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。\nString s2 = “ab”;说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。\nString s3 = “a” + “b”;说明：s3指向字符串常量池中已经创建的”ab”的字符串。String s4 = s1.intern();说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。\n\nString常用方法\nint length()：返回字符串的长度： return value.length\nchar charAt(int index)： 返回某索引处的字符return value[index]\nboolean isEmpty()：判断是否是空字符串：return value.length == 0\nString toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写\nString toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写\nString trim()：返回字符串的副本，忽略前导空白和尾部空白\nboolean equals(Object obj)：比较字符串的内容是否相同\nboolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写\nString concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”\nint compareTo(String anotherString)：比较两个字符串的大小\nString substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。\nString substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。\nboolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束\nboolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始\nboolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始\nboolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true\nint indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引\nint indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始\nint lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引\nint lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索\nString replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar 替换此字符串中出现的所有oldChar 得到的。\nString replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。\nString replaceAll(String regex, String replacement) ： 使用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。\nString replaceFirst(String regex, String replacement) ：使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。\nboolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。\nString[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。\nString[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。\n\nString与字符数组转换\n字符数组-&gt;字符串    String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。\n\n字符串-&gt;字符数组    public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。    public void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。\n\n字节数组-&gt;字符串    String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。    String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。\n\n字符串-&gt;字节数组    public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。    public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。\n\n\nStringBuffer类\njava.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。\n很多方法与String相同。\n作为参数传递时，方法内部可以改变值。\n\nStringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器：    StringBuffer()：初始容量为16的字符串缓冲区    StringBuffer(int size)：构造指定容量的字符串缓冲区    StringBuffer(String str)：将内容初始化为指定字符串内容\nStringBuffer类的常用方法\nStringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接\nStringBuffer delete(int start,int end)：删除指定位置的内容\nStringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str \nStringBuffer insert(int offset, xxx)：在指定位置插入xxx\nStringBuffer reverse() ：把当前字符序列逆转\npublic int indexOf(String str)\npublic String substring(int start,int end) public int length()\npublic char charAt(int n )\npublic void setCharAt(int n ,char ch)\n\nStringBuilder类StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样面试题：对比String、StringBuffer、StringBuilder⭐⭐\n    String(JDK1.0)：不可变字符序列    StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全    StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全\n注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。\n1.2 JDK 8之前的日期时间API1. java.lang.System类System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。\n此方法适于计算时间差。\n\n计算世界时间的主要标准有：    UTC(Coordinated Universal Time)    GMT(Greenwich Mean Time)    CST(Central Standard Time)\n\n2. java.util.Date类表示特定的瞬间，精确到毫秒\n\n构造器：    Date()：使用无参构造器创建的对象可以获取本地当前时间。    Date(long date)\n常用方法    getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。    toString():把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。    其它很多方法都过时了。\n\n3. java.text.SimpleDateFormat类\nDate类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。\n\n它允许进行格式化：日期文本、解析：文本日期\n\n格式化\n    SimpleDateFormat() ：默认的模式和语言环境创建对象    public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：    public String format(Date date)：方法格式化时间对象date\n\n解析：public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。\n\n\n\n4. java.util.Calendar(日历)类\nCalendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。\n获取Calendar实例的方法    使用Calendar.getInstance()方法    调用它的子类GregorianCalendar的构造器。\n一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、 MINUTE、SECOND    public void set(int field,int value)    public void add(int field,int amount)    public final Date getTime()    public final void setTime(Date date)\n注意:    获取月份时：一月是0，二月是1，以此类推，12月是11    获取星期时：周日是1，周二是2 ， 。。。。周六是7\n\n1.3 JDK 8中新日期时间API新时间日期API\n    第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。    Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。\n\njava.time – 包含值对象的基础包\njava.time.chrono – 提供对不同的日历系统的访问\njava.time.format – 格式化和解析时间和日期\njava.time.temporal – 包括底层框架和扩展特性\njava.time.zone – 包含时区支持的类\n\n    LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。    LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。    LocalTime表示一个时间，而不是日期。    LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。\n\n\n\n\n方法\n描述\n\n\n\n\nnow() / *  now(ZoneId zone)\n静态方法，根据当前时间创建对象/指定时区的对象\n\n\nof()\n静态方法，根据指定日期/时间创建对象\n\n\ngetDayOfMonth()/getDayOfYear()\n获得月份天数(1-31) /获得年份天数(1-366)\n\n\ngetDayOfWeek()\n获得星期几(返回一个 DayOfWeek 枚举值)\n\n\ngetMonth()\n获得月份, 返回一个 Month 枚举值\n\n\ngetMonthValue() / getYear()\n获得月份(1-12) /获得年份\n\n\ngetHour()/getMinute()/getSecond()\n获得当前对象对应的小时、分钟、秒\n\n\nwithDayOfMonth()/withDayOfYear()/withMonth()/withYear()\n将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象\n\n\nplusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()\n向当前对象添加几天、几周、几个月、几年、几小时\n\n\nminusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()\n从当前对象减去几月、几周、几天、几年、几小时\n\n\n\n\n瞬时：Instant    Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。    在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。    java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。    (1 ns = 10-9 s)   1秒 = 1000毫秒 =10^6微秒=10^9纳秒\n\n\n\n\n方法\n描述\n\n\n\n\nnow()\n静态方法，返回默认UTC时区的Instant类的对象\n\n\nofEpochMilli(long epochMilli)\n静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象\n\n\natOffset(ZoneOffset offset)\n结合即时的偏移来创建一个OffsetDateTime\n\n\ntoEpochMilli()\n返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳\n\n\n\n\n时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。\n格式化与解析日期或时间java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：\n    预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME    本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)    自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)\n\n\n\n\n方 法\n描 述\n\n\n\n\nofPattern(String pattern)\n静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 的DateTimeFormatter\n\n\nformat(TemporalAccessor t)\n格式化一个日期、时间，返回字符串\n\n\nparse(CharSequence text)\n将指定格式的字符序列解析为一个日期、时间\n\n\n\n\n其它API\nZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris\nZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。\n其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等\nClock：使用时区提供对当前即时、日期和时间的访问的时钟。\n持续时间：Duration，用于计算两个“时间”间隔\n日期间隔：Period，用于计算两个“日期”间隔\nTemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。\nTemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。\n\n与传统日期处理的转换\n\n\n\n类\nTo 遗留类\nFrom 遗留类\n\n\n\n\njava.time.Instant与java.util.Date\nDate.from(instant)\ndate.toInstant()\n\n\njava.time.Instant与java.sql.Timestamp\nTimestamp.from(instant)\ntimestamp.toInstant()\n\n\njava.time.ZonedDateTime与java.util.GregorianCalendar\nGregorianCalendar.from(zonedDateTime)\ncal.toZonedDateTime()\n\n\njava.time.LocalDate与java.sql.Time\nDate.valueOf(localDate)\ndate.toLocalDate()\n\n\njava.time.LocalTime与java.sql.Time\nDate.valueOf(localDate)\ndate.toLocalTime()\n\n\njava.time.LocalDateTime与java.sql.Timestamp\nTimestamp.valueOf(localDateTime)\ntimestamp.toLocalDateTime()\n\n\njava.time.ZoneId与java.util.TimeZone\nTimezone.getTimeZone(id)\ntimeZone.toZoneId()\n\n\njava.time.format.DateTimeFormatter与java.text.DateFormat\nformatter.toFormat()\n无\n\n\n\n\n1.4 Java比较器在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。Java实现对象排序的方式有两种：\n\n自然排序：java.lang.Comparable\n定制排序：java.util.Comparator\n\n自然排序：java.lang.Comparable    Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。    实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。    实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。    对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。\nComparable 的典型实现：(默认都是从小到大排列的)    String：按照字符串中字符的Unicode值进行比较    Character：按照字符的Unicode值来进行比较    数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较    Boolean：true 对应的包装类实例大于 false 对应的包装类实例    Date、Time等：后面的日期时间比前面的日期时间大\n定制排序：java.util.Comparator    当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。    重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。    可以将 Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort），从而允许在排序顺序上实现精确控制。    还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。\n1.5 System类    System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。    由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。成员变量    System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。成员方法    native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。    void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。\n\nvoid gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。\nString getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：\n\n1.6 Math类ava.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。\n\n\n\n\n\n\n\n\n\n\nabs\n绝对值\n\n\nacos,asin,atan,cos,sin,tan\n三角函数\n\n\nsqrt\n平方根\n\n\npow(double a,doble b)\na的b次幂\n\n\nlog\n自然对数\n\n\nexp\ne为底指数\n\n\nmax(double a,double b)\n\n\n\nmin(double a,double b)\n\n\n\nrandom()\n返回0.0到1.0的随机数\n\n\nlong round(double a)\ndouble型数据a转换为long型（四舍五入）\n\n\ntoDegrees(double angrad)\n弧度—&gt;角度\n\n\ntoRadians(double angdeg)\n角度—&gt;弧度\n\n\n\n\n1.7 BigInteger与BigDecimalBigInteger类    Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。    java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。    构造器：BigInteger(String val)：根据字符串构建BigInteger对象\n常用方法\n\npublic BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。\nBigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger\nBigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger\nBigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger\nBigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。\nBigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。\nBigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。\nBigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。\n\nBigDecimal类​        一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。​        BigDecimal类支持不可变的、任意精度的有符号十进制定点数。构造器    public BigDecimal(double val)    public BigDecimal(String val)常用方法    public BigDecimal add(BigDecimal augend)    public BigDecimal subtract(BigDecimal subtrahend)    public BigDecimal multiply(BigDecimal multiplicand)    public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)\n2. 枚举类与注解枚举类的实现    JDK1.5之前需要自定义枚举类    JDK 1.5 新增的 enum 关键字用于定义枚举类\n\n若枚举只有一个对象, 则可以作为一种单例模式的实现方式。\n枚举类的属性    枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰    枚举类的使用 private final 修饰的属性应该在构造器中为其赋值    若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数\n\n2.1 枚举类的使用自定义枚举类\n私有化类的构造器，保证不能在类的外部创建其对象\n在类的内部创建枚举类的实例。声明为：public static final\n对象如果有实例变量，应该声明为private final，并在构造器中初始化\n\n使用关键字enum定义枚举类使用说明    使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类    枚举类的构造器只能使用 private 权限修饰符    枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰    必须在枚举类的第一行声明枚举类对象\n\nJDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。\n\nEnum类的主要方法    values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。    valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。    toString()：返回当前枚举类对象常量的名称\n\n实现接口的枚举类\n和普通 Java 类一样，枚举类可以实现一个或多个接口\n若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。\n若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法\n\n2.2 注解的使用注解(Annotation)概述    从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)    Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。    Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在Annotation的 “name=value” 对中。\n    在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。    未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。\n常见的Annotation示例    使用Annotation 时要在其前面增加 @ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素    示例一：生成文档相关的注解\n@author 标明开发该类模块的作者，多个作者之间使用,分割\n@version 标明该类模块的版本\n@see 参考转向，也就是相关主题\n@since 从哪个版本开始增加的\n@param 对方法中某参数的说明，如果没有参数就不能写\n@return 对方法返回值的说明，如果方法的返回值类型是void就不能写\n@exception 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写其中\n\n@param @return 和@exception 这三个标记都是只用于方法的。 @param的格式要求：@param 形参名形参类型 形参说明\n@return 的格式要求：@return 返回值类型返回值说明\n@exception的格式要求：@exception 异常类型异常说明\n@param和@exception可以并列多个\n\n示例二：在编译时进行格式检查(JDK内置的三个基本注解)    @Override: 限定重写父类方法, 该注解只能用于方法    @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择    @SuppressWarnings: 抑制编译器警告\n自定义Annotation\n定义新的Annotation 类型使用@interface 关键字\n自定义注解自动继承了java.lang.annotation.Annotation接口\nAnnotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。\n可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用default 关键字\n如果只有一个参数成员，建议使用参数名为value\n如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”\n没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据Annotation\n\nJDK中的元注解JDK 的元Annotation 用于修饰其他Annotation 定义\nJDK5.0提供了4个标准的meta-annotation类型，分别是：    Retention    Target    Documented    Inherited\n\n@Retention: 只能用于修饰一个Annotation 定义, 用于指定该Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值:    RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释    RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值    RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。\n\n@Target: 用于修饰Annotation 定义, 用于指定被修饰的Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。\n\n\n@Documented: 用于指定被该元Annotation 修饰的Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。    定义为Documented的注解必须设置Retention值为RUNTIME。\n\n@Inherited: 被它修饰的Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的Annotation, 则其子类将自动具有该注解。    比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解    实际应用中，使用较少\n\n\n利用反射获取注解信息（在反射部分涉及）\nJDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素\n当一个Annotation 类型被定义为运行时Annotation 后, 该注解才是运行时可见, 当 class 文件被载入时保存在 class 文件中的Annotation 才会被虚拟机读取\n程序可以调用AnnotatedElement对象的如下方法来访问Annotation 信息\n\nJDK 8中注解的新特性Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。\n类型注解：\n\nJDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE。\n在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方。    ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。    ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 \n\n","slug":"J3-常用类、枚举、注解","date":"2021-11-12T02:30:10.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"8dfa68efe4979ccc3a00434835ec3a9a","title":"异常与多线程","content":"1. 异常处理1.1 异常概述与异常体系结构异常：在Java语言中，将程序执行中发生的不正常情况\n异常事件可分为两类：\n\nError：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。\nException: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：    空指针访问    试图读取不存在的文件    网络连接中断    数组角标越界\n\n错误的处理方法\n\n遇到错误就终止程序的运行。\n由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。\n\n\n捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等\n分类：编译时异常和运行时异常\n\n运行时异常    是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。    对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n编译时异常    是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。    对于这类异常，如果程序不处理，可能会带来意想不到的结果。\n1.2 常见异常\n1.3 异常处理机制一：try-catch-finallyJava程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。\n异常对象的生成\n\n由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出\n由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样\n\n异常抛出流程\n\n如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。\n如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。\n程序员通常只能处理Exception，而对Error无能为力。\n\n异常处理是通过try-catch-finally语句实现的。\ntry{\n//可能产生异常的代码\n}\ncatch( ExceptionName1 e ){\n//当产生ExceptionName1型异常时的处置措施\n}\ncatch( ExceptionName2 e ){\n//当产生ExceptionName2型异常时的处置措施\n}\n[ finally{\n.. //无论是否发生异常，都无条件执行的语句\n}]\n\ntry捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。catch (Exceptiontype e)在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。\n\n如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。\n\n捕获异常的有关信息：\ngetMessage() 获取异常信息，返回字符串printStackTrace()  获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\nfinally\n\n捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。\n不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return， finally块中的语句都会被执行。\nfinally语句和catch语句是任选的\n\n1.4 异常处理机制二：throws​        如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\npublic void readFile(String file) throws FileNotFoundException {\n    //读文件的操作可能产生FileNotFoundException类型的异常\n    FilelnputStream fis = new FilelnputStream(file);\n}\n重写方法声明抛出异常的原则\n重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。\n1.5 手动抛出异常：throw​        Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。\nIOException e = new IOException(); throw e;\n可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：\nthrow new String(\"want to throw\");\n1.6 用户自定义异常类\n一般地，用户自定义异常类都是RuntimeException的子类。\n自定义异常类通常需要编写几个重载的构造器。\n自定义异常需要提供serialVersionUID\n自定义的异常通过throw抛出。\n自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。\n\n2 多线程2.1 基本概念：程序、进程、线程程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期    如：运行中的QQ，运行中的MP3播放器    程序是静态的，进程是动态的    进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。    若一个进程同一时间并行执行多个线程，就是支持多线程的    线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小    一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。\n并行与并发    并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。    并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。\n多线程程序的优点：\n\n提高应用程序的响应。对图形化界面更有意义，可增强用户体验。\n提高计算机系统CPU的利用率\n改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改\n\n2.2 线程的创建和使用⭐⭐Thread类的特性    每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体    通过该Thread对象的start()方法来启动这个线程，而非直接调用run()\nThread类构造器    Thread()：创建新的Thread对象    Thread(String threadname)：创建线程并指定线程实例名    Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法    Thread(Runnable target, String name)：创建新的Thread对象\nAPI中创建线程的两种方式方式一：继承Thread类\n1)    定义子类继承Thread类。2)    子类中重写Thread类中的run方法。3)    创建Thread子类对象，即创建了线程对象。4)    调用线程对象start方法：启动线程，调用run方法。\n注意点：\n\n如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。\nrun()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。\n想要启动多线程，必须调用start方法。\n一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。\n\n方式二：实现Runnable接口\n1)    定义子类，实现Runnable接口。2)    子类中重写Runnable接口中的run方法。3)    通过Thread类含参构造器创建线程对象。4)    将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。5)    调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。\n继承方式和实现方式的联系与区别\n区别    继承Thread：线程代码存放Thread子类run方法中。    实现Runnable：线程代码存在接口的子类的run方法。实现方式的好处    避免了单继承的局限性    多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。\nThread类的有关方法\nvoid start():  启动线程，并执行对象的run()方法\nrun():  线程在被调度时执行的操作\nString getName():  返回线程的名称\nvoid setName(String name):设置该线程名称\nstatic Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实类\nstatic  void  yield()：线程让步    暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程    若队列中没有同优先级的线程，忽略此方法\njoin() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止    低优先级的线程也可以获得执行\nstatic  void  sleep(long millis)：(指定时间:毫秒)    令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。    抛出InterruptedException异常\nstop(): 强制线程生命期结束，不推荐使用\nboolean isAlive()：返回boolean，判断线程是否还活着\n\n线程的调度Java的调度方法    同优先级线程组成先进先出队列（先到先服务），使用时间片策略    对高优先级，使用优先调度的抢占式策略\n线程的优先级线程的优先级等级    MAX_PRIORITY：10    MIN _PRIORITY：1    NORM_PRIORITY：5涉及的方法    getPriority() ：返回线程优先值    setPriority(int newPriority) ：改变线程的优先级说明    线程创建时继承父线程的优先级    低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用\n线程的分类Java中的线程分为两类：一种是守护线程，一种是用户线程。\n\n它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。\n守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。\nJava垃圾回收就是一个典型的守护线程。\n若JVM中都是守护线程，当前JVM将退出。\n形象理解：兔死狗烹，鸟尽弓藏\n\n2.3 线程的生命周期JDK中用Thread.State类定义了线程的几种状态\n新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束\n\n2.4 线程的同步问题的提出    多个线程执行的不确定性引起执行结果的不稳定    多个线程对账本的共享，会造成操作的不完整性，会破坏数据。\nSynchronized的使用方法对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。\n\n同步代码块：\n\nsynchronized (对象){\n// 需要被同步的代码；\n}\n\nsynchronized还可以放在方法声明中，表示整个方法为同步方法。例如：\n\npublic synchronized void show (String name){ \n...\n}\n同步机制中的锁当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。\nsynchronized的锁\n\n任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。\n同步方法的锁：静态方法（类名.class）、非静态方法（this）\n同步代码块：自己指定，很多时候也是指定为this或类名.class\n必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全\n一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）\n\n同步的范围1、如何找问题，即代码是否存在线程安全？（非常重要）\n（1）    明确哪些代码是多线程运行的代码（2）    明确多个线程是否有共享数据（3）    明确多线程运行代码中是否有多条语句操作共享数据\n2、如何解决呢？（非常重要）对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中3、切记：\n    范围太小：没锁住所有有安全问题的代码    范围太大：没发挥多线程的功能。\n释放锁的操作    当前线程的同步方法、同步代码块执行结束。    当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。    当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。    当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。\n不会释放锁的操作\n线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行\n线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。    应尽量避免使用suspend()和resume()来控制线程\n\n线程的死锁问题死锁:不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁,出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。解决方法    专门的算法、原则    尽量减少同步资源的定义    尽量避免嵌套同步\nLock(锁)    从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。    java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。    ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。\nclass A{\n    private final ReentrantLock lock = new ReenTrantLock();\n    public void m(){\n        lock.lock();\n        try{\n        \t11保证线程安全的代码;\n        }\n        finally{\n        \tlock.unlock();\n        }\n    }\n}\n//注意：如果同步代码有异常，要将unlock()写入finally语句块\nsynchronized 与 Lock 的对比\nLock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放\nLock只有代码块锁，synchronized有代码块锁和方法锁\n使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n\n2.5 线程的通信\nwait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。\nnotify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待\nnotifyAll ()：唤醒正在排队等待资源的所有线程结束等待.\n\n    这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。\nwait() 方法    在当前线程中调用方法： 对象名.wait()    使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify(或notifyAll) 为止。    调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）    调用此方法后，当前线程将释放对象监控权 ，然后进入等待    在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。\nnotify()/notifyAll()    在当前线程中调用方法： 对象名.notify()    功能：唤醒等待该对象监控权的一个/所有线程。    调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）\n2.6 JDK5.0新增线程创建方式新增方式一：实现Callable接口与使用Runnable相比， Callable功能更强大些    相比run()方法，可以有返回值    方法可以抛出异常    支持泛型的返回值    需要借助FutureTask类，比如获取返回结果\nFuture接口    可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。    FutrueTask是Futrue接口的唯一的实现类    FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值\n新增方式二：使用线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。好处：    提高响应速度（减少了创建新线程的时间）    降低资源消耗（重复利用线程池中线程，不需要每次都创建）    便于线程管理            corePoolSize：核心池的大小            maximumPoolSize：最大线程数            keepAliveTime：线程没有任务时最多保持多长时间后会终止\n线程池相关APIJDK 5.0起提供了线程池相关API：ExecutorService 和 ExecutorsExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor    void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable     Future submit(Callable task)：执行任务，有返回值，一般又来执行Callable    void shutdown() ：关闭连接池Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池    Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池    Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池    Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池    Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n","slug":"J2-异常与多线程","date":"2021-11-12T02:28:44.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"3c25c67d0781653798d002eeefd584b0","title":"环境与包管理","content":"1. Pip对 Python 包的查找、下载、安装、卸载的功能。\n1.1 pip常用命令pip的更新\npython -m pip install --upgrade pip\npip安装包\npip install 包名==版本号\npip更新包\npip install --upgrade 要更新的包名\npip删除包\npip uninstall 要卸载的包名\n1.2 pip镜像配置临时使用pip安装包的时候加参数-i 镜像源地址\npip install bs4 -i https://pypi.tuna.tsinghua.edu.cn/simple\n清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/豆瓣：http://pypi.douban.com/simple/\n永久更改Linux：修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\n[global] \nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\nwindows直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，然后新建文件pip.ini，即 %HOMEPATH%\\pip\\pip.ini，在pip.ini文件中输入以下内容（以豆瓣镜像为例）：\n[global]\nindex-url = http://pypi.douban.com/simple\n[install]\ntrusted-host = pypi.douban.com\n1.3 pip依赖迁移导出依赖\npip freeze &gt;  requirements.txt\n安装依赖\npip install -r requirements.txt\n2. Anacondaconda is a tool for managing and deploying applications, environments and packages.\n2.1 下载安装官网下载：Anaconda | The World’s Most Popular Data Science Platform\n下一步、下一步点点点，安装完成\n2.2 conda环境管理conda clean ：净化Anaconda\n# 删除索引缓存，锁定文件，未使用的缓存包，和包。\nconda clean -a\nconda compare：比较conda环境之间的包。\nconda config：配置环境的配置信息。\nconda create：创建新的conda环境。⭐⭐\n# 创建环境：conda create -n 环境名称 [python]\nconda create -n env_name python=3.8\n\n# 用 environment.yml 配置文件创建环境\nconda env create -f nvironment.yml\n\n# 导出environment.yml环境文件\nconda env_name export &gt; environment.yml \n\n\n\n\n\n\n\n\n\n坑爹：\n装新环境必须删除原镜像配置\nconda info：显示有关当前conda安装的信息。\nconda activate env_name：激活环境。⭐⭐\nconda deactivate env_name：停用环境。\nconda env remove —n env_name：删除环境\n构建相同的conda环境（不同机器间的环境复制）\n# 激活需要导出配置文件的环境\nconda list --explicit &gt; files.txt\n# 在同系统的不同机器执行\nconda create --name env_name -f files.txt\n克隆环境（同一台机器的环境复制\nconda create --name clone_env_name --clone env_name\nconda env list：查看环境列表\n2.3 conda包管理conda search [包名]：查看特定包\nconda install 包名[=版本号]：安装指定包\nconda update 包名：更新包\nconda update python：更新python\nconda list：查看当前环境的包\nconda remove 包名：删除包\n2.4 conda镜像修改conda config —remove-key channels恢复默认镜像\nconda config —add 镜像地址\n# 清华大学镜像\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge \nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/\nconda config —show：在channel里查看配置的镜像地址\n3. Jupyter notebook3.1 设置代码提示conda activate base\n\npip install jupyter_contrib_nbextensions\n\njupyter contrib nbextension install --user\n\npip install jupyter_nbextensions_configurator\n\njupyter nbextensions_configurator enable --user\n\n\n3.2 jupyter中添加conda环境查看JupyterNotebook的kernel及存放位置\nipython kernelspec list\n添加kernel\n# 首先安装ipykernel：\nconda install ipykernel\n\n# 在虚拟环境下创建kernel文件：\nconda install -n 环境名称 ipykernel\n\n# 激活conda环境，将环境写入notebook的kernel中\n\npython -m ipykernel install --user --name 环境名称 --display-name \"Python (环境名称)\"\n\n# 打开notebook服务器：jupyter notebook\n\n# 删除kernel环境：\n\njupyter kernelspec remove 环境名称\n","slug":"P3-Anaconda与jupyter notebook","date":"2021-11-11T10:25:42.000Z","categories_index":"Python","tags_index":"","author_index":"YFR718"},{"id":"4a207b7e885fdbcca8129599135e5f2e","title":"MySQL基础","content":"1 MySQL概述1.1 数据库概述数据库的好处持久化数据到本地可以实现结构化查询，方便管理\n数据库相关概念DB：数据库，保存一组有组织的数据的容器DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据SQL:结构化查询语言，用于和DBMS通信的语言\n数据库存储数据的特点\n将数据放到表中，表再放到库中\n一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。\n表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。\n表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”\n表中的数据是按行存储的，每一行类似于java中的“对象”。\n\n1.2 MySQL的背景前身属于瑞典的一家公司，MySQL AB\n08年被sun公司收购\n09年sun被oracle收购\nMySQL优点\n1、开源、免费、成本低\n2、性能高、移植性也好\n3、体积小，便于安装\n1.3 MySQL产品的介绍和安装MySQL服务的启动和停止方式一：计算机——右击管理——服务方式二：通过管理员身份运行\nnet start 服务名（启动服务）\nnet stop 服务名（停止服务）\nMySQL服务的登录和退出  方式一：通过mysql自带的客户端（只限于root用户）\n  方式二：通过windows自带的客户端\n#登录：\nmysql 【-h主机名 -P端口号 】-u用户名 -p密码\n#退出：\nexit或ctrl+C\nMySQL的语法规范不区分大小写,但建议关键字大写，表名、列名小写\n每条命令最好用分号结尾\n每条命令根据需要，可以进行缩进 或换行\n注释\n    单行注释：#注释文字\n    单行注释：-- 注释文字\n    多行注释：/* 注释文字  */\n2. 基本操作存储过程：创建数据库=&gt;确认字段=&gt;创建数据表=&gt;插入数据\n创建数据库# 展示数据库\nmysql&gt; SHOW DATABASES;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sakila             |\n| sys                |\n| world              |\n+--------------------+\n# 打开指定的库\nmysql&gt; use 库名\n# 创建数据库\nmysql&gt; CREATE DATABASE demo;\n# 删除数据库\nmysql&gt; DROP DATABASE demo;\n# 查看服务器的版本\n#方式一：登录到mysql服务端\nmysql&gt; select version();\n#方式二：没有登录到mysql服务端\nmysql --version\n或\nmysql --V\n●”information_schema”是MySQL系统自带的数据库,主要保存MySQL数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件所在的文件夹和系统使用的文件夹，等等。●”performance_ schema”是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。●“sys” 数据库是MySQL系统自带的数据库，主要作用是，以一种更容易被理解的方式展示MySQL数据库服务器的各类性能指标，帮助系统管理员和开发人员监控MySQL的技术性能。●”mysql”数据库保存了MySQL数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等。\n确认字段MySQL数据表由行与列组成，一行就是一条数据记录， 每一条数据记录都被分成许多列，一列就叫一个字段。每个字段都需要定义数据类型，这个数据类型叫做字段类型。\n创建数据表#展示数据表\nmysql&gt; SHOW TABLES;\n+----------------+\n| Tables_in_demo |\n+----------------+\n| test           |\n+----------------+\n# 查看其它库的所有表\nmysql&gt; show tables from 库名;\n#创建数据表\nmysql&gt; CREATE TABLE demo.test(barcode text,goodname text,price int);\n# 查看表结构\nmysql&gt; desc 表名;\nmysql&gt; show columns from actor;\nmysql&gt; DESCRIBE demo.test;\n+----------+---------+------+-----+---------+-------+\n| Field    | Type    | Null | Key | Default | Extra |\n+----------+---------+------+-----+---------+-------+\n| barcode  | text    | YES  |     | NULL    |       |\n| goodname | text    | YES  |     | NULL    |       |\n| price    | int(11) | YES  |     | NULL    |       |\n+----------+---------+------+-----+---------+-------+\n●Field: 表示字段名称。●Type: 表示字段类型。●Null: 表示这个字段是否允许是空值(NULL) 。在MySQL里面,空值不等于空字符串。一个空字符串的长度是0,而一个空值的长度是空。而且，在MySQL里面，空值是占用空间的。●Key:我们暂时把它叫做键。●Default: 表示默认值。我们导入的表的所有的字段都允许是空，默认值都是NULL。●Extra:表示附加信息。\n#其他show语句\n❑ SHOW STATUS，用于显示广泛的服务器状态信息；\n❑ SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句；\n❑ SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；\n❑ SHOW ERRORS 和 SHOW WARNINGS，用来显示服务器错误或警告消息。\n插入数据#添加主键\nALTER TABLE demo. test\nADD COLUMN itemnumber int PRIMARY KEY AUTO_INCREMENT ;\n#向表中添加数据\nINSERT INTO demo.test\n(barcode, goodsname,price)\nVALUES ('0001','本' ,3);\n\nSQL的语言分类DQL（Data Query Language）：数据查询语言\n    select \nDML(Data Manipulate Language):数据操作语言\n    insert 、update、delete\nDDL（Data Define Languge）：数据定义语言\n    create、drop、alter\nTCL（Transaction Control Language）：事务控制语言\n    commit、rollback\n3. DQL语言数据查询语言：select \n/*\n类似于Java中 :System.out.println(要打印的东西);\n特点：\n①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在\n② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数*/\n\n#检索单个列\nmysql&gt; SELECT 列名 FROM 表名;\n#检索多个列\nmysql&gt; SELECT 列名,列名... FROM 表名;\n#检索所有列\nmysql&gt; SELECT * FROM 表名;\n#使用完全限定的名字\nmysql&gt; SELECT 表名.列名 FROM 数据库.表名;\n#拼接计算字段\nmysql&gt; SELECT CONCAT(列名，列名) FROM 表名;\n#计算字段运算\nmysql&gt; SELECT 列名*5 FROM 表名;\n\n\n\n\n子句\n功能\n示例\n\n\n\n\nDISTINCT\n去重\nSELECT DISTINCT 列名 FROM 表名;\n\n\nLIMIT\n限制行数\nSELECT 列名 FROM 表名 LIMIT 10;SELECT 列名 FROM 表名 LIMIT 10,3; #从行10开始取3行\n\n\nORDER BY\n排序\nSELECT 列名 FROM 表名 ORDER BY 列名 LIMIT 10;   //先排序再取10SELECT 列名 FROM 表名 ORDER BY 列名,列名..;     //按多个列排序\n\n\nDESC\n降序排\nSELECT 列名 FROM 表名 ORDER BY 列名 DESC;\n\n\nASC\n升序排\n与不加相同\n\n\nWHERE\n数据过滤\nSELECT 列名 FROM 表名 WHERE 条件;\n\n\nGROUP BY\n分组数据\nSELECT 列名 FROM 表名 GROUP BY 列名;\n\n\nHAVING\n过滤基于分组值\nSELECT 列名 FROM 表名 GROUP BY 列名 HAVING COUNT(*)&gt;=2;;\n\n\nUNION (ALL)\n组合查询\n执行多条SELECT语句，并将结果作为单个查询结果集返回\n\n\n\n\nSELECT子句顺序\n\n\n\n子句\n说明\n是否必须使用\n\n\n\n\nSELECT\n要返回的列\n是\n\n\nFROM\n要检索的表\n仅在表中选择数据\n\n\nWHERE\n行过滤\n否\n\n\nGROUP BY\n分组说明\n仅在按组计算聚集时\n\n\nHAVING\n组过滤\n否\n\n\nORDER BY\n排序\n否\n\n\nLIMIT\n要检索的行数\n否\n\n\n\n\nWHERE子句操作符\n\n\n\n操作符\n说明\n\n\n\n\n=\n等于\n\n\n&lt;&gt;或!=\n不等于\n\n\n&lt;,&lt;=,&gt;,&gt;=\n小于大于\n\n\nBETWEEN A AND B\n[A,B]\n\n\nIS NULL\n空值检查\n\n\nAND OR NOT\n与 或 非\n\n\nIN (A,B)\n集合范围匹配\n\n\n()\n优先运算括号里的\n\n\nLIKE\n通配符\n\n\n\n\n优先级：AND&gt;OR\n通配符LIKE用法\n\n\n\n通配符\n含义\n示例\n\n\n\n\n%\n任何字符出现任意次数\nWHERE 列名 LIKE ‘yfr%’：\n\n\n_\n只匹配单个字符\nWHERE 列名 LIKE ‘yfr_’：\n\n\n\n\n正则表达式\n\n\n\n关键字\n含义\n示例\n\n\n\n\nREGEXP\n包含\nwhere 列名 REGEXP ‘400’;\n\n\nBINARY\n不区分大小匹配\nwhere 列名 REGEXP BINARY  ‘AS’;\n\n\n\\\n\nOR匹配\nwhere 列名 REGEXP ‘400\\\n500’;\n\n\n[123]\n匹配几个字符之一\nwhere 列名 REGEXP ‘[123]400’;\n\n\n123\n匹配几个字符之外所有\nwhere 列名 REGEXP ‘[\\^123]400’;\n\n\n[0-9]\n范围匹配\nwhere 列名 REGEXP ‘[0-9]400’;\n\n\n\\\\\n匹配特殊字符．、[]、\n和-where 列名 REGEXP ‘\\400’;\n\n\n字符类\n匹配字符类\n[ :alpha: ] [:blank:]等等\n\n\n{n,m}\n匹配数目范围\nwhere 列名 REGEXP ‘[0-9]{1,}’;匹配一次以上\n\n\n[[:&lt;:]]、[[:&gt;:]]、$、^\n定位符：词的开始/尾，文本的开始/尾\nwhere 列名 REGEXP ‘^[0-9]’;\n\n\n\n\n函数文本处理函数\n\n\n\n函数\n\n\n\n\n\nConcat()\n拼接\n\n\nUpper()\n转换成大写\n\n\nLower()\n转换成小写\n\n\nTrim()\n去前后指定的空格和字符\n\n\nLeft()\n返回串左边的字符\n\n\nLength()\n返回串的长度\n\n\nLocate()\n找出串的一个子串\n\n\nLower()\n将串转换为小写\n\n\nLTrim()\n去掉串左边的空格\n\n\nRight()\n返回串右边的字符\n\n\nRTrim()\n去掉串右边的空格\n\n\nSoundex()\n返回串的SOUNDEX值\n\n\nSubString()\n返回子串的字符\n\n\nUpper()\n将串转换为大写\n\n\nReplace()\n替换\n\n\nLpad()\n左填充\n\n\nRpad()\n右填充\n\n\nInstr()\n返回子串第一次出现的索引\n\n\n\n\n数值和日期时间处理函数\n\n\n\n数值函数\n日期函数\n\n\n\n\nAbs()\nAddData()\n\n\nCos()\nAddTime()\n\n\nExp()\nCurData() 当前系统日期\n\n\nMod() 取余\nDate()\n\n\nPi()\nDay()\n\n\nRand()  随机数\nHour()\n\n\nSin()\nMinute()\n\n\nSqrt()\nNow() 当前系统日期+时间\n\n\nTan()\nYear()\n\n\nRound() 四舍五入\nCurtime() 当前系统时间\n\n\nFloor() 向下取整\nStr_to_date() 将字符转换成日期\n\n\nCeil() 向上取整\nDate_format() 将日期转换成字符\n\n\nTruncate() 截断\n\n\n\n\nSQL聚集函数\n\n\n\n函数\n\n\n\n\n\nAVG()\nmysql&gt; SELECT AVG(列名) from 表名;\n\n\nCOUNT()\nmysql&gt; SELECT COUNT(列名) from 表名;\n\n\nMAX()\nmysql&gt; SELECT MAX(列名) from 表名;\n\n\nMIN()\nmysql&gt; SELECT MIN(列名) from 表名;\n\n\nSUM()\nmysql&gt; SELECT SUM(列名) from 表名;\n\n\n\n\n特点：\n1、以上五个分组函数都忽略null值，除了count(*)\n2、sum和avg一般用于处理数值型\n    max、min、count可以处理任何数据类型\n3、都可以搭配distinct使用，用于统计去重后的结果\n4、count的参数可以支持：\n    字段、*、常量值，一般放1\n\n   建议使用 count(*)\n流程控制函数\n\n\n\n函数\n\n\n\n\n\nIF(判断条件，返回1，返回2)\n\n\n\ncase语句\n处理多分支：处理等值判断、处理条件判断\n\n\n\n\n\n\n\n其他函数\n\n\n\n函数\n\n\n\n\n\nversion() 版本\n\n\n\ndatabase() 当前库\n\n\n\nuser() 当前连接用户\n\n\n\npassword(‘字符’)：返回该字符的密码形式\n\n\n\nmd5(‘字符’):返回该字符的md5加密形式\n\n\n\n\n子查询嵌套在其他查询中的查询,在外面的查询语句，称为主查询或外查询。\nSELECT cust_id\nFROM orders\nWHERE order_num IN (SELECT order_num\n                     FROM orderitems\n                     WHERE prod_id = 'TNT2');\n/*\n1、子查询都放在小括号内\n2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧\n3、子查询优先于主查询执行，主查询使用了子查询的执行结果\n4、子查询根据查询结果的行数不同分为以下两类：\n① 单行子查询\n\t结果集只有一行\n\t一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= \n\t非法使用子查询的情况：\n\ta、子查询的结果为一组值\n\tb、子查询的结果为空\n\t\n② 多行子查询\n\t结果集有多行\n\t一般搭配多行操作符使用：any、all、in、not in\n\tin： 属于子查询结果中的任意一个就行\n\tany和all往往可以用其他查询代替\n\t*/\n连接表jion联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。\n#等值联结（equijoin）\nSELECT *\nFROM A,B\nWHERE A.c=B.c;\n\n1.等值连接的结果 = 多个表的交集\n2.n表连接，至少需要n-1个连接条件\n3.多个表不分主次，没有顺序要求\n4.一般为表起别名，提高阅读性和性能\n\n#内部联结\nSELECT *\nFROM A INNER JOIN B\nWHERE A.c=B.c;\n#自然联结\nSELECT *\nFROM A AS a,A AS b\nWHERE a.c=b.c;\n#外部联结\nSELECT *\nFROM A OUTER JOIN B\nWHERE A.c=B.c;\n性能考虑 MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。\n\n自然联结：无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。自然联结排除多次出现，使每个列只返回一次。\n外部联结：许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。\n\nsql99语法：通过join关键字实现连接含义：1999年推出的sql语法\n支持：\n等值连接、非等值连接 （内连接）\n外连接\n交叉连接\n\n语法：\n\nselect 字段，...\nfrom 表1\n【inner|left outer|right outer|cross】join 表2 on  连接条件\n【inner|left outer|right outer|cross】join 表3 on  连接条件\n【where 筛选条件】\n【group by 分组字段】\n【having 分组后的筛选条件】\n【order by 排序的字段或表达式】\n\n好处：语句上，连接条件和筛选条件实现了分离，简洁明了！\n别名AS:别名简化编码\nSELECT name as n\nFROM papa as p,Baba as b\nWHERE p.c=b.c;\n分页查询应用场景：实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句\nselect 字段|表达式,...\nfrom 表\n【where 条件】\n【group by 分组字段】\n【having 条件】\n【order by 排序的字段】\nlimit 【起始的条目索引，】条目数;\n特点：\n1.起始条目索引从0开始\n\n2.limit子句放在查询语句的最后\n\n3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage\n假如:\n每页显示条目数sizePerPage\n要显示的页数 page\n联合查询union 联合、合并\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】\n.....\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】\n特点：\n1、多条查询语句的查询的列数必须是一致的\n2、多条查询语句的查询的列的类型几乎相同\n3、union代表去重，union all代表不去重\n4. DML语言数据操作语言：insert、update、delete\n4.1 插入语法：\ninsert into 表名(字段名，...)\nvalues(值1，...);\n\n# 支持一次插入多行，语法如下：\ninsert into 表名【(字段名,..)】 values(值，..),(值，...),...;\n\n#支持子查询，语法如下：\ninsert into 表名 查询语句;\n\ninsert into 表名 set 字段=值,字段=值,...;\n特点：\n\n字段类型和值类型一致或兼容，而且一一对应\n可以为空的字段，可以不用插入值，或用null填充\n不可以为空的字段，必须插入值\n字段个数和值的个数必须一致\n字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致\n\n4.2 修改修改单表语法：\nupdate 表名 set 字段=新值,字段=新值\n【where 条件】\n修改多表语法：\nupdate 表1 别名1,表2 别名2\nset 字段=新值，字段=新值\nwhere 连接条件\nand 筛选条件\n4.3 删除方式1：delete语句单表的删除： ★\ndelete from 表名 【where 筛选条件】\n多表的删除：    delete 别名1，别名2    from 表1 别名1，表2 别名2    where 连接条件    and 筛选条件;\n方式2：truncate语句truncate table 表名\n两种方式的区别【面试题】\n#1.truncate不能加where条件，而delete可以加where条件\n\n#2.truncate的效率高一丢丢\n\n#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始\n#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始\n\n#4.truncate删除不能回滚，delete删除可以回滚\n5. DDL语言数据定义语言：create、drop、alter\n5.1 库和表的管理一、创建库\ncreate database 库名\n二、删除库\ndrop database 库名\n5.2 创建表 createcreate table 表名(\n  字段名 字段类型 not null,#非空\n  字段名 字段类型 primary key,#主键\n  字段名 字段类型 unique,#唯一\n  字段名 字段类型 default 值,#默认\n  constraint 约束名 foreign key(字段名) references 主表（被引用列）\n)\nCREATE TABLE IF NOT EXISTS stuinfo(\n\tstuId INT,\n\tstuName VARCHAR(20),\n\tgender CHAR,\n\tbornDate DATETIME\n);\nDESC studentinfo;\n\n\n\n\n\n支持类型\n可以起约束名\n\n\n\n\n列级约束\n除了外键\n不可以\n\n\n表级约束\n除了非空和默认\n可以，但对主键无效\n\n\n\n\n列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求\n常见类型\n\n常见约束\nNOT NULL：非空，该字段的值必填\nUNIQUE：唯一，该字段的值不可重复\nDEFAULT：默认，该字段的值不用手动插入有默认值\nCHECK：检查，mysql不支持\nPRIMARY KEY：主键，该字段的值不可重复并且非空 unique+not null\nFOREIGN KEY：外键，该字段的值引用了另外的表的字段\n主键和唯一\n1、区别：\n①、一个表至多有一个主键，但可以有多个唯一\n②、主键不允许为空，唯一可以为空\n2、相同点\n都具有唯一性，都支持组合键，但不推荐\n外键：\n\n用于限制两个表的关系，从表的字段值引用了主表的某字段值\n外键列和主表的被引用列要求类型一致，意义一样，名称无要求\n主表的被引用列要求是一个key（一般就是主键）\n插入数据，先插入主表，删除数据，先删除从表\n\n可以通过以下两种方式来删除主表的记录\n#方式一：级联删除\nALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;\n\n#方式二：级联置空\nALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;\n自增长列特点：\n\n不用手动插入值，可以自动提供序列值，默认从1开始，步长为1\n\n如果要更改起始值：手动插入值\n如果要更改步长：更改系统变量\nset auto_increment_increment=值;\n\n一个表至多有一个自增长列\n\n自增长列只能支持数值型\n\n自增长列必须为一个key\n\n\n创建表时设置自增长列\ncreate table 表(\n\t字段名 字段类型 约束 auto_increment\n)\n修改表时设置自增长列\nalter table 表 modify column 字段名 字段类型 约束 auto_increment\n删除自增长列\nalter table 表 modify column 字段名 字段类型 约束 \n5.3 修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;\n\n#修改字段名\nALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;\n\n#修改表名\nALTER TABLE stuinfo RENAME [TO]  studentinfo;\n\n#修改字段类型和列级约束\nALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;\n\n#添加字段\nALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;\n\n#删除字段\nALTER TABLE studentinfo DROP COLUMN email;\n\n#添加列\nalter table 表名 add column 列名 类型 【first|after 字段名】;\n\n#修改列名\nalter table 表名 change column 旧列名 新列名 类型;\n\n#删除列\nalter table 表名 drop column 列名;\n\n修改表时添加或删除约束\n1、非空\n添加非空\nalter table 表名 modify column 字段名 字段类型 not null;\n删除非空\nalter table 表名 modify column 字段名 字段类型 ;\n\n2、默认\n添加默认\nalter table 表名 modify column 字段名 字段类型 default 值;\n删除默认\nalter table 表名 modify column 字段名 字段类型 ;\n3、主键\n添加主键\nalter table 表名 add【 constraint 约束名】 primary key(字段名);\n删除主键\nalter table 表名 drop primary key;\n\n4、唯一\n添加唯一\nalter table 表名 add【 constraint 约束名】 unique(字段名);\n删除唯一\nalter table 表名 drop index 索引名;\n5、外键\n添加外键\nalter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;\n删除外键\nalter table 表名 drop foreign key 约束名;\n\n5.4 删除表DROP TABLE [IF EXISTS] studentinfo;\n复制表\n\n复制表的结构create table 表名 like 旧表;\n复制表的结构+数据create table 表名select 查询列表 from 旧表【where 筛选】;\n\n6. TCL语言事务控制语言：commit、rollback\n6.1 数据库事务含义：通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态\n特点（ACID）：\n\n原子性：要么都执行，要么都回滚\n一致性：保证数据的状态操作前和操作后保持一致\n隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰\n持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改\n\n相关步骤：\n开启事务\n编写事务的一组逻辑操作单元（多条sql语句）\n提交事务或回滚事务\n\n事务的分类：隐式事务，没有明显的开启和结束事务的标志，比如 insert、update、delete语句本身就是一个事务\n显式事务，具有明显的开启和结束事务的标志\n1、开启事务\n取消自动提交事务的功能\n\n2、编写事务的一组逻辑操作单元（多条sql语句）\ninsert\nupdate\ndelete\n\n3、提交事务或回滚事务\n使用到的关键字set autocommit=0;\nstart transaction;\ncommit;\nrollback;\n\nsavepoint  断点\ncommit to 断点\nrollback to 断点\n事务的隔离级别:事务并发问题如何发生？\n\n\n\n\n\n\n\n\n\n当多个事务同时操作同一个数据库的相同数据时\n事务的并发问题有哪些？\n\n\n\n\n\n\n\n\n\n脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据\n如何避免事务的并发问题？\n\n\n\n\n\n\n\n\n\n通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读\n设置隔离级别：\nset session|global  transaction isolation level 隔离级别名;\n查看隔离级别：\nselect @@tx_isolation;\n7. 视图含义：理解成一张虚拟的表\n视图和表的区别：\n\n\n\n\n\n使用方式\n占用物理空间\n\n\n\n\n视图\n完全相同\n占用物理空间\n\n\n表\n完全相同\n占用\n\n\n\n\n\n\n\n\n视图的好处：\n\nsql语句提高重用性，效率高\n和表实现了分离，提高了安全性\n\n7.1 视图的创建、删除、查看CREATE VIEW  视图名\nAS\n查询语句;\n\n#视图的删除\nDROP VIEW test_v1,test_v2,test_v3;\n\n###视图结构的查看\t\nDESC test_v7;\nSHOW CREATE VIEW test_v7;\n7.2 视图的增删改查1、查看视图的数据 ★\nSELECT * FROM my_v4;\nSELECT * FROM my_v1 WHERE last_name='Partners';\n\n2、插入视图的数据\nINSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);\n\n3、修改视图的数据\nUPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';\n\n4、删除视图的数据\nDELETE FROM my_v4;\n​    \n7.3 某些视图不能更新​    包含以下关键字的sql语句：\n\n分组函数、distinct、group  by、having、union或者union all\n常量视图\nSelect中包含子查询\njoin\nfrom一个不能更新的视图\nwhere子句的子查询引用了from子句中的表\n\n\n7.4 视图逻辑的更新#方式一：\nCREATE OR REPLACE VIEW test_v7\nAS\nSELECT last_name FROM employees\nWHERE employee_id&gt;100;\n\n#方式二:\nALTER VIEW test_v7\nAS\nSELECT employee_id FROM employees;\n\nSELECT * FROM test_v7;\n8 存储过程含义：一组经过预先编译的sql语句的集合好处：\n\n提高了sql语句的重用性，减少了开发程序员的压力\n提高了效率\n减少了传输次数\n\n分类：\n1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个\n8.1 创建存储过程语法：\ncreate procedure 存储过程名(in|out|inout 参数名  参数类型,...)\nbegin\n\t存储过程体\nend\n类似于方法：\n修饰符 返回类型 方法名(参数类型 参数名,...){\n\n\t方法体;\n}\n注意\n\n需要设置新的结束标记delimiter 新的结束标记\n\n示例：\ndelimiter $\n\nCREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)\nBEGIN\n\tsql语句1;\n\tsql语句2;\n\nEND $\n\n\n存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end\n\n参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出\n\n\n8.2 调用存储过程call 存储过程名(实参列表)\n学过的函数：LENGTH、SUBSTR、CONCAT等语法：\nCREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型\nBEGIN\n\t函数体\n\nEND\n调用函数：SELECT 函数名（实参列表）\n函数和存储过程的区别\n\n\n\n\n\n关键字\n调用语法\n返回值\n应用场景\n\n\n\n\n函数\nFUNCTION\nSELECT\n只能是一个\n一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个\n\n\n存储过程\nPROCEDURE\nCALL\n可以有0个或多个\n一般用于更新\n\n\n\n\n8.3 查看存储过程show create procedure 存储过程名;\n8.4 删除drop procedure 存储过程名;\n9 流程控制结构9.1 系统变量全局变量\n作用域：针对于所有会话（连接）有效，但不能跨重启\n查看所有全局变量\nSHOW GLOBAL VARIABLES;\n查看满足条件的部分系统变量\nSHOW GLOBAL VARIABLES LIKE '%char%';\n查看指定的系统变量的值\nSELECT @@global.autocommit;\n为某个系统变量赋值\nSET @@global.autocommit=0;\nSET GLOBAL autocommit=0;\n会话变量\n作用域：针对于当前会话（连接）有效\n查看所有会话变量\nSHOW SESSION VARIABLES;\n查看满足条件的部分会话变量\nSHOW SESSION VARIABLES LIKE '%char%';\n查看指定的会话变量的值\nSELECT @@autocommit;\nSELECT @@session.tx_isolation;\n为某个会话变量赋值\nSET @@session.tx_isolation='read-uncommitted';\nSET SESSION tx_isolation='read-committed';\n9.2 自定义变量用户变量\n声明并初始化：\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名:=值;\n赋值：\n方式一：一般用于赋简单的值\nSET 变量名=值;\nSET 变量名:=值;\nSELECT 变量名:=值;\n方式二：一般用于赋表 中的字段值\nSELECT 字段名或表达式 INTO 变量\nFROM 表;\n使用：\nselect @变量名;\n局部变量\n声明：\ndeclare 变量名 类型 【default 值】;\n赋值：\n方式一：一般用于赋简单的值\nSET 变量名=值;\nSET 变量名:=值;\nSELECT 变量名:=值;\n方式二：一般用于赋表 中的字段值\nSELECT 字段名或表达式 INTO 变量\nFROM 表;\n使用：\nselect 变量名\n二者的区别：\n\n\n\n\n\n作用域\n定义位置\n语法\n\n\n\n\n语法\n当前会话\n会话的任何地方\n加@符号，不用指定类型\n\n\n局部变量\n定义它的BEGIN END中\nBEGIN END的第一句话\n一般不用加@,需要指定类型\n\n\n\n\n9.3 分支if函数    语法：if(条件，值1，值2)    特点：可以用在任何位置\ncase语句\n情况一：类似于switch\ncase 表达式\nwhen 值1 then 结果1或语句1(如果是语句，需要加分号) \nwhen 值2 then 结果2或语句2(如果是语句，需要加分号)\n...\nelse 结果n或语句n(如果是语句，需要加分号)\nend 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）\n\n情况二：类似于多重if\ncase \nwhen 条件1 then 结果1或语句1(如果是语句，需要加分号) \nwhen 条件2 then 结果2或语句2(如果是语句，需要加分号)\n...\nelse 结果n或语句n(如果是语句，需要加分号)\nend 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）\n特点：可以用在任何位置\nif elseif语句\nif 情况1 then 语句1;\nelseif 情况2 then 语句2;\n...\nelse 语句n;\nend if;\n特点：只能用在begin end中！！！！！！！！！！！！！！！应用场合\n\nif函数：简单双分支\ncase结构：等值判断 的多分支\nif结构：区间判断 的多分支\n\n9.4 循环【标签：】WHILE 循环条件  DO\n    循环体\nEND WHILE 【标签】;\n特点：\n只能放在BEGIN END里面\n如果要搭配leave跳转语句，需要使用标签，否则可以不用标签\nleave类似于java中的break语句，跳出所在循环！！！\n","slug":"MySQL基础","date":"2021-11-10T12:30:04.000Z","categories_index":"数据库","tags_index":"MySQL","author_index":"YFR718"},{"id":"31135c47a98e6bfd7ef6f55be399b5e8","title":"PyMySQL","content":"1. 连接数据库import pymysql\n\n# 创建连接对象\nconn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')\n\n# 获取游标对象\ncursor = conn.cursor()\n\n# 关闭游标\ncursor.close()\n\n# 关闭连接\nconn.close()\n2. 数据库操作2.1 DQL语言selectselect选择\n# 查询 SQL 语句\nsql = \"select * from students;\"\n# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数\nrow_count = cursor.execute(sql)\n\n# 取出结果集中一行数据,　例如:(1, '张三')\nprint(cursor.fetchone())\n\n# 取出结果集中的所有数据, 例如:((1, '张三'), (2, '李四'), (3, '王五'))\nfor line in cursor.fetchall():\n    print(line)\n        \nPython查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。\n\nfetchone(): 该方法获取下一个查询结果集。结果集是一个对象\n\nfetchall(): 接收全部的返回结果行.\n\nrowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。\n\n\n2.2 DML数据操作语言insert 、update、deleteinsert插入\n# SQL 插入语句\nsql = \"\"\"INSERT INTO EMPLOYEE(FIRST_NAME,\n         LAST_NAME, AGE, SEX, INCOME)\n         VALUES ('Mac', 'Mohan', 20, 'M', 2000)\"\"\"\ntry:\n   # 执行sql语句\n   cursor.execute(sql)\n   # 提交到数据库执行\n   db.commit()\nexcept:\n   # 如果发生错误则回滚\n   db.rollback()\n插入多行数据时，数据是list，其中元素是元组。\n# 一次插入多行数据\n# print(value)\nsql = 'insert into summary(id,dataname,herf,rel) values(%s,%s,%s,%s)'\nvalue = []\nfor rep in root.findall('repository'):\n    id = rep.find('id').text\n    dataname = rep.find('name').text\n    herf = rep.find('link').attrib['href']\n    rel = rep.find('link').attrib['rel']\n    value.append((id,dataname,herf,rel))\n    \ntry:\n    cursor.executemany(sql,value)\n    db.commit()\n    print(\"summary写入成功\")\nexcept Exception as e:\n    print(e)\n    db.rollback()\n    print(\"summary写入失败\")\nfinally:\n    db.close()\n\nupdate更新\n# SQL 更新语句\nsql = \"UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'\" % ('M')\ntry:\n   # 执行SQL语句\n   cursor.execute(sql)\n   # 提交到数据库执行\n   db.commit()\nexcept:\n   # 发生错误时回滚\n   db.rollback()\ndelete删除\n# SQL 删除语句\nsql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; %s\" % (20)\ntry:\n   # 执行SQL语句\n   cursor.execute(sql)\n   # 提交修改\n   db.commit()\nexcept:\n   # 发生错误时回滚\n   db.rollback()\n2.3 DDL数据定义语言create、drop、altercreate创建数据表\n# 使用 cursor() 方法创建一个游标对象 cursor\ncursor = db.cursor()\n \n\n# 使用预处理语句创建表\nsql = \"\"\"CREATE TABLE EMPLOYEE (\n         FIRST_NAME  CHAR(20) NOT NULL,\n         LAST_NAME  CHAR(20),\n         AGE INT,  \n         SEX CHAR(1),\n         INCOME FLOAT )\"\"\"\n \ncursor.execute(sql)\ndrop删除数据表\n# 使用 execute() 方法执行 SQL，如果表存在则删除\ncursor.execute(\"DROP TABLE IF EXISTS EMPLOYEE\")\n \nalter更改数据表\n2.4 TCL事务控制语言commit、rollback# SQL删除记录语句\nsql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; %s\" % (20)\ntry:\n   # 执行SQL语句\n   cursor.execute(sql)\n   # 向数据库提交\n   db.commit()\nexcept:\n   # 发生错误时回滚\n   db.rollback()\n","slug":"P2-PyMySQL","date":"2021-11-10T02:06:01.000Z","categories_index":"Python","tags_index":"MySQL","author_index":"YFR718"},{"id":"446bbf5d6e6c49aba6d56562199f8a0a","title":"XML解析","content":"1 xml.etree.ElementTree对Python的轻量级XML支持。\nXML是一种固有的分层数据格式，最自然的表示方法是使用树。这个模块有两个类用于此目的:\n\nElementTree将整个XML文档表示为树。\n元素表示此树中的单个节点。\n\n​        与整个文档的交互(对文件的读写)通常在ElementTree级别完成。与单个XML元素及其子元素的交互是在element级别上完成的。\n​        元素是一种灵活的容器对象，用于在内存中存储分层数据结构。它可以被描述为介于列表和字典之间的混合体。每个元素都有许多与之相关的属性:\n\n‘tag’——包含元素名称的字符串。\n‘attributes’——一个存储元素属性的Python字典。\n‘text’ -一个包含元素文本内容的字符串。\n‘tail’ -一个可选字符串，在元素的结束标签之后包含文本。以及一系列存储在Python序列中的子元素。\n\n​        要创建元素实例，请使用element构造函数或SubElement工厂函数。还可以使用ElementTree类包装元素结构，并将其与XML进行转换。\n1.1 导入数据从xml文件导入\nimport xml.etree.ElementTree as ET\ntree = ET.parse('country_data.xml')\nroot = tree.getroot()\n从html导入\nimport xml.etree.ElementTree as ET\n# 要爬取的地址\nurl = \"https://www.re3data.org/api/v1/repositories\"\nres = requests.get(url)\nroot = ET.fromstring(res.text)\n1.2 数据查询1.2.1 获取四个属性print(root.tag)\nprint(root.attrib)\nprint(root.tail)\nprint(res.text)\n1.2.2 访问子节点用 len(Element) 检查子节点个数\n用 Element[0] 访问第0个子节点，Element[1] 访问第1个子节点…\n用 for child in Element 遍历所有子节点\n用 Element.remove(child) 删除某个子节点\nfor i in root:\n    print(i.tag)\n1.2.3 查询指定标签\nElementt.iter() #递归迭代xml文件中所有节点（包含子节点，以及子节点的子节点），返回一个包含所有节点的迭代器\nElement.find(tag) #查找第一个节点为tag的直接子元素，返回一个节点对象\nElement.findall(tag) #查找节点为tag的所有直接子元素’，返回一个节点列表直接子元素的意思：只会查找当前节点的子节点那一级目录\n\nfor rep in root.findall('repository'):\n    # print(rep.find('id').text)\n    # print(rep.find('name').text)\n    print(rep.find('link').attrib['href'],rep.find('link').attrib['rel'])\n处理含namespace的文件\nnamespace = \"{http://www.re3data.org/schema/2-2}\"\nfor element in root.iter(namespace + \"re3data.orgIdentifier\"):  # ID\n    print(\"1#   \", element.text)\n    ID = element.text\n1.2.4 树结构与 XML 字符串的相互转换使用 xml.etree.ElementTree 包中的 tostring() 和 fromstring() 函数：\n\n如果 tostring() 参数不指定 encoding=\"unicode\"，函数将返回 byte 序列。\n\nfrom xml.etree.ElementTree import Element, tostring\n\ntree_str = tostring(root, encoding=\"unicode\")\n\nnew_root = fromstring(tree_str)\nprint(new_root.tag, new_root[0].tag, new_root[1].tag)\n1.3 数据创建1.3.1 创建树节点创建树节点时，一定要指定节点名：\ntree_node = Element(\"node1\")\nprint(tree_node.tag)    # 输出 node1\nprint(tree_node.text)   # 输出 None\nprint(tree_node.tail)   # 输出 None\nprint(tree_node.attrib) # 输出 {}\n也可在创建时指定属性（Element.attrib）：\ntree_node = Element(\"node2\", {\"attr1\": 1, \"attr2\": 2})\nprint(tree_node.tag)    # 输出 node2\nprint(tree_node.text)   # 输出 None\nprint(tree_node.tail)   # 输出 None\nprint(tree_node.attrib) # 输出 {'attr1': 1, 'attr2': 2}\n1.3.2 设置文本（Element.text）或附加文本（Element.tail）创建节点后，可以设置 text, tail 等类成员。这些成员的初始值为 None。\ntree_node = Element(\"node1\")\ntree_node.text = \"Hello world\"\ntree_node.tail = \"Bye\"\n1.3.3 添加子节点可以用 Element.append() 成员函数添加子节点：\nroot = Element(\"root\")\nchild1 = Element(\"child1\")\nchild2 = Element(\"child2\")\n\nroot.append(child1)\nroot.append(child2)\n","slug":"P1-XML解析","date":"2021-11-10T01:23:54.000Z","categories_index":"Python","tags_index":"XML","author_index":"YFR718"},{"id":"0e809b380a45c732473fb3fa1636bd4c","title":"ASCII码","content":"ASCII码表格：\n\n\n\n\nASCII值\n控制字符\nASCII值\n字符\nASCII值\n字符\nASCII值\n字符\n\n\n\n\n0\nNUT\n32\n(space)\n64\n@\n96\n、\n\n\n1\nSOH\n33\n!\n65\nA\n97\na\n\n\n2\nSTX\n34\n“\n66\nB\n98\nb\n\n\n3\nETX\n35\n#\n67\nC\n99\nc\n\n\n4\nEOT\n36\n$\n68\nD\n100\nd\n\n\n5\nENQ\n37\n%\n69\nE\n101\ne\n\n\n6\nACK\n38\n&amp;\n70\nF\n102\nf\n\n\n7\nBEL\n39\n,\n71\nG\n103\ng\n\n\n8\nBS\n40\n(\n72\nH\n104\nh\n\n\n9\nHT\n41\n)\n73\nI\n105\ni\n\n\n10\nLF\n42\n*\n74\nJ\n106\nj\n\n\n11\nVT\n43\n+\n75\nK\n107\nk\n\n\n12\nFF\n44\n,\n76\nL\n108\nl\n\n\n13\nCR\n45\n-\n77\nM\n109\nm\n\n\n14\nSO\n46\n.\n78\nN\n110\nn\n\n\n15\nSI\n47\n/\n79\nO\n111\no\n\n\n16\nDLE\n48\n0\n80\nP\n112\np\n\n\n17\nDCI\n49\n1\n81\nQ\n113\nq\n\n\n18\nDC2\n50\n2\n82\nR\n114\nr\n\n\n19\nDC3\n51\n3\n83\nS\n115\ns\n\n\n20\nDC4\n52\n4\n84\nT\n116\nt\n\n\n21\nNAK\n53\n5\n85\nU\n117\nu\n\n\n22\nSYN\n54\n6\n86\nV\n118\nv\n\n\n23\nTB\n55\n7\n87\nW\n119\nw\n\n\n24\nCAN\n56\n8\n88\nX\n120\nx\n\n\n25\nEM\n57\n9\n89\nY\n121\ny\n\n\n26\nSUB\n58\n:\n90\nZ\n122\nz\n\n\n27\nESC\n59\n;\n91\n[\n123\n{\n\n\n28\nFS\n60\n&lt;\n92\n/\n124\n\\\n\n\n\n29\nGS\n61\n=\n93\n]\n125\n}\n\n\n30\nRS\n62\n&gt;\n94\n^\n126\n`\n\n\n31\nUS\n63\n?\n95\n_\n127\nDEL\n\n\n\n\nASCII 码大致由以下两部分组成：\n\nASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。\nASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。\n\n","slug":"0-计算机基础","date":"2021-11-06T11:52:59.000Z","categories_index":"计算机基础","tags_index":"","author_index":"YFR718"},{"id":"fa82b363c947b237a81a51347767262e","title":"4. 寻找两个正序数组的中位数","content":"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n\n\n\n\n\n\n\n\n\n输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2\n\n\n\n\n\n\n\nsort\n将两数组合在一起，排序后直接输出中位数。\n\n\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int l1 = nums1.length, l2 = nums2.length;\n        int[] nums = new int[l1+l2];\n        for(int i = 0;i &lt; l1; i++) {\n            nums[i] = nums1[i];\n        }\n        for(int i = 0; i &lt; l2; i++) {\n            nums[l1+i] = nums2[i];\n        }\n        Arrays.sort(nums);\n\n        if((l1 + l2) % 2 == 1) {\n            return (double)nums[(l1 + l2) / 2];\n        }else{\n            return (double)(nums[(l1 + l2) / 2]+nums[(l1 + l2) / 2 - 1]) / 2.0;\n        }\n    }\n}\n\n\n\n\n\n\n\n 递归\n🚹\n\n\n:heart\n","slug":"l0004","date":"2021-11-05T12:34:37.000Z","categories_index":"LeetCode","tags_index":"双指针","author_index":"YFR718"},{"id":"02ad4c9c8b4647bd8676742f0e73d72a","title":"3. 无重复字符的最长子串","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n\n\n\n\n\n\n\n\n输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n\n\n\n\n\n\n双指针 \n\n设置左指针初值-1，右指针初值0，int数组对区间(l,r]出现过的字母计数\nfor循环对右指针指向的字母计数\n如果计数&lt;=1,更新答案\n如果计数&gt;1,左指针向右移，直到计数=1\n\n\n\n// 数组计数\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int a[] = new int[1000];\n        int l = -1, r = 0;\n        int maxl = 0;\n        for(r = 0; r&lt; s.length();r++){\n            a[(int)s.charAt(r)]+=1;     // 计数\n            if(a[(int)s.charAt(r)]&lt;=1){ // 不重复更新答案\n                maxl = maxl&gt; (r-l) ? maxl: r-l; \n            }else{                      //重复左指针向右移，直到不重复\n                while(a[(int)s.charAt(r)]&gt;1){\n                    l+=1;\n                    a[(int)s.charAt(l)]-=1;\n                }\n            }\n        }\n        return maxl;\n    }\n    \n}\n// 哈希集合\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set&lt;Character&gt; occ = new HashSet&lt;Character&gt;();\n        int len = s.length();\n        int l = -1, r = 0;\n        int maxl = 0;\n        for(r = 0; r&lt; s.length();r++){\n            while(occ.contains(s.charAt(r))) {\n                occ.remove(s.charAt(++l));\n            }\n            occ.add(s.charAt(r));\n            maxl = Math.max(maxl,r-l);\n        }\n        return maxl;\n    }\n    \n}\n","slug":"l0003","date":"2021-11-05T12:09:37.000Z","categories_index":"LeetCode","tags_index":"双指针","author_index":"YFR718"},{"id":"f8534e8f12d0bc66698739d3b7153c65","title":"J5.对象与类","content":"\n面向对象编程OOP类(Class)和对象(Object)是面向对象的核心概念。\n\n类是对一类事物的描述，是抽象的、概念上的定义\n对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。\n属 性：对应类中的成员变量\n行 为：对应类中的成员方法\n由类构造（construct）对象的过程称为创建类的实例（instance）。\n\n创建Java自定义类\n\n定义类（考虑修饰符、类名）\n编写类的属性（考虑修饰符、属性类型、属性名、初始化值）\n编写类的方法（考虑修饰符、返回值类型、方法名、形参等）\n\n对象的创建和使用\n创建对象语法： 类名 对象名 = new 类名();使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）\n属性修饰符 数据类型 属性名 = 初始化值 ; \n\n修饰符：常用的权限修饰符有：private、缺省、protected、public，其他修饰符：static、final (暂不考虑)\n数据类型：任何基本数据类型(如int、Boolean) 或 任何引用数据类型。\n属性名：属于标识符，符合命名规则和规范即可。\n\n变量的分类：成员变量与局部变量\n\n\n\n\n\n\n成员变量\n局部变量\n\n\n\n\n声明的位置\n直接声明在类中\n方法形参或内部、代码块内、构造器内等\n\n\n修饰符\nprivate、public、static、final等\n不能用权限修饰符修饰，可以用final修饰\n\n\n初始化值\n有默认初始化值\n没有默认初始化值，必须显式赋值，方可使用\n\n\n内存加载位置\n堆空间 或 静态域内\n栈空间\n\n\n\n\n方法\n方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。\n将功能封装为方法的目的是，可以实现代码重用，简化代码\nJava里的方法不能独立存在，所有的方法必须定义在类里。\n\n// 方法的声明格式：\n修饰符  返回值类型  方法名（参数类型形参1, 参数类型形参2, ….）｛\n    方法体程序代码\n    return 返回值;\n}\n修饰符：public,缺省,private, protected等返回值类型：\n返回值类型：没有返回值：void，有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用\n方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” \n形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开返回值：方法在执行完毕后返还给调用它的程序的数据。\nmain方法\n\n\n\nmain方法\n\n\n\n\n\npublic\n由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n\nstatic\n因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的\n\n\nString[] args\n该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数\n\n\n\n\n代码块代码块(或初始化块)的作用： 对Java类或对象进行初始化代码块(或初始化块)的分类：一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。\n// static代码块通常用于初始化static的属性\nclass Person {\n    public static int total; \n    static {\n        total = 100;//为total赋初值\n    }\n}\n\n静态代码块：用static 修饰的代码块\n\n\n可以有输出语句。\n可以对类的属性、类的声明进行初始化操作。\n不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。\n若有多个静态的代码块，那么按照从上到下的顺序依次执行。\n静态代码块的执行要先于非静态代码块。\n静态代码块随着类的加载而加载，且只执行一次。\n\n\n非静态代码块：没有static修饰的代码块\n\n\n可以有输出语句。\n可以对类的属性、类的声明进行初始化操作。\n除了调用非静态的结构外，还可以调用静态的变量或方法。\n若有多个非静态的代码块，那么按照从上到下的顺序依次执行。\n每次创建对象的时候，都会执行一次。且先于构造器执行。\n\n⭐程序中成员变量赋值的执行顺序\n\n声明成员变量的默认初始化\n显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）\n构造器再对成员进行初始化操作\n通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值\n\n重载 overload在同一个类中，允许存在一个以上的==同名方法==，只要它们的==参数个数或者参数类型==不同即可。\n==与返回值类型无关==，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。\n//返回两个整数的和\nint add(int x,int y){return x+y;}\n//返回三个整数的和\nint add(int x,int y,int z){return x+y+z;} \n//返回两个小数的和\ndouble add(double x,double y){return x+y;}\n可变个数的形参public static void test(int a ,String…books);\n\n可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个\n可变个数形参的方法与同名的方法之间，彼此构成重载\n可变参数方法的使用与方法参数部分使用数组是一致的\n方法的参数部分有可变形参，需要放在形参声明的最后\n在一个方法的形参位置，最多只能声明一个可变个数形参\n\n方法参数的值传递机制    形参：方法声明时的参数    实参：方法调用时实际传给形参的参数值\nJava里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。\n    形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参    形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参\nint[] arr = new int[10];\nSystem.out.println(arr);//地址值\nchar[] arr1 = new char[10]; System.out.println(arr1); //内容\n//源码解析\npublic void println(Object x) {\n    String s = String.valueOf(x);\n    synchronized (this) {\n        print(s);\n        newLine();\n    }\n}\npublic void println(char x[]) {\n    synchronized (this) {\n        print(x);\n        newLine();\n    }\n}\n构造器 (或构造方法)构造器的特征\n\n它具有与类相同的名称\n它不声明返回值类型。（与声明为void不同）\n不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值\n\n构造器的作用：创建对象；给对象进行初始化\n\n如：Order o = new Order();    Person p = new Person(“Peter”,15);\n如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。\n\n// 语法格式：\n修饰符 类名 (参数列表) {\n    初始化语句;\n}\n根据参数不同，构造器可以分为如下两类：    隐式无参构造器（系统默认提供）    显式定义一个或多个构造器（无参、有参）注 意：    Java语言中，每个类都至少有一个构造器    默认构造器的修饰符与所属类的修饰符一致    一旦显式定义了构造器，则系统不再提供默认构造器    一个类可以创建多个重载的构造器    父类的构造器不可被子类继承\n构造器重载\n构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。\n// 构造器重载举例：\npublic class Person{\n    public Person(String name, int age, Date d) {this(name,age);…} \n    public Person(String name, int age) {…}\n    public Person(String name, Date d) {…}\n    public Person(){…}\n}\n关键字—this    它在方法内部使用，即这个方法所属对象的引用；    它在构造器内部使用，表示该构造器正在初始化的对象。\nthis 可以调用类的属性、方法和构造器\n什么时候使用this关键字呢？    当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。比如：this.name = name;\n⭐this可以作为一个类中构造器相互调用的特殊格式\nclass Person{\n    //定义Person类\n    private String name ;\n    private int age ;\n    public Person(){\n        //无参构造器\n        System.out.println(\"新对象实例化\");\n    }\n    public Person(String name ){\n        this(); //调用本类中的无参构造器\n        this.name = name ;\n    }\n    public Person(String name,int age){\n        this(name); // 调用有一个参数的构造器\n        this.age = age;\n    }\n    public String getInfo(){\n    return \"姓名: \"+name+\"，年龄:\"+age;\n    }\n}\n\n    可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！    明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器    如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”    “this(形参列表)”必须声明在类的构造器的首行！    在类的一个构造器中，最多只能声明一个”this(形参列表)”\n封装与隐藏    高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；    低耦合 ：仅对外暴露少量的方法用于使用。\n隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。\nJava中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：\n    隐藏一个类中不需要对外提供的实现细节；    使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；    便于修改，增强代码的可维护性；\n\n\n\n\n修饰符\n类内部\n同一个包\n不同包的子类\n同一个工程\n\n\n\n\nprivate\n√\n\n\n\n\n\n(缺省)\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\n\n\n包(package)的管理与作用package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：package 顶层包名.子包名 ;\n//举例：pack1\\pack2\\PackageTest.java\npackage pack1.pack2;    //指定类PackageTest属于包pack1.pack2 \n\npublic class PackageTest{\n    public void display(){\n        System.out.println(\"in  method display()\");\n    }\n}\n    包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次；    包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx\n包的作用：\n    包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式    包可以包含类和子包，划分项目层次，便于管理    解决类命名冲突的问题    控制访问权限\n\n\n\n\n\nJDK中主要的包介绍\n\n\n\n\njava.lang\n包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能\n\n\njava.net\n包含执行与网络相关的操作的类和接口\n\n\njava.io\n包含能提供多种输入/输出功能的类\n\n\njava.util\n包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数\n\n\njava.text\n包含了一些java格式化相关的类\n\n\njava.sql\n包含了java进行JDBC数据库编程的相关类/接口\n\n\njava.awt\n包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)\n\n\n\n\n继承 (inheritance)多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。\n    此处的多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。可以理解为:“子类 is a 父类”\n// 类继承语法规则:\nclass Subclass extends SuperClass{ }\n作用：    继承的出现减少了代码冗余，提高了代码的复用性。    继承的出现，更有利于功能的扩展。    继承的出现让类与类之间产生了关系，提供了多态的前提。\n\n子类继承了父类，就继承了父类的方法和属性。\n在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。\n在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。\n\n关于继承的规则：\n\n子类不能直接访问父类中私有的(private)的成员变量和方法。\n⭐Java只支持单继承和多层继承，不允许多重继承\n\n方法的重写 (override/overwrite)定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。\n要求：\n\n子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表\n子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型\n子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限    子类不能重写父类中声明为private权限的方法\n子类方法抛出的异常不能大于父类被重写方法的异常\n子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。\n\n子类继承父类\n    若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。    对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量\n关键字—super在Java类中使用super来调用父类中的指定操作：\n\nsuper可用于访问父类中定义的属性\nsuper可用于调用父类中定义的成员方法\nsuper可用于在子类构造器中调用父类的构造器\n尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员\nsuper的追溯不仅限于直接父类\nsuper和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识\n\n调用父类的构造器\n    子类中所有的构造器默认都会访问父类中空参数的构造器    当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行    如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错\n\n\n\n\nNo.\n区别点\nthis\nsuper\n\n\n\n\n1\n访问属性\n访问本类中的属性，如果本类没有此属性则从父类中继续查找\n直接访问父类中的属性\n\n\n2\n调用方法\n访问本类中的方法，如果本类没有此方法则从父类中继续查找\n直接访问父类中的方法\n\n\n3\n调用构造器\n调用本类构造器，必须放在构造器的首行\n调用父类构造器，必须放在子类构造器的首行\n\n\n\n\n子类对象的实例化过程\n多态性对象的多态性：父类的引用指向子类的对象\nJava引用变量有两个类型：\n\n编译时类型：由声明该变量时使用的类型决定。\n运行时类型：由实际赋给该变量的对象决定。\n\n\n编译时，看左边；运行时，看右边。\n若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)\n\n\n\n\n\n\n\n\n\n\n\n多态作用\n    提高了代码的通用性，常称作接口重用\n\n\n前提\n    需要存在继承或者实现关系    有方法的重写\n\n\n成员方法\n    编译时：要查看引用变量所声明的类中是否有所调用的方法。    运行时：调用实际new的对象所属的类中的重写方法。\n\n\n成员变量\n不具备多态性，只看引用变量所声明的类。\n\n\n\n\n对象的多态：在Java中,子类的对象可以替代父类的对象使用    一个变量只能有一种确定的数据类型    一个引用类型变量可能指向(引用)多种不同类型的对象\n\n子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。\n\n一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就==不能==再访问子类中添加的属性和方法\n虚拟方法调用\n子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。\ninstanceof运算符x instanceof A：检验x是否为类A的对象，返回值为boolean型。\n对象类型转换\n    从子类到父类的类型转换可以自动进行    从父类到子类的类型转换必须通过造型(强制类型转换)实现    无继承关系的引用类型间的转换是非法的    在造型前可以使用instanceof操作符测试一个对象的类型\n对象类型转换 (Casting )基本数据类型的Casting：\n\n自动类型转换：小的数据类型可以自动转换成大的数据类型如long g=20; double d=12.0f\n强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型如 float f=(float)12.0; int a=(int)1200L    对Java对象的强制类型转换称为造型    从子类到父类的类型转换可以自动进行    从父类到子类的类型转换必须通过造型(强制类型转换)实现    无继承关系的引用类型间的转换是非法的    在造型前可以使用instanceof操作符测试一个对象的类型\n\n方法的重载与重写从编译和运行的角度看：重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”\n Object类的结构与方法Object类是所有Java类的根父类    如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类\npublic class Person { ...\n}\n//等价于\npublic class Person extends Object { ...\n}\n\n\n\n\n方法名称\n类型\n描述\n\n\n\n\npublic Object()\n构造\n构造器\n\n\npublic boolean equals(Object obj)\n普通\n对象比较\n\n\npublic int hashCode()\n普通\n取得Hash码\n\n\npublic String toString()\n普通\n对象打印时调用\n\n\n\n\n==操作符与equals方法基本类型比较值:只要两个变量的值相等，即为true。\n引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。\n用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错\nequals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。    只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。    格式:obj1.equals(obj2)    特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；    原因：在这些类中重写了Object类的equals()方法。    当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等\n重写equals()方法的原则    对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是 “true”。    自反性：x.equals(x)必须返回是“true”。    传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。    一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。    任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。\n⭐面试题：==和equals的区别\n== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址\nequals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。\n具体要看自定义类里有没有重写Object的equals方法来判断。\n通常情况下，重写equals方法，会比较类中的相应属性是否都相等。\n\ntoString() 方法toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。在进行String与其它类型数据的连接操作时，自动调用toString()方法Date now=new Date();\nSystem.out.println(“now=”+now); //相当于\nSystem.out.println(“now=”+now.toString());\n可以根据需要在用户自定义类型中重写toString()方法\n//如String 类重写了toString()方法，返回字符串的值。\ns1=“hello”;\nSystem.out.println(s1);//相当于System.out.println(s1.toString());\n    基本类型数据转换为String类型时，调用了对应包装类的toString()方法    int a=10; System.out.println(“a=”+a);\n包装类的使用    针对八种基本数据类型定义相应的引用类型—包装类（封装类）\nByte、Short、Integer、Long、Float、Double、Boolean、Character\n基本数据类型包装成包装类的实例 —-装箱通过包装类的构造器实现：\nint i = 500;   Integer t = new Integer(i);\nint i = new Integer(“12”);\n通过字符串参数构造包装类对象：\nFloat f = new Float(“4.56”);\nLong l = new Long(“asdf”);  //NumberFormatException\n获得包装类对象中包装的基本类型变量 —-拆箱调用包装类的.xxxValue()方法：\nboolean b = bObj.booleanValue();\n通过包装类的parseXxx(String s)静态方法：\n// 字符串转包装类\nFloat f = Float.parseFloat(“12.1”);\n\n// 基本数据类型包装成包装类的实例 ---装箱\n// 通过包装类的构造器实现：\nint i = 500;   Integer t = new Integer(i);\n// 通过字符串参数构造包装类对象：\nFloat f = new Float(“4.56”);\nLong l = new Long(“asdf”);  //NumberFormatException\n\n//获得包装类对象中包装的基本类型变量 ---拆箱\n// 调用包装类的.xxxValue()方法：\nboolean b = bObj.booleanValue();\n\n// 字符串转换成基本数据类型\n// 通过包装类的构造器实现：\nint i = new Integer(“12”);\n// 通过包装类的parseXxx(String s)静态方法：\nFloat f = Float.parseFloat(“12.1”);\n\n// 基本数据类型转换成字符串\n// 调用字符串重载的valueOf()方法：\nString fstr = String.valueOf(2.34f);\n//更直接的方式：\nString intStr = 5 + “”\n关键字—static当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，==只有通过new关键字才会产生出对象==，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，==某些特定的数据在内存空间里只有一份==。\n\n类属性作为该类==各个对象之间共享的变量==。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。\n如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。\n\n    使用范围：在Java类中，可用static修饰属性、方法、代码块、内部类\n被修饰后的成员具备以下特点：    随着类的加载而加载    优先于对象存在    修饰的成员，被所有对象所共享    访问权限允许时，可不创建对象，直接被类调用\n匿名对象\n不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。\nnew Person().shout();\n类变量(class Variable)类变量（类属性）由该类的所有实例共享\npublic static int total = 0;\n\nPerson.total = 100; // 不用创建对象就可以访问静态成员 \n//访问方式：类名.类属性，类名.类方法\n类方法(class method)没有对象的实例时，可以用类名.方法名()的形式访问由static修饰的类方法。    在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。    在static方法中不能有this，也不能有super\n理解main方法的语法​        由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。\n​        又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。\n关键字—final\nfinal标记的类不能被继承。提高安全性，提高程序的可读性。String类、System类、StringBuffer类\nfinal标记的方法不能被子类重写。Object类中的getClass()。\n    final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。\n\n\n\n\n\nfinal\n在类、变量和方法时表示“最终的”\n\n\n\n\n类不能被继承\n提高安全性，提高程序的可读性。\n\n\n方法不能被子类重写\n    比如：Object类中的getClass()\n\n\nfinal标记的变量\n名称大写，且只能被赋值一次\n\n\n\n\n// final修饰类\nfinal class A{\n}\n// final修饰方法\nclass A {\n    public final void print() {\n        System . out . println(\"A\");\n    }\n}\n//final修饰变量——常量\nprivate final String INFO = \"atguigu\";  //声明常量\n抽象类与抽象方法—abstract类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。\n用abstract关键字来修饰一个类，这个类叫做==抽象类==。用abstract来修饰一个方法，该方法叫做==抽象方法==。    抽象方法：只有方法的声明，没有方法的实现。以分号结束：比如：public abstract void talk();    含有抽象方法的类必须被声明为抽象类。    抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。    不能用abstract修饰变量、代码块、构造器；    不能用abstract修饰私有方法、静态方法、final的方法、final的类。\n关键字—interface接口(interface)是抽象方法和常量值定义的集合。接口的特点：    用interface来定义。    接口中的所有成员变量都默认是由public static final修饰的。    接口中的所有抽象方法都默认是由public abstract修饰的。    接口中没有构造器。    接口采用多继承机制。\npublic interface Runner {\n    public static final int ID = 1; \n    public abstract void start(); \n    public abstract void run(); \n    public abstract void stop();\n}\n定义Java类的语法格式：先写extends，后写implements    class SubClass extends SuperClass implements InterfaceA{ }一个类可以实现多个接口，接口也可以继承其它接口。    实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。    接口的主要用途就是被实现类实现。（面向接口编程）    与继承关系类似，接口与实现类之间存在多态性    接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，(JDK7.0及之前)，而没有变量和方法的实现。\n\n一个类可以实现多个无关的接口\n与继承关系类似，接口与实现类之间存在多态性\n\n\n\n\n\n区别点\n抽象类\n接口\n\n\n\n\n定义\n包含抽象方法的类\n主要是抽象方法和全局常量的集合\n\n\n组成\n构造方法、抽象方法、普通方法、常量、变量\n常量、抽象方法、(jdk8.0:默认方法、静态方法)\n\n\n使用\n子类继承抽象类(extends)\n子类实现接口(implements)\n\n\n关系\n抽象类可以实现多个接口\n接口不能继承抽象类，但允许继承多个接口\n\n\n常见设计模式\n模板方法\n简单工厂、工厂方法、代理模式\n\n\n对象\n都通过对象的多态性产生实例化对象\n\n\n\n局限\n抽象类有单继承的局限\n接口没有此局限\n\n\n实际\n作为一个模板\n是作为一个标准或是表示一种能力\n\n\n选择\n如果抽象类和接口都可以使用的话，\n优先使用接口，因为避免单继承的局限\n\n\n\n\n在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。\nJava 8中关于接口的改进Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。静态方法：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。默认方法：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。\n接口中的默认方法\n    若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。    解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。\n若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。\n内部类当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。\n    Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。    Inner class的名字不能与包含它的外部类类名相同；\n\n成员内部类（static成员内部类和非static成员内部类）\n\n局部内部类（不谈修饰符）、匿名内部类\n\n\n成员内部类作为类的成员的角色：    和外部类不同，Inner class还可以声明为private或protected；    可以调用外部类的结构    Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；成员内部类作为类的角色：    可以在内部定义属性、方法、构造器等结构    可以声明为abstract类 ，因此可以被其它的内部类继承    可以声明为final的    编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）\n注意：\n\n非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。\n外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式\n成员内部类可以直接使用外部类的所有成员，包括私有的数据\n当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的\n\nclass外部类{\n    方法(){\n    \tclass局部内部类{\n    \t}\n\t}\n    {\n        class局部内部类{\n\t\t}\n    }\n}\n\n如何使用局部内部类\n\n    只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类    但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型\n\n局部内部类的特点\n\n    内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。    只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。    局部内部类可以使用外部类的成员，包括私有的。    局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。    局部内部类和局部变量地位类似，不能使用public,protected,缺省,private    局部内部类不能使用static修饰，因此也不能包含静态成员\n匿名内部类\n    匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。\nnew 父类构造器（实参列表）|实现接口(){\n    //匿名内部类的类体部分\n}\n匿名内部类的特点    匿名内部类必须继承父类或实现接口    匿名内部类只能有一个对象    匿名内部类对象只能使用多态形式引用\n","slug":"J1-对象与类","date":"2021-11-05T06:23:36.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"4ec631ba9c8264548f541e9cb0021e69","title":"2. 两数相加","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n\n\n\n\n\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.\n\n\n\n\n\n\n\n模拟\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode ans = new ListNode();\n        ListNode a = ans;\n        int t = 0;\n        while(l1 != null || l2 != null){\n            if(l1 != null) {\n                t += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null) {\n                t += l2.val;\n                l2 = l2.next;\n            }\n            a.next = new ListNode(t%10);\n            a = a.next;\n            t = t/10;\n        }\n        if(t != 0) a.next = new ListNode(t);\n        return ans.next;\n\n    }\n}\n","slug":"l0002","date":"2021-11-04T14:51:28.000Z","categories_index":"LeetCode","tags_index":"链表","author_index":"YFR718"},{"id":"2a28fcbe1a17ab37c1c849fd02eb2771","title":"1. 两数之和","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n\n\n\n\n\n\n\n\n\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n\n\n\n\n\n暴力解法\n双重for循环\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0;i&lt;nums.length;i++) { \n            for(int j = i+1;j&lt;nums.length;j++) {\n                if(nums[i] + nums[j] == target) {\n                    return new int[] {i,j};\n                }\n            }\n        }\n        return new int[] {0};\n    }\n}\n\n\n\n\n\n\n\n 哈希表\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; hashTable = new HashMap&lt;Integer, Integer&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            if(hashTable.containsKey(target - nums[i])) {\n                return new int[]{hashTable.get(target - nums[i]),i};\n            }\n            hashTable.put(nums[i],i);\n        }\n        return new int[] {0};\n\n    }\n}\n# Python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            r = target-nums[i]\n            if r in d:\n                return [d[r],i]\n            else:\n                d[nums[i]]=i\n","slug":"l0001","date":"2021-11-04T12:06:25.000Z","categories_index":"LeetCode","tags_index":"哈希","author_index":"YFR718"},{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"Java概述是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。\nJava语言特性\n特点一：面向对象\n两个基本概念：类、对象\n三大特性：封装、继承、多态\n\n特点二：健壮性\n吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制\n\n特点三：跨平台性\n跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”\n原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。\n因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。\n\n\n核心机制—Java虚拟机\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n对于不同的平台，有不同的虚拟机。\n只有某平台提供了对应的java虚拟机，java程序才可在此平台运行\nJava虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”\n\n核心机制—垃圾回收​        不再使用的内存空间应回收——垃圾回收。在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。\n\n\n\n\nJava语言的环境\n功能\n包含\n\n\n\n\nJDK(Java Development Kit    Java开发工具包)\nJDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。\nJRE + 开发工具集（编译工具javac.exe 打包工具jar.exe)\n\n\nJRE(Java Runtime Environment    Java运行环境)\n包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\nJVM + Java SE标准类库\n\n\nJVM (Java Virtal Machine Java虚拟机）\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n\n\n\n\nHello Java​        我们来编写第一个简单的Java程序：\npublic class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\npublic称为访问修饰符（accessmodifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。\nclass表明Java程序中的全部内容都包含在类中。\nHelloJava：类名。\nstatic：静态方法。\nvoid：无参数返回。\nmain：主方法，程序的入口。\nString[]：程序执行的参数。\nargs：参数名。\nSystem.out.println()：输出一行语句。\n\nJava运行步骤：\n将 Java 代码编写到扩展名为 .java 的文件中。\n通过 javac 命令对该 java 文件进行编译。\n通过 java 命令对生成的 class 文件进行运行。\n\nC:\\Users\\24378\\Desktop\\Java>javac f1.java\nC:\\Users\\24378\\Desktop\\Java>java f1\nhello Java\n一些规范Java命名规范\n\n\n\n类型(名)\n约束\n列\n\n\n\n\n项目\n全部小写，画线-分隔\nspring-cloud\n\n\n包\n全部小写\ncom.yfr.softmax\n\n\n类\n单次首字母大写\nNewWorld\n\n\n变量/方法\n首字母小写\nuserName\n\n\n常量\n全部大写，下划线_分隔\nINT_MAX\n\n\n\n\nJava代码编写规范public class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\n注意大括号的风格\n二元三元运算符两边用一个空格隔开\n逗号语句后如不换行，紧跟一个空格\n将类似操作，或一组操作放在一起不用空行隔开，而用空行隔开不同组的代码\n每个if while for等语句，都不要省略大括号{}\n\nJava注释\n\n\n\n注释类型\n\n\n\n\n\n\n单行注释\n//注释文字\n\n\n\n多行注释\n/  注释文字 /\n\n\n\n文档注释：\n/*@author  指定java程序的作者@version  指定源文件的版本/\n\n\n\n\n# 生成注释文档\nPS C:\\Users\\24378\\Desktop\\Java&gt; javadoc -d mydoc -author -version .\\f1.java\n正在加载源文件.\\f1.java...\n正在构造 Javadoc 信息...\n...\nJava注意事项\nJava源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本例中的HelloWorld类。\n\nJava应用程序的执行入口是main()方法。它有固定的书写格式：\npublic static void main(String[] args)  &#123;...&#125;\n\n\n\nJava语言严格区分大小写。\n\nJava方法由一条条语句构成，每个语句以“;”结束。\n\n大括号都是成对出现的，缺一不可。\n\n一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。\n\n\n基本数据类型整数\n\n\n\n类型\n存储需求\n取值范围\n例\n\n\n\n\nint\n4字节\n$- 2^{31} \\sim 2^{31}-1$（21亿）\n10\n\n\nshort\n2字节\n$- 2^{15} \\sim 2^{15}-1$（32768）\n\n\n\nlong\n8字节\n$- 2^{63} \\sim 2^{63}-1$\n10L\n\n\nbyte\n1字节\n$- 2^{7} \\sim 2^{7}-1$（128）\n\n\n\n\n浮点数\n\n\n\n类型\n存储需求\n符号位\n指数位\n尾数位\n例\n\n\n\n\nfloat\n4字节\n1\n8\n23\n3.14F\n\n\ndouble\n8字节\n1\n11\n52\n3.14\n\n\n\n\n更详细\nchar类型\n\n\n\n类型\n存储需求\n\n\n\n\n\nchar\n2字节\n1\n\n\n\n\nchar类型的字面量值要用单引号括起来。例如：’A’.\n在Java中，char类型描述了UTF-16编码中的一个代码单元。对char类型字符运行时，直接当做ASCII表对应的整数来对待。\nUnicode 编码:一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。\nUnicode 的缺点：Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别 Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。\nUTF-8:一种变长的编码方式。它可以使用 1-6 个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则：1）对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。2）对于多字节的UTF-8编码，如果编码包含 n 个字节，那么第一个字节的前 n 位为1，第一个字节的第 n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。\nboolean\n\n\n\n类型\n存储需求\n\n\n\n\n\nboolean\n1位\ntrue/flase\n\n\n\n\n变量变量的声明与使用标识符：Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符定义合法标识符规则：\n\n由26个英文字母大小写，0-9 ，_或$ 组成\n数字不可以开头。\n不可以使用关键字和保留字，但能包含关键字和保留字。\nJava中严格区分大小写，长度无限制。\n标识符不能包含空格。\n\n变量的概念：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。变量的作用：用于在内存中保存数据\n使用变量注意：\n\nJava中每个变量必须先声明，后使用\n使用变量名来访问这块区域的数据\n变量的作用域：其定义所在的一对{ }内\n变量只有在其作用域内才有效\n同一个作用域内，不能定义重名的变量\n\n声明变量\n\n语法：&lt;数据类型&gt; &lt;变量名称&gt;;\n\n例如：int var;\n\n\n变量的赋值\n\n语法：&lt;变量名称&gt; =  &lt;值&gt;\n例如：var = 10;\n\n声明和赋值变量\n\n语法： &lt;数据类型&gt; &lt;变量名&gt; =  &lt;初始化值&gt;\n例如：int var = 10;\n\n变量的分类-按数据类型\n\n变量的分类-按声明的位置\n\n在方法体外，类体内声明的变量称为成员变量。\n在方法体内部声明的变量称为局部变量。\n\n\n常量在Java中，利用关键字final指示常量。\nfinal int A = 1000;\n数值类型之间的转换自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：\n\n\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\nbyte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。\nboolean类型不能与其它数据类型运算。\n当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。\n\nString str1 = 4; //判断对错: no\nString str2= 3.5f + \"\"; //判断str2对错: yes\nSystem.out.printIn(str2); //输出:”3.5”\nSystem.out .println(3+4+\"Hello!\"); //输出:7Hello!\nSystem.out.println(\"Hello!\" +3+4); //输出: Hello!34\nSystem.out.printIn('a'+ 1+\"Hello!\"); //输 出: 98Hello!\nSystem.out.printIn(\"Hello\"+'a'+1); //输出: Helloa1\n强制类型转换：将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。\n通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n// 判断是否能通过编译\nshort s = 5;\ns = s - 2; //报错：int 不能用short存储\ns = (short) (s - 2); //正确写法\n\nbyte b = 3;\nb = b + 4; //报错：int 不能用byte存储\nb = (byte) (b + 4); //正确写法\n\nchar a = 'a';\nint i = 5;\nfloat d = .314F;\ndouble result = a + i + d; //正确\n\nbyte b = 5;\nshort s = 3;\nshort t = s + b; //报错：int 不能用short存储\n进制与运算符\n\n\n\n进制\n\n\n\n\n\n\n二进制 (binary)\n0,1\n满2进1.以0b或0B开头\n\n\n十进制 (decimal)\n0-9\n满10进1\n\n\n八进制 (octal)：\n0-7\n满8进1. 以数字0开头表示\n\n\n十六进制 (hex) (hex)(hex)(hex)：\n0-9，A-F\n满16进1. 以0x或0X开头表示\n\n\n\n\n进制的基本转换    十进制 二进制互转       二进制转成十进制 乘以2的幂数       十进制转成二进制 除以2取余数    二进制 八进制互转    二进制 十六进制互转    十进制八进制互转    十进制十六进制互转\n\n\n\n\n运算符\n运算\n\n\n\n\n算术运算符\n+-*/%++–\n\n\n赋值运算符\n=,+=, -=, *=, /=, %=\n\n\n比较运算符（关系运算符）\n==,!=,&lt;,&gt;,&lt;=,&gt;=,instanceof\n\n\n逻辑运算符\n&amp;,\\\n,!,&amp;&amp;,\\\n\\\n,^\n\n\n位运算符\n&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,\\\n,^,~\n\n\n三元运算符\n(条件表达式)?表达式1：表达式2；\n\n\n\n\n\n\n\n\n\n位运算符的细节\n\n\n\n\n&lt;&lt;\n空位补0，被移除的高位丢弃，空缺位补0。\n\n\n&gt;&gt;\n被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。\n\n\n&gt;&gt;&gt;\n被移位二进制最高位无论是0或者是1，空缺位都用0补。\n\n\n&amp;\n二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;\n\n\n\\\n\n二进制位进行 \\\n运算，只有0 \\\n0时结果是0，否则是1;\n\n\n^\n相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1\n\n\n~\n正数取反，各二进制码按补码各位取反负数取反，各二进制码按补码各位取反\n\n\n\n\n运算优先级：\n思考1：\nshort s = 3; \ns = s+2;//s1+2运算结果是int型，需要强制转换类型   \n① s += 2;    //+= 不改变原本的数据类型\n\n思考2：\nint i = 1;\ni *= 0.1;  //*= 不改变原本的数据类型\nSystem.out.println(i);\ni++;\nSystem.out.println(i);\n\n思考3：\nint m = 2;\nint n = 3;\nn *= m++; \nSystem.out.println(\"m=\" + m); System.out.println(\"n=\" + n); 3，6\n    \n思考4：\nint n = 10;\nn += (n++) + (++n); //10 + 10 + 12\nSystem.out.println(n);\n“&amp;”和“&amp;&amp;”的区别：“|”和“||”的区别同理    单&amp;时，左边无论真假，右边都进行运算；    双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。\nint x = 1,y = 1;\nif(x++==2 &amp; ++y==2)&#123;\n    x =7;\n&#125;\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，2\nint x = 1,y = 1;\nif(x++==2 &amp;&amp; ++y==2)&#123;\n    x =7;\n&#125;\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，1\nint x = 1,y = 1;\nif(x++==1 | ++y==1)&#123;\n    x =7;\n&#125;\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，2\n\nint x = 1,y = 1;\nif(x++==1 || ++y==1)&#123;\n    x =7;\n&#125;\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，1\n\nclass Test &#123;\n    public static void main (String [] args) &#123;\n        boolean x=true;\n        boolean y=false;\n        short z=42;\n        //if(y == true)\n        if((z++==42)&amp;&amp;(y=true))z++;\n        if((x=false) || (++z==45)) z++;\n        System.out.println(\"z=\"+z);\n    &#125;\n&#125;\n// z=46\nStringString s = \"123456\";\n\n\n\n\n常用方法\n功能\n示例/说明\n\n\n\n\ns.substring(x,y)\n获得字串[x,y-1]\na.substring(0,3)\n\n\ns1 + s2\n拼接字符串\ns + “789”\n\n\nString.jion(‘’,”,s1,s2,s3)\n多个字符串放在一起用分隔符\n静态方法\n\n\ns.equals(s1)\n检查两字符串是否相等\n\n\n\ns.equalsIgnoreCase(s1)\n检查两字符串是否相等，忽略大小写\n\n\n\ns.length()\n获取字符串长度\n空串：长度为0\n\n\ns.codePointCount(0，s.length();\n得到实际的长度，即码点数量\n\n\n\ns.charAt(n)\n返回位置n的代码单元\n\n\n\nint codePointAt(int index)\n返回从给定位置开始的码点。\n\n\n\nint offsetByCodePoints(int startIndex, int cpCount)\n返回从startIndex代码点开始，位移cpCount后的码点索引。\n\n\n\nint compareTo(String other)\n按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。\n\n\n\nIntStream codePoints()\n将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nboolean equalsIgnoreCase(String other)\nboolean equalsIgnoreCase(String other)\n\n\n\nboolean startsWith(String prefix)\n\n\n\n\nboolean endsWith(String suffix)\n如果字符串以suffix开头或结尾，则返回true。\n\n\n\nint index0f(String str, int fromIndex)\n返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。\n\n\n\nint lastIndex0f(String str, int fromIndex)\nint lastIndex0f(String str, int fromIndex)\n\n\n\nint codePointCount(int startIndex, int endIndex)\n返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。\n\n\n\nString replace(CharSequence oldString, CharSequence newString)\n返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。\n\n\n\nString toUpperCase( )String toUpperCase( )\n返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。\n\n\n\nString trim( )\n返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。\n\n\n\n\n\n\n\n\n\n注意事项：\n\nString没办法修改字符串，可以通过提取字串+拼接实现\n\n一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。\nif(s.substring(0,3) == \"123\") // false\n\n\nStringBuilder需要由较短的字符串构建字符串\nStringBuilder builder = new StringBuilder();\n//当每次需要添加一部分内容时，就调用append方法。\nbuilder.append(\"1\");\nbuilder.append(\"2\");\n//在需要构建字符串时就调用toString方法\nSystem.out.println(builder.toString());\n\n\n\n\n\n\n\n\n\n这个类的前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑（通常都是这样），则应该用StringBuilder替代它。这两个类的API是相同的。\nAPI\n\n\n\n\n方法\n功能\n\n\n\n\n\nStringBuilder()\n构造一个空的字符串构建器。\n\n\n\nint length()\n返回构建器或缓冲器中的代码单元数量。\n\n\n\nStringBuilder append(String str)\n追加一个字符串并返回this。\n\n\n\nStringBuilder append(char c)\n追加一个代码单元并返回this。\n\n\n\nStringBuilder appendCodePoint(int cp)\n追加一个代码点，并将其转换为一个或两个代码单元并返回this。\n\n\n\nvoid setCharAt(int i, char c)\n将第i个代码单元设置为c。\n\n\n\nStringBuilder insert(int offset, String str)\n在offset位置插入一个字符串并返回this。\n\n\n\nStringBuilder insert(int offset, Char c)\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n\n标准输入输出数据读入import java.util.Scanner;\nScanner in = new Scanner(System,in);\n// 读入一行\nString name = in.nextLine();\n//读入一个单词\nString name = in.next();\n//读入一个整数\n int a = sc.nextInt();\n\n\n\n\n\n方法\n功能\n\n\n\n\nScanner (InputStream in)\n用给定的输入流创建一个Scanner对象。\n\n\nString nextLine( )\n读取输入的下一行内容。\n\n\nString next( )\n读取输入的下一个单词（以空格作为分隔符）。\n\n\nint nextInt( ) int nextInt( )\n读取并转换下一个表示整数或浮点数的字符序列。\n\n\nboolean hasNext( )\n检测输入中是否还有其他单词。\n\n\nboolean hasNextInt( )boolean hasNextDouble( )\n检测是否还有表示整数或浮点数的下一个字符序列。\n\n\nstatic Console console( )\n\n\n\n\n格式化输出System.out.print(x)\n每一个以%字符开始的格式说明符都用相应的参数替换。格式说明符尾部的转换符将指示被格式化的数值类型：\n\n\n\n\n转换符\n类型\n\n\n\n\nd\n十进制\n\n\nx\n十六进制\n\n\no\n八进制\n\n\nf\n定点浮点数\n\n\ne\n指数浮点数\n\n\ng\n通用浮点数\n\n\na\n十六进制浮点数\n\n\ns\n字符串\n\n\nc\n字符\n\n\nb\n布尔\n\n\nh\n散列码\n\n\ntx/TX\n日期时间\n\n\n%\n百分号\n\n\nn\n行分隔符\n\n\n\n\n可以使用多个标志，例如，“%, ( .2f”使用分组的分隔符并将负数括在括号内。\n\n\n\n\n标志\n目的\n\n\n\n\n+\n打印正负号\n\n\n空格\n在正整数前加空格\n\n\n0\n数字前补0\n\n\n-\n左对齐\n\n\n(\n将负数扩在括号里\n\n\n,\n添加分组分隔符\n\n\n#(对f格式)\n包含小数点\n\n\n#(对x或0格式)\n添加前缀0x\n\n\n$\n给定被格式化的参数索引。例如，%ISd. %1$x 将以十进制和十六进制格式打印第1个参数\n\n\n\n&lt;\n格式化前面说明的数值。例如，%d%&lt;x以十进制和十六进制打印同一个数值\n\n\n\n\n\n\n\n文件输入与输出文件读取要想对文件进行读取，就需要一个用File对象构造一个Scanner对象，如下所示：\nScanner in = new Scanner(Paths.get(\"myfile.txt\"),\"UTF-8\");\n如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠：“c:\\\\mydirectory\\\\myfile.txt”。\n文件写入要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：\nPrintWriter out = new PrintWriter(\"myfile.txt\",\"UTF-8\");\n\n\n\n\n\n\n\n\n\n\nScanner(File f)\n构造一个从给定文件读取数据的Scanner。\n\n\nScanner(String data)\n构造一个从给定字符串读取数据的Scanner。\n\n\nPrintWriter(String fileName)\nPrintWriter(String fileName)\n\n\nstatic Path get(String pathname)\n根据给定的路径名构造一个Path。\n\n\n\n\n\n\n\n块作用域 Block块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。\n注意：\n\n不能在嵌套的两个块中声明同名的变量。\n块内定义的变量块外不能使用。\n\n\n流程控制语句\n\n\n\n流程控制\n\n\n\n\n\n\n顺序结构\n\n\n\n\n分支语句\nif-else、switch-case\n\n\n\n循环结构\nfor、while、do-while\n\n\n\n特殊流程控制语句\nbreak、continue、return\n\n\n\n\nswitch (i)&#123;\n    case 0:...;\n        break;\n    case 1:...;\n        break;\n    default:...;\n        break;\n&#125;\ncase标签可以是：\n● 类型为char、byte、short或int的常量表达式。\n● 枚举常量。\n● 从Java SE 7开始，case标签还可以是字符串字面量。\n带标签的break语句有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望跳到嵌套的所有循环语句之外。通过添加一些额外的条件判断实现各层循环的检测很不方便。\n这里有一个示例说明了break语句的工作状态。请注意，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。\nlabel:\n&#123;\n    ...\n\tif (condition) break label; // exits b1ock\n\t...\n&#125;\n\n大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。\n&#x2F;&#x2F;使用静态的valueOf方法可以将普通的数值转换为大数值\nBigInteger a &#x3D; BigInteger.valueOf(999999999999999999l);\n\n&#x2F;&#x2F;使用大数值类中的add和multiply方法。\nBigInteger d &#x3D; a.multiply(a);\nSystem.out.println(d);\n\n\n\n\nBigInteger\n\n\n\n\n\nBigInteger add(BigInteger other)\n+\n\n\nBigInteger subtract(BigInteger other)\n-\n\n\nBigInteger multiply(BigInteger other)\n*\n\n\nBigInteger divide(BigInteger other)\n/\n\n\nBigInteger divide(BigInteger other)\n%\n\n\nint compareTo(BigInteger other)\n相等，返回0；小于，返回负数；否则，返回正数。\n\n\nstatic BigInteger valueOf(long x)\n返回值等于x的大整数。\n\n\n\n\n\n\n\n\nBigInteger\n\n\n\n\n\nBigDecimal add(BigDecimal other)\n+\n\n\nBigDecimal subtract(BigDecimal other)\n-\n\n\nBigDecimal multiply(BigDecimal other)\n*\n\n\nBigDecimal multiply(BigDecimal other)\n/\n\n\nint compareTo(BigDecimal other)\n比较\n\n\nstatic BigDecimal valueOf(long x)\n\n\n\nstatic BigDecimal valueOf(long x, int scale)\n$x / 10^{scale}$\n\n\n\n\nJava数组数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组的常见概念\n\n数组名\n下标(或索引)\n元素\n数组的长度\n\n一维数组的创建与使用// 一维数组的声明方式：\ntype var[] 或 type[]  var;\n//Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： \nint a[5];  //非法\n//动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行\nint[] arr = new int[3];\nString names[]; names = new String[3];\n//静态初始化：在定义数组的同时就为数组元素分配空间并赋值。\nint arr[] = new int[]&#123; 3, 9, 8&#125;;\nint[] arr = &#123;3,9,8&#125;;\n// 属性length\na.length 指明数组a的长度(元素个数)\n数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。\n\n对于基本数据类型而言，默认初始化值各有不同\n对于引用数据类型而言，默认初始化值为null(注意与0不同！\n\n\n\n\n\n\n\n\n\n\n数组元素类型\n元素默认初始值\n\n\n\n\nbyte\n0\n\n\nshort\n0\n\n\nint\n0\n\n\nlong\n0L\n\n\nfloat\n0.0F\n\n\ndouble\n0.0\n\n\nchar\n0 或写为:’\\u0000’(表现为空)\n\n\nboolean\nfalse\n\n\n引用类型\nnull\n\n\n\n\nfor each循环依次处理数组中的每个元素（其他类型的元素集合亦可）而不必为指定下标值而分心。\nfor (v : collection) statement;\n\nint[] ints = new int[100];\nfor (int anInt : ints) &#123;\n    ;\n&#125;\n数组的拷贝将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组：\nint[] ints = new int[100];\nint[] b = int;\n将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：\nint b = Arrays.copyof(a,a.length)\n多维数组// 格式1（动态初始化）：\nint[][] arr = new int[3][2];\n// 格式2（动态初始化）：\nint[][] arr = new int[3][];\n// 每个一维数组都是默认初始化值null (注意：区别于格式1）可以对这个三个一维数组分别进行初始化\narr[0] = new int[3];    \narr[1] = new int[1];   \narr[2] = new int[2];\n注：int[][]arr = new int[][3];  //非法\n// 格式3（静态初始化）：\nint[][] arr = new int[][]&#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;;\n// 注意特殊写法情况：\nint[] x,y[]; x是一维数组，y是二维数组。\n\n// 声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是：\nx[0] = y;  no\ny[0] = x;   yes\ny[0][0] = x;   no\nx[0][0] = y;  no\ny[0][0] = x[0];  yes\nx = y;   no\n// 提示：\n一维数组：int[] x  或者int x[]   \n二维数组：int[][] y 或者 int[] y[]  或者 int y[][]\n数组的默认初始化与内存分析操作数组的工具类Arraysjava.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\n\n\n\n\n工具类Arrays\n\n\n\n\n\nboolean equals(int[] a,int[] b)\n判断两个数组是否相等。\n\n\nString toString(int[] a)\n输出数组信息。\n\n\nvoid fill(int[] a,int val)\n将指定值填充到数组之中。\n\n\nvoid sort(int[] a)\n对数组进行排序。\n\n\nint binarySearch(int[] a,int key)\n对排序后的数组进行二分法检索指定的值。\n\n\nstatic type copyOf(type[] a, int length)\n\n\n\nstatic type copyOfRange(type[] a, int start, int end)\n\n\n\nstatic void sort(type[] a)\n优化的快速排序算法\n\n\nstatic int binarySearch(type[] a, type v)\n\n\n\nstatic int binarySearch(type[] a, int start, int end, type v)\n二分搜索算法查找值v\n\n\nstatic void fill(type[] a, type v)\n将数组的所有数据元素值设置为v。\n\n\nstatic boolean equals(type[] a, type[] b)\n如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。\n\n\n\n\n\n\n\n\n\n\n\nJava关键字    定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）    特点：关键字中所有字母都为小写\n\n\n\n\n用于定义数据类型的关键字\n\n\n\n\n\n\n\n\nclass\ninterface\nenum\nbyte\nshort\n\n\nint\nlong\nfloat\ndouble\nchar\n\n\nboolean\nvoid\n\n\n\n\n\n用于定义流程控制的关键字\n\n\n\n\n\n\nif\nelse\nswitch\ncase\ndefault\n\n\nwhile\ndo\nfor\nbreak\ncontinue\n\n\nreturn\n\n\n\n\n\n\n用于定义访问权限修饰符的关键字\n\n\n\n\n\n\nprivate\nprotect\npublic\n\n\n\n\n用于定义类，函数，变量修饰符的关键字\n\n\n\n\n\n\nabstract\nfinal\nstatic\nsynchronized\n\n\n\n用于定义类与类之间关系的关键字\n\n\n\n\n\n\nextends\nimplements\n\n\n\n\n\n用于定义建立实例及引用实例，判断实例的关键字\n\n\n\n\n\n\nnew\nthis\nsuper\ninstanceof\n\n\n\n用于异常处理的关键字\n\n\n\n\n\n\ntry\ncatch\nfinally\nthrow\nthrows\n\n\n用于包的关键字\n\n\n\n\n\n\npackage\nimport\n\n\n\n\n\n其他修饰符关键字\n\n\n\n\n\n\nnative\nstrictfp\ntransient\nvolatile\nassert\n\n\n* 用于定义数据类型值的字面值\n\n\n\n\n\n\ntrue\nfalse\nnull\n\n\n\n\n\nJava保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto 、const\nJava的内存管理与垃圾回收JVM的内存结构\n\n\n\n\n\n\n\n\n\n\n\n栈（Stack）\n虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、 char 、 short 、 int 、 float 、 long 、 double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。\n\n\n堆（Heap）\n此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。\n\n\n方法区（Method Area）\n用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"J0-Java基础","date":"2021-11-04T06:41:20.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"07213b6ca5497f88ac351468e0325797","title":"Hexo 个人博客搭建","content":"Hexo 个人博客搭建安装步骤\ngithub创建yfr718.github.io项目\n\n安装git、设置用户名和邮箱、ssh连接github\ngit config --global user.name &quot;你的GitHub用户名&quot;\ngit config --global user.email &quot;你的GitHub注册邮箱&quot;\nssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;\n#打开GitHub_Settings_keys 页面，新建new SSH Key\n#Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 \nssh git@github.com\n\n\n\n安装Node.js\n# 安装后，检测Node.js是否安装成功，在命令行中输入 \nnode -v\n\n安装Hexo\n# 在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。\n# 在相应文件夹安装Hexo\nnpm install -g hexo-cli \n# 初始化博客\nhexo init blog\n# 查看博客网页\nhexo g #生成网页\nhexo s #运行网页\n# 完成后，打开浏览器输入地址：\nlocalhost:4000\n\n\nHexo 常用命令博客管理npm install hexo -g # 安装Hexo\nnpm update hexo -g # 升级\nhexo init # 初始化博客\nhexo clean # 清除缓存文件 db.json 和已生成的静态文件 public\nhexo g # 自动生成网站静态文件，并部署到设定的仓库\nhexo s # 启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;\nhexo d # 自动生成网站静态文件，并部署到设定的仓库\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d # 本地更新后重新部署到github上\n文章管理# 新建文章\nhexo new 文章文件名\n一些markdown格式\n\n\n\n\n\n提示\nNormal Tips Container\n\n\n\n\n\n\n\n\n注意\nWarning!!!\n\n\n\n\n\n\n\n\naaa\nWarning!!!\n\n\n\n\n\n\n\n\n特别注意\nDanger!!!\n\n\nClick to see more\n\n隐藏内容\n\n\n\n引用块\n\n","slug":"0.Hexo个人博客搭建","date":"2021-11-02T09:47:00.000Z","categories_index":"前端","tags_index":"hexo","author_index":"YFR718"}]