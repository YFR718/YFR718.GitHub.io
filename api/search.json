[{"id":"3c25c67d0781653798d002eeefd584b0","title":"环境与包管理","content":"1. Pip对 Python 包的查找、下载、安装、卸载的功能。\n1.1 pip常用命令pip的更新\npython -m pip install --upgrade pip\npip安装包\npip install 包名==版本号\npip更新包\npip install --upgrade 要更新的包名\npip删除包\npip uninstall 要卸载的包名\n1.2 pip镜像配置临时使用pip安装包的时候加参数-i 镜像源地址\npip install bs4 -i https://pypi.tuna.tsinghua.edu.cn/simple\n清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/豆瓣：http://pypi.douban.com/simple/\n永久更改Linux：修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\n[global] \nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\nwindows直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，然后新建文件pip.ini，即 %HOMEPATH%\\pip\\pip.ini，在pip.ini文件中输入以下内容（以豆瓣镜像为例）：\n[global]\nindex-url = http://pypi.douban.com/simple\n[install]\ntrusted-host = pypi.douban.com\n1.3 pip依赖迁移导出依赖\npip freeze &gt;  requirements.txt\n安装依赖\npip install -r requirements.txt\n2. Anacondaconda is a tool for managing and deploying applications, environments and packages.\n2.1 下载安装官网下载：Anaconda | The World’s Most Popular Data Science Platform\n下一步、下一步点点点，安装完成\n2.2 conda环境管理conda clean ：净化Anaconda\n# 删除索引缓存，锁定文件，未使用的缓存包，和包。\nconda clean -a\nconda compare：比较conda环境之间的包。\nconda config：配置环境的配置信息。\nconda create：创建新的conda环境。⭐⭐\n# 创建环境：conda create -n 环境名称 [python]\nconda create -n env_name python=3.8\n\n# 用 environment.yml 配置文件创建环境\nconda env create -f nvironment.yml\n\n# 导出environment.yml环境文件\nconda env_name export &gt; environment.yml \n\n\n\n\n\n\n\n\n\n坑爹：\n装新环境必须删除原镜像配置\nconda info：显示有关当前conda安装的信息。\nconda activate env_name：激活环境。⭐⭐\nconda deactivate env_name：停用环境。\nconda env remove —n env_name：删除环境\n构建相同的conda环境（不同机器间的环境复制）\n# 激活需要导出配置文件的环境\nconda list --explicit &gt; files.txt\n# 在同系统的不同机器执行\nconda create --name env_name -f files.txt\n克隆环境（同一台机器的环境复制\nconda create --name clone_env_name --clone env_name\nconda env list：查看环境列表\n2.3 conda包管理conda search [包名]：查看特定包\nconda install 包名[=版本号]：安装指定包\nconda update 包名：更新包\nconda update python：更新python\nconda list：查看当前环境的包\nconda remove 包名：删除包\n2.4 conda镜像修改conda config —remove-key channels恢复默认镜像\nconda config —add 镜像地址\n# 清华大学镜像\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge \nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/\nconda config —show：在channel里查看配置的镜像地址\n3. Jupyter notebook3.1 设置代码提示conda activate base\n\npip install jupyter_contrib_nbextensions\n\njupyter contrib nbextension install --user\n\npip install jupyter_nbextensions_configurator\n\njupyter nbextensions_configurator enable --user\n\n\n3.2 jupyter中添加conda环境查看JupyterNotebook的kernel及存放位置\nipython kernelspec list\n添加kernel\n# 首先安装ipykernel：\nconda install ipykernel\n\n# 在虚拟环境下创建kernel文件：\nconda install -n 环境名称 ipykernel\n\n# 激活conda环境，将环境写入notebook的kernel中\n\npython -m ipykernel install --user --name 环境名称 --display-name \"Python (环境名称)\"\n\n# 打开notebook服务器：jupyter notebook\n\n# 删除kernel环境：\n\njupyter kernelspec remove 环境名称\n","slug":"P3-Anaconda与jupyter notebook","date":"2021-11-11T10:25:42.000Z","categories_index":"Python","tags_index":"","author_index":"YFR718"},{"id":"a3f5b417ccee185425acbc3a549133c3","title":"LeetCode做题记录","content":"刷题汇总\n\n\n\n题号\n题目\n算法\n最优解\n时间复杂度\n\n\n\n\n1\n两数之和\n哈希\n:green_heart:\n$$\n\n\n2\n两数相加\n模拟\n:green_heart:\n\n\n\n3\n无重复字符的最长子串\n\n\n\n\n\n4\n\n\n\n\n\n\n5\n\n\n\n\n\n\n6\n\n\n\n\n\n\n7\n\n\n\n\n\n\n8\n\n\n\n\n\n\n9\n\n\n\n\n\n\n10\n\n\n\n\n\n\n11\n\n\n\n\n\n\n12\n\n\n\n\n\n\n13\n\n\n\n\n\n\n14\n\n\n\n\n\n\n15\n\n\n\n\n\n\n16\n\n\n\n\n\n\n17\n\n\n\n\n\n\n18\n\n\n\n\n\n\n19\n\n\n\n\n\n\n20\n\n\n\n\n\n\n21\n\n\n\n\n\n\n22\n\n\n\n\n\n\n23\n\n\n\n\n\n\n24\n\n\n\n\n\n\n25\n\n\n\n\n\n\n26\n\n\n\n\n\n\n27\n\n\n\n\n\n\n28\n\n\n\n\n\n\n29\n\n\n\n\n\n\n30\n\n\n\n\n\n\n31\n\n\n\n\n\n\n32\n\n\n\n\n\n\n33\n\n\n\n\n\n\n34\n\n\n\n\n\n\n35\n\n\n\n\n\n\n36\n\n\n\n\n\n\n37\n\n\n\n\n\n\n38\n\n\n\n\n\n\n39\n\n\n\n\n\n\n40\n\n\n\n\n\n\n41\n\n\n\n\n\n\n42\n\n\n\n\n\n\n43\n\n\n\n\n\n\n44\n\n\n\n\n\n\n45\n\n\n\n\n\n\n46\n\n\n\n\n\n\n47\n\n\n\n\n\n\n48\n\n\n\n\n\n\n49\n\n\n\n\n\n\n50\n\n\n\n\n\n\n51\n\n\n\n\n\n\n52\n\n\n\n\n\n\n53\n\n\n\n\n\n\n54\n\n\n\n\n\n\n55\n\n\n\n\n\n\n56\n\n\n\n\n\n\n57\n\n\n\n\n\n\n58\n\n\n\n\n\n\n59\n\n\n\n\n\n\n60\n\n\n\n\n\n\n61\n\n\n\n\n\n\n62\n\n\n\n\n\n\n63\n\n\n\n\n\n\n64\n\n\n\n\n\n\n65\n\n\n\n\n\n\n66\n\n\n\n\n\n\n67\n\n\n\n\n\n\n68\n\n\n\n\n\n\n69\n\n\n\n\n\n\n70\n\n\n\n\n\n\n71\n\n\n\n\n\n\n72\n\n\n\n\n\n\n73\n\n\n\n\n\n\n74\n\n\n\n\n\n\n75\n\n\n\n\n\n\n76\n\n\n\n\n\n\n77\n\n\n\n\n\n\n78\n\n\n\n\n\n\n79\n\n\n\n\n\n\n80\n\n\n\n\n\n\n81\n\n\n\n\n\n\n82\n\n\n\n\n\n\n83\n\n\n\n\n\n\n84\n\n\n\n\n\n\n85\n\n\n\n\n\n\n86\n\n\n\n\n\n\n87\n\n\n\n\n\n\n88\n\n\n\n\n\n\n89\n\n\n\n\n\n\n90\n\n\n\n\n\n\n91\n\n\n\n\n\n\n92\n\n\n\n\n\n\n93\n\n\n\n\n\n\n94\n\n\n\n\n\n\n95\n\n\n\n\n\n\n96\n\n\n\n\n\n\n97\n\n\n\n\n\n\n98\n\n\n\n\n\n\n\n算法分类对应题目分类","slug":"l0000","date":"2021-11-05T13:51:29.000Z","categories_index":"LeetCode","tags_index":"","author_index":"YFR718"},{"id":"71dcb878b30b2fb16e5265f7515744d5","title":"疑难杂症队列","content":"Java\n整理笔记，等待发布\n尚硅谷整理的Java学习\n书5.7跳过\n\nLinux\n笔记整理，待发布\nshell编程笔记整理，待发布\n\n算法\nleetcode每日三道题\nACwing课程学习\n\nHadoop\nP88 job提交源码\nP89 切片源码\nP97 、98自定义分区\nP100~102\nP104 Combiner\nP107 OutPutFormat\nP101 源码解析\n\n\n","slug":"1-疑难杂症队列","date":"2021-11-04T05:27:30.000Z","categories_index":"学习规划","tags_index":"","author_index":"YFR718"},{"id":"4a207b7e885fdbcca8129599135e5f2e","title":"MySQL基础","content":"1 MySQL概述1.1 数据库概述数据库的好处持久化数据到本地可以实现结构化查询，方便管理\n数据库相关概念DB：数据库，保存一组有组织的数据的容器DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据SQL:结构化查询语言，用于和DBMS通信的语言\n数据库存储数据的特点\n将数据放到表中，表再放到库中\n一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。\n表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。\n表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”\n表中的数据是按行存储的，每一行类似于java中的“对象”。\n\n1.2 MySQL的背景前身属于瑞典的一家公司，MySQL AB\n08年被sun公司收购\n09年sun被oracle收购\nMySQL优点\n1、开源、免费、成本低\n2、性能高、移植性也好\n3、体积小，便于安装\n1.3 MySQL产品的介绍和安装MySQL服务的启动和停止方式一：计算机——右击管理——服务方式二：通过管理员身份运行\nnet start 服务名（启动服务）\nnet stop 服务名（停止服务）\nMySQL服务的登录和退出  方式一：通过mysql自带的客户端（只限于root用户）\n  方式二：通过windows自带的客户端\n#登录：\nmysql 【-h主机名 -P端口号 】-u用户名 -p密码\n#退出：\nexit或ctrl+C\nMySQL的语法规范不区分大小写,但建议关键字大写，表名、列名小写\n每条命令最好用分号结尾\n每条命令根据需要，可以进行缩进 或换行\n注释\n    单行注释：#注释文字\n    单行注释：-- 注释文字\n    多行注释：/* 注释文字  */\n2. 基本操作存储过程：创建数据库=&gt;确认字段=&gt;创建数据表=&gt;插入数据\n创建数据库# 展示数据库\nmysql&gt; SHOW DATABASES;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sakila             |\n| sys                |\n| world              |\n+--------------------+\n# 打开指定的库\nmysql&gt; use 库名\n# 创建数据库\nmysql&gt; CREATE DATABASE demo;\n# 删除数据库\nmysql&gt; DROP DATABASE demo;\n# 查看服务器的版本\n#方式一：登录到mysql服务端\nmysql&gt; select version();\n#方式二：没有登录到mysql服务端\nmysql --version\n或\nmysql --V\n●”information_schema”是MySQL系统自带的数据库,主要保存MySQL数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件所在的文件夹和系统使用的文件夹，等等。●”performance_ schema”是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。●“sys” 数据库是MySQL系统自带的数据库，主要作用是，以一种更容易被理解的方式展示MySQL数据库服务器的各类性能指标，帮助系统管理员和开发人员监控MySQL的技术性能。●”mysql”数据库保存了MySQL数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等。\n确认字段MySQL数据表由行与列组成，一行就是一条数据记录， 每一条数据记录都被分成许多列，一列就叫一个字段。每个字段都需要定义数据类型，这个数据类型叫做字段类型。\n创建数据表#展示数据表\nmysql&gt; SHOW TABLES;\n+----------------+\n| Tables_in_demo |\n+----------------+\n| test           |\n+----------------+\n# 查看其它库的所有表\nmysql&gt; show tables from 库名;\n#创建数据表\nmysql&gt; CREATE TABLE demo.test(barcode text,goodname text,price int);\n# 查看表结构\nmysql&gt; desc 表名;\nmysql&gt; show columns from actor;\nmysql&gt; DESCRIBE demo.test;\n+----------+---------+------+-----+---------+-------+\n| Field    | Type    | Null | Key | Default | Extra |\n+----------+---------+------+-----+---------+-------+\n| barcode  | text    | YES  |     | NULL    |       |\n| goodname | text    | YES  |     | NULL    |       |\n| price    | int(11) | YES  |     | NULL    |       |\n+----------+---------+------+-----+---------+-------+\n●Field: 表示字段名称。●Type: 表示字段类型。●Null: 表示这个字段是否允许是空值(NULL) 。在MySQL里面,空值不等于空字符串。一个空字符串的长度是0,而一个空值的长度是空。而且，在MySQL里面，空值是占用空间的。●Key:我们暂时把它叫做键。●Default: 表示默认值。我们导入的表的所有的字段都允许是空，默认值都是NULL。●Extra:表示附加信息。\n#其他show语句\n❑ SHOW STATUS，用于显示广泛的服务器状态信息；\n❑ SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句；\n❑ SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；\n❑ SHOW ERRORS 和 SHOW WARNINGS，用来显示服务器错误或警告消息。\n插入数据#添加主键\nALTER TABLE demo. test\nADD COLUMN itemnumber int PRIMARY KEY AUTO_INCREMENT ;\n#向表中添加数据\nINSERT INTO demo.test\n(barcode, goodsname,price)\nVALUES ('0001','本' ,3);\n\nSQL的语言分类DQL（Data Query Language）：数据查询语言\n    select \nDML(Data Manipulate Language):数据操作语言\n    insert 、update、delete\nDDL（Data Define Languge）：数据定义语言\n    create、drop、alter\nTCL（Transaction Control Language）：事务控制语言\n    commit、rollback\n3. DQL语言数据查询语言：select \n/*\n类似于Java中 :System.out.println(要打印的东西);\n特点：\n①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在\n② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数*/\n\n#检索单个列\nmysql&gt; SELECT 列名 FROM 表名;\n#检索多个列\nmysql&gt; SELECT 列名,列名... FROM 表名;\n#检索所有列\nmysql&gt; SELECT * FROM 表名;\n#使用完全限定的名字\nmysql&gt; SELECT 表名.列名 FROM 数据库.表名;\n#拼接计算字段\nmysql&gt; SELECT CONCAT(列名，列名) FROM 表名;\n#计算字段运算\nmysql&gt; SELECT 列名*5 FROM 表名;\n\n\n\n\n子句\n功能\n示例\n\n\n\n\nDISTINCT\n去重\nSELECT DISTINCT 列名 FROM 表名;\n\n\nLIMIT\n限制行数\nSELECT 列名 FROM 表名 LIMIT 10;SELECT 列名 FROM 表名 LIMIT 10,3; #从行10开始取3行\n\n\nORDER BY\n排序\nSELECT 列名 FROM 表名 ORDER BY 列名 LIMIT 10;   //先排序再取10SELECT 列名 FROM 表名 ORDER BY 列名,列名..;     //按多个列排序\n\n\nDESC\n降序排\nSELECT 列名 FROM 表名 ORDER BY 列名 DESC;\n\n\nASC\n升序排\n与不加相同\n\n\nWHERE\n数据过滤\nSELECT 列名 FROM 表名 WHERE 条件;\n\n\nGROUP BY\n分组数据\nSELECT 列名 FROM 表名 GROUP BY 列名;\n\n\nHAVING\n过滤基于分组值\nSELECT 列名 FROM 表名 GROUP BY 列名 HAVING COUNT(*)&gt;=2;;\n\n\nUNION (ALL)\n组合查询\n执行多条SELECT语句，并将结果作为单个查询结果集返回\n\n\n\n\nSELECT子句顺序\n\n\n\n子句\n说明\n是否必须使用\n\n\n\n\nSELECT\n要返回的列\n是\n\n\nFROM\n要检索的表\n仅在表中选择数据\n\n\nWHERE\n行过滤\n否\n\n\nGROUP BY\n分组说明\n仅在按组计算聚集时\n\n\nHAVING\n组过滤\n否\n\n\nORDER BY\n排序\n否\n\n\nLIMIT\n要检索的行数\n否\n\n\n\n\nWHERE子句操作符\n\n\n\n操作符\n说明\n\n\n\n\n=\n等于\n\n\n&lt;&gt;或!=\n不等于\n\n\n&lt;,&lt;=,&gt;,&gt;=\n小于大于\n\n\nBETWEEN A AND B\n[A,B]\n\n\nIS NULL\n空值检查\n\n\nAND OR NOT\n与 或 非\n\n\nIN (A,B)\n集合范围匹配\n\n\n()\n优先运算括号里的\n\n\nLIKE\n通配符\n\n\n\n\n优先级：AND&gt;OR\n通配符LIKE用法\n\n\n\n通配符\n含义\n示例\n\n\n\n\n%\n任何字符出现任意次数\nWHERE 列名 LIKE ‘yfr%’：\n\n\n_\n只匹配单个字符\nWHERE 列名 LIKE ‘yfr_’：\n\n\n\n\n正则表达式\n\n\n\n关键字\n含义\n示例\n\n\n\n\nREGEXP\n包含\nwhere 列名 REGEXP ‘400’;\n\n\nBINARY\n不区分大小匹配\nwhere 列名 REGEXP BINARY  ‘AS’;\n\n\n\\\n\nOR匹配\nwhere 列名 REGEXP ‘400\\\n500’;\n\n\n[123]\n匹配几个字符之一\nwhere 列名 REGEXP ‘[123]400’;\n\n\n123\n匹配几个字符之外所有\nwhere 列名 REGEXP ‘[\\^123]400’;\n\n\n[0-9]\n范围匹配\nwhere 列名 REGEXP ‘[0-9]400’;\n\n\n\\\\\n匹配特殊字符．、[]、\n和-where 列名 REGEXP ‘\\400’;\n\n\n字符类\n匹配字符类\n[ :alpha: ] [:blank:]等等\n\n\n{n,m}\n匹配数目范围\nwhere 列名 REGEXP ‘[0-9]{1,}’;匹配一次以上\n\n\n[[:&lt;:]]、[[:&gt;:]]、$、^\n定位符：词的开始/尾，文本的开始/尾\nwhere 列名 REGEXP ‘^[0-9]’;\n\n\n\n\n函数文本处理函数\n\n\n\n函数\n\n\n\n\n\nConcat()\n拼接\n\n\nUpper()\n转换成大写\n\n\nLower()\n转换成小写\n\n\nTrim()\n去前后指定的空格和字符\n\n\nLeft()\n返回串左边的字符\n\n\nLength()\n返回串的长度\n\n\nLocate()\n找出串的一个子串\n\n\nLower()\n将串转换为小写\n\n\nLTrim()\n去掉串左边的空格\n\n\nRight()\n返回串右边的字符\n\n\nRTrim()\n去掉串右边的空格\n\n\nSoundex()\n返回串的SOUNDEX值\n\n\nSubString()\n返回子串的字符\n\n\nUpper()\n将串转换为大写\n\n\nReplace()\n替换\n\n\nLpad()\n左填充\n\n\nRpad()\n右填充\n\n\nInstr()\n返回子串第一次出现的索引\n\n\n\n\n数值和日期时间处理函数\n\n\n\n数值函数\n日期函数\n\n\n\n\nAbs()\nAddData()\n\n\nCos()\nAddTime()\n\n\nExp()\nCurData() 当前系统日期\n\n\nMod() 取余\nDate()\n\n\nPi()\nDay()\n\n\nRand()  随机数\nHour()\n\n\nSin()\nMinute()\n\n\nSqrt()\nNow() 当前系统日期+时间\n\n\nTan()\nYear()\n\n\nRound() 四舍五入\nCurtime() 当前系统时间\n\n\nFloor() 向下取整\nStr_to_date() 将字符转换成日期\n\n\nCeil() 向上取整\nDate_format() 将日期转换成字符\n\n\nTruncate() 截断\n\n\n\n\nSQL聚集函数\n\n\n\n函数\n\n\n\n\n\nAVG()\nmysql&gt; SELECT AVG(列名) from 表名;\n\n\nCOUNT()\nmysql&gt; SELECT COUNT(列名) from 表名;\n\n\nMAX()\nmysql&gt; SELECT MAX(列名) from 表名;\n\n\nMIN()\nmysql&gt; SELECT MIN(列名) from 表名;\n\n\nSUM()\nmysql&gt; SELECT SUM(列名) from 表名;\n\n\n\n\n特点：\n1、以上五个分组函数都忽略null值，除了count(*)\n2、sum和avg一般用于处理数值型\n    max、min、count可以处理任何数据类型\n3、都可以搭配distinct使用，用于统计去重后的结果\n4、count的参数可以支持：\n    字段、*、常量值，一般放1\n\n   建议使用 count(*)\n流程控制函数\n\n\n\n函数\n\n\n\n\n\nIF(判断条件，返回1，返回2)\n\n\n\ncase语句\n处理多分支：处理等值判断、处理条件判断\n\n\n\n\n\n\n\n其他函数\n\n\n\n函数\n\n\n\n\n\nversion() 版本\n\n\n\ndatabase() 当前库\n\n\n\nuser() 当前连接用户\n\n\n\npassword(‘字符’)：返回该字符的密码形式\n\n\n\nmd5(‘字符’):返回该字符的md5加密形式\n\n\n\n\n子查询嵌套在其他查询中的查询,在外面的查询语句，称为主查询或外查询。\nSELECT cust_id\nFROM orders\nWHERE order_num IN (SELECT order_num\n                     FROM orderitems\n                     WHERE prod_id = 'TNT2');\n/*\n1、子查询都放在小括号内\n2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧\n3、子查询优先于主查询执行，主查询使用了子查询的执行结果\n4、子查询根据查询结果的行数不同分为以下两类：\n① 单行子查询\n\t结果集只有一行\n\t一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= \n\t非法使用子查询的情况：\n\ta、子查询的结果为一组值\n\tb、子查询的结果为空\n\t\n② 多行子查询\n\t结果集有多行\n\t一般搭配多行操作符使用：any、all、in、not in\n\tin： 属于子查询结果中的任意一个就行\n\tany和all往往可以用其他查询代替\n\t*/\n连接表jion联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。\n#等值联结（equijoin）\nSELECT *\nFROM A,B\nWHERE A.c=B.c;\n\n1.等值连接的结果 = 多个表的交集\n2.n表连接，至少需要n-1个连接条件\n3.多个表不分主次，没有顺序要求\n4.一般为表起别名，提高阅读性和性能\n\n#内部联结\nSELECT *\nFROM A INNER JOIN B\nWHERE A.c=B.c;\n#自然联结\nSELECT *\nFROM A AS a,A AS b\nWHERE a.c=b.c;\n#外部联结\nSELECT *\nFROM A OUTER JOIN B\nWHERE A.c=B.c;\n性能考虑 MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。\n\n自然联结：无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。自然联结排除多次出现，使每个列只返回一次。\n外部联结：许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。\n\nsql99语法：通过join关键字实现连接含义：1999年推出的sql语法\n支持：\n等值连接、非等值连接 （内连接）\n外连接\n交叉连接\n\n语法：\n\nselect 字段，...\nfrom 表1\n【inner|left outer|right outer|cross】join 表2 on  连接条件\n【inner|left outer|right outer|cross】join 表3 on  连接条件\n【where 筛选条件】\n【group by 分组字段】\n【having 分组后的筛选条件】\n【order by 排序的字段或表达式】\n\n好处：语句上，连接条件和筛选条件实现了分离，简洁明了！\n别名AS:别名简化编码\nSELECT name as n\nFROM papa as p,Baba as b\nWHERE p.c=b.c;\n分页查询应用场景：实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句\nselect 字段|表达式,...\nfrom 表\n【where 条件】\n【group by 分组字段】\n【having 条件】\n【order by 排序的字段】\nlimit 【起始的条目索引，】条目数;\n特点：\n1.起始条目索引从0开始\n\n2.limit子句放在查询语句的最后\n\n3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage\n假如:\n每页显示条目数sizePerPage\n要显示的页数 page\n联合查询union 联合、合并\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】\n.....\nselect 字段|常量|表达式|函数 【from 表】 【where 条件】\n特点：\n1、多条查询语句的查询的列数必须是一致的\n2、多条查询语句的查询的列的类型几乎相同\n3、union代表去重，union all代表不去重\n4. DML语言数据操作语言：insert、update、delete\n4.1 插入语法：\ninsert into 表名(字段名，...)\nvalues(值1，...);\n\n# 支持一次插入多行，语法如下：\ninsert into 表名【(字段名,..)】 values(值，..),(值，...),...;\n\n#支持子查询，语法如下：\ninsert into 表名 查询语句;\n\ninsert into 表名 set 字段=值,字段=值,...;\n特点：\n\n字段类型和值类型一致或兼容，而且一一对应\n可以为空的字段，可以不用插入值，或用null填充\n不可以为空的字段，必须插入值\n字段个数和值的个数必须一致\n字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致\n\n4.2 修改修改单表语法：\nupdate 表名 set 字段=新值,字段=新值\n【where 条件】\n修改多表语法：\nupdate 表1 别名1,表2 别名2\nset 字段=新值，字段=新值\nwhere 连接条件\nand 筛选条件\n4.3 删除方式1：delete语句单表的删除： ★\ndelete from 表名 【where 筛选条件】\n多表的删除：    delete 别名1，别名2    from 表1 别名1，表2 别名2    where 连接条件    and 筛选条件;\n方式2：truncate语句truncate table 表名\n两种方式的区别【面试题】\n#1.truncate不能加where条件，而delete可以加where条件\n\n#2.truncate的效率高一丢丢\n\n#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始\n#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始\n\n#4.truncate删除不能回滚，delete删除可以回滚\n5. DDL语言数据定义语言：create、drop、alter\n5.1 库和表的管理一、创建库\ncreate database 库名\n二、删除库\ndrop database 库名\n5.2 创建表 createcreate table 表名(\n  字段名 字段类型 not null,#非空\n  字段名 字段类型 primary key,#主键\n  字段名 字段类型 unique,#唯一\n  字段名 字段类型 default 值,#默认\n  constraint 约束名 foreign key(字段名) references 主表（被引用列）\n)\nCREATE TABLE IF NOT EXISTS stuinfo(\n\tstuId INT,\n\tstuName VARCHAR(20),\n\tgender CHAR,\n\tbornDate DATETIME\n);\nDESC studentinfo;\n\n\n\n\n\n支持类型\n可以起约束名\n\n\n\n\n列级约束\n除了外键\n不可以\n\n\n表级约束\n除了非空和默认\n可以，但对主键无效\n\n\n\n\n列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求\n常见类型\n\n常见约束\nNOT NULL：非空，该字段的值必填\nUNIQUE：唯一，该字段的值不可重复\nDEFAULT：默认，该字段的值不用手动插入有默认值\nCHECK：检查，mysql不支持\nPRIMARY KEY：主键，该字段的值不可重复并且非空 unique+not null\nFOREIGN KEY：外键，该字段的值引用了另外的表的字段\n主键和唯一\n1、区别：\n①、一个表至多有一个主键，但可以有多个唯一\n②、主键不允许为空，唯一可以为空\n2、相同点\n都具有唯一性，都支持组合键，但不推荐\n外键：\n\n用于限制两个表的关系，从表的字段值引用了主表的某字段值\n外键列和主表的被引用列要求类型一致，意义一样，名称无要求\n主表的被引用列要求是一个key（一般就是主键）\n插入数据，先插入主表，删除数据，先删除从表\n\n可以通过以下两种方式来删除主表的记录\n#方式一：级联删除\nALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;\n\n#方式二：级联置空\nALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;\n自增长列特点：\n\n不用手动插入值，可以自动提供序列值，默认从1开始，步长为1\n\n如果要更改起始值：手动插入值\n如果要更改步长：更改系统变量\nset auto_increment_increment=值;\n\n一个表至多有一个自增长列\n\n自增长列只能支持数值型\n\n自增长列必须为一个key\n\n\n创建表时设置自增长列\ncreate table 表(\n\t字段名 字段类型 约束 auto_increment\n)\n修改表时设置自增长列\nalter table 表 modify column 字段名 字段类型 约束 auto_increment\n删除自增长列\nalter table 表 modify column 字段名 字段类型 约束 \n5.3 修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;\n\n#修改字段名\nALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;\n\n#修改表名\nALTER TABLE stuinfo RENAME [TO]  studentinfo;\n\n#修改字段类型和列级约束\nALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;\n\n#添加字段\nALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;\n\n#删除字段\nALTER TABLE studentinfo DROP COLUMN email;\n\n#添加列\nalter table 表名 add column 列名 类型 【first|after 字段名】;\n\n#修改列名\nalter table 表名 change column 旧列名 新列名 类型;\n\n#删除列\nalter table 表名 drop column 列名;\n\n修改表时添加或删除约束\n1、非空\n添加非空\nalter table 表名 modify column 字段名 字段类型 not null;\n删除非空\nalter table 表名 modify column 字段名 字段类型 ;\n\n2、默认\n添加默认\nalter table 表名 modify column 字段名 字段类型 default 值;\n删除默认\nalter table 表名 modify column 字段名 字段类型 ;\n3、主键\n添加主键\nalter table 表名 add【 constraint 约束名】 primary key(字段名);\n删除主键\nalter table 表名 drop primary key;\n\n4、唯一\n添加唯一\nalter table 表名 add【 constraint 约束名】 unique(字段名);\n删除唯一\nalter table 表名 drop index 索引名;\n5、外键\n添加外键\nalter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;\n删除外键\nalter table 表名 drop foreign key 约束名;\n\n5.4 删除表DROP TABLE [IF EXISTS] studentinfo;\n复制表\n\n复制表的结构create table 表名 like 旧表;\n复制表的结构+数据create table 表名select 查询列表 from 旧表【where 筛选】;\n\n6. TCL语言事务控制语言：commit、rollback\n6.1 数据库事务含义：通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态\n特点（ACID）：\n\n原子性：要么都执行，要么都回滚\n一致性：保证数据的状态操作前和操作后保持一致\n隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰\n持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改\n\n相关步骤：\n开启事务\n编写事务的一组逻辑操作单元（多条sql语句）\n提交事务或回滚事务\n\n事务的分类：隐式事务，没有明显的开启和结束事务的标志，比如 insert、update、delete语句本身就是一个事务\n显式事务，具有明显的开启和结束事务的标志\n1、开启事务\n取消自动提交事务的功能\n\n2、编写事务的一组逻辑操作单元（多条sql语句）\ninsert\nupdate\ndelete\n\n3、提交事务或回滚事务\n使用到的关键字set autocommit=0;\nstart transaction;\ncommit;\nrollback;\n\nsavepoint  断点\ncommit to 断点\nrollback to 断点\n事务的隔离级别:事务并发问题如何发生？\n\n\n\n\n\n\n\n\n\n当多个事务同时操作同一个数据库的相同数据时\n事务的并发问题有哪些？\n\n\n\n\n\n\n\n\n\n脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据\n如何避免事务的并发问题？\n\n\n\n\n\n\n\n\n\n通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读\n设置隔离级别：\nset session|global  transaction isolation level 隔离级别名;\n查看隔离级别：\nselect @@tx_isolation;\n7. 视图含义：理解成一张虚拟的表\n视图和表的区别：\n\n\n\n\n\n使用方式\n占用物理空间\n\n\n\n\n视图\n完全相同\n占用物理空间\n\n\n表\n完全相同\n占用\n\n\n\n\n\n\n\n\n视图的好处：\n\nsql语句提高重用性，效率高\n和表实现了分离，提高了安全性\n\n7.1 视图的创建、删除、查看CREATE VIEW  视图名\nAS\n查询语句;\n\n#视图的删除\nDROP VIEW test_v1,test_v2,test_v3;\n\n###视图结构的查看\t\nDESC test_v7;\nSHOW CREATE VIEW test_v7;\n7.2 视图的增删改查1、查看视图的数据 ★\nSELECT * FROM my_v4;\nSELECT * FROM my_v1 WHERE last_name='Partners';\n\n2、插入视图的数据\nINSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);\n\n3、修改视图的数据\nUPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';\n\n4、删除视图的数据\nDELETE FROM my_v4;\n​    \n7.3 某些视图不能更新​    包含以下关键字的sql语句：\n\n分组函数、distinct、group  by、having、union或者union all\n常量视图\nSelect中包含子查询\njoin\nfrom一个不能更新的视图\nwhere子句的子查询引用了from子句中的表\n\n\n7.4 视图逻辑的更新#方式一：\nCREATE OR REPLACE VIEW test_v7\nAS\nSELECT last_name FROM employees\nWHERE employee_id&gt;100;\n\n#方式二:\nALTER VIEW test_v7\nAS\nSELECT employee_id FROM employees;\n\nSELECT * FROM test_v7;\n8 存储过程含义：一组经过预先编译的sql语句的集合好处：\n\n提高了sql语句的重用性，减少了开发程序员的压力\n提高了效率\n减少了传输次数\n\n分类：\n1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个\n8.1 创建存储过程语法：\ncreate procedure 存储过程名(in|out|inout 参数名  参数类型,...)\nbegin\n\t存储过程体\nend\n类似于方法：\n修饰符 返回类型 方法名(参数类型 参数名,...){\n\n\t方法体;\n}\n注意\n\n需要设置新的结束标记delimiter 新的结束标记\n\n示例：\ndelimiter $\n\nCREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)\nBEGIN\n\tsql语句1;\n\tsql语句2;\n\nEND $\n\n\n存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end\n\n参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出\n\n\n8.2 调用存储过程call 存储过程名(实参列表)\n学过的函数：LENGTH、SUBSTR、CONCAT等语法：\nCREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型\nBEGIN\n\t函数体\n\nEND\n调用函数：SELECT 函数名（实参列表）\n函数和存储过程的区别\n\n\n\n\n\n关键字\n调用语法\n返回值\n应用场景\n\n\n\n\n函数\nFUNCTION\nSELECT\n只能是一个\n一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个\n\n\n存储过程\nPROCEDURE\nCALL\n可以有0个或多个\n一般用于更新\n\n\n\n\n8.3 查看存储过程show create procedure 存储过程名;\n8.4 删除drop procedure 存储过程名;\n9 流程控制结构9.1 系统变量全局变量\n作用域：针对于所有会话（连接）有效，但不能跨重启\n查看所有全局变量\nSHOW GLOBAL VARIABLES;\n查看满足条件的部分系统变量\nSHOW GLOBAL VARIABLES LIKE '%char%';\n查看指定的系统变量的值\nSELECT @@global.autocommit;\n为某个系统变量赋值\nSET @@global.autocommit=0;\nSET GLOBAL autocommit=0;\n会话变量\n作用域：针对于当前会话（连接）有效\n查看所有会话变量\nSHOW SESSION VARIABLES;\n查看满足条件的部分会话变量\nSHOW SESSION VARIABLES LIKE '%char%';\n查看指定的会话变量的值\nSELECT @@autocommit;\nSELECT @@session.tx_isolation;\n为某个会话变量赋值\nSET @@session.tx_isolation='read-uncommitted';\nSET SESSION tx_isolation='read-committed';\n9.2 自定义变量用户变量\n声明并初始化：\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名:=值;\n赋值：\n方式一：一般用于赋简单的值\nSET 变量名=值;\nSET 变量名:=值;\nSELECT 变量名:=值;\n方式二：一般用于赋表 中的字段值\nSELECT 字段名或表达式 INTO 变量\nFROM 表;\n使用：\nselect @变量名;\n局部变量\n声明：\ndeclare 变量名 类型 【default 值】;\n赋值：\n方式一：一般用于赋简单的值\nSET 变量名=值;\nSET 变量名:=值;\nSELECT 变量名:=值;\n方式二：一般用于赋表 中的字段值\nSELECT 字段名或表达式 INTO 变量\nFROM 表;\n使用：\nselect 变量名\n二者的区别：\n\n\n\n\n\n作用域\n定义位置\n语法\n\n\n\n\n语法\n当前会话\n会话的任何地方\n加@符号，不用指定类型\n\n\n局部变量\n定义它的BEGIN END中\nBEGIN END的第一句话\n一般不用加@,需要指定类型\n\n\n\n\n9.3 分支if函数    语法：if(条件，值1，值2)    特点：可以用在任何位置\ncase语句\n情况一：类似于switch\ncase 表达式\nwhen 值1 then 结果1或语句1(如果是语句，需要加分号) \nwhen 值2 then 结果2或语句2(如果是语句，需要加分号)\n...\nelse 结果n或语句n(如果是语句，需要加分号)\nend 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）\n\n情况二：类似于多重if\ncase \nwhen 条件1 then 结果1或语句1(如果是语句，需要加分号) \nwhen 条件2 then 结果2或语句2(如果是语句，需要加分号)\n...\nelse 结果n或语句n(如果是语句，需要加分号)\nend 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）\n特点：可以用在任何位置\nif elseif语句\nif 情况1 then 语句1;\nelseif 情况2 then 语句2;\n...\nelse 语句n;\nend if;\n特点：只能用在begin end中！！！！！！！！！！！！！！！应用场合\n\nif函数：简单双分支\ncase结构：等值判断 的多分支\nif结构：区间判断 的多分支\n\n9.4 循环【标签：】WHILE 循环条件  DO\n    循环体\nEND WHILE 【标签】;\n特点：\n只能放在BEGIN END里面\n如果要搭配leave跳转语句，需要使用标签，否则可以不用标签\nleave类似于java中的break语句，跳出所在循环！！！\n","slug":"MySQL基础","date":"2021-11-10T12:30:04.000Z","categories_index":"数据库","tags_index":"MySQL","author_index":"YFR718"},{"id":"31135c47a98e6bfd7ef6f55be399b5e8","title":"PyMySQL","content":"1. 连接数据库import pymysql\n\n# 创建连接对象\nconn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')\n\n# 获取游标对象\ncursor = conn.cursor()\n\n# 关闭游标\ncursor.close()\n\n# 关闭连接\nconn.close()\n2. 数据库操作2.1 DQL语言selectselect选择\n# 查询 SQL 语句\nsql = \"select * from students;\"\n# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数\nrow_count = cursor.execute(sql)\n\n# 取出结果集中一行数据,　例如:(1, '张三')\nprint(cursor.fetchone())\n\n# 取出结果集中的所有数据, 例如:((1, '张三'), (2, '李四'), (3, '王五'))\nfor line in cursor.fetchall():\n    print(line)\n        \nPython查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。\n\nfetchone(): 该方法获取下一个查询结果集。结果集是一个对象\n\nfetchall(): 接收全部的返回结果行.\n\nrowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。\n\n\n2.2 DML数据操作语言insert 、update、deleteinsert插入\n# SQL 插入语句\nsql = \"\"\"INSERT INTO EMPLOYEE(FIRST_NAME,\n         LAST_NAME, AGE, SEX, INCOME)\n         VALUES ('Mac', 'Mohan', 20, 'M', 2000)\"\"\"\ntry:\n   # 执行sql语句\n   cursor.execute(sql)\n   # 提交到数据库执行\n   db.commit()\nexcept:\n   # 如果发生错误则回滚\n   db.rollback()\n插入多行数据时，数据是list，其中元素是元组。\n# 一次插入多行数据\n# print(value)\nsql = 'insert into summary(id,dataname,herf,rel) values(%s,%s,%s,%s)'\nvalue = []\nfor rep in root.findall('repository'):\n    id = rep.find('id').text\n    dataname = rep.find('name').text\n    herf = rep.find('link').attrib['href']\n    rel = rep.find('link').attrib['rel']\n    value.append((id,dataname,herf,rel))\n    \ntry:\n    cursor.executemany(sql,value)\n    db.commit()\n    print(\"summary写入成功\")\nexcept Exception as e:\n    print(e)\n    db.rollback()\n    print(\"summary写入失败\")\nfinally:\n    db.close()\n\nupdate更新\n# SQL 更新语句\nsql = \"UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'\" % ('M')\ntry:\n   # 执行SQL语句\n   cursor.execute(sql)\n   # 提交到数据库执行\n   db.commit()\nexcept:\n   # 发生错误时回滚\n   db.rollback()\ndelete删除\n# SQL 删除语句\nsql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; %s\" % (20)\ntry:\n   # 执行SQL语句\n   cursor.execute(sql)\n   # 提交修改\n   db.commit()\nexcept:\n   # 发生错误时回滚\n   db.rollback()\n2.3 DDL数据定义语言create、drop、altercreate创建数据表\n# 使用 cursor() 方法创建一个游标对象 cursor\ncursor = db.cursor()\n \n\n# 使用预处理语句创建表\nsql = \"\"\"CREATE TABLE EMPLOYEE (\n         FIRST_NAME  CHAR(20) NOT NULL,\n         LAST_NAME  CHAR(20),\n         AGE INT,  \n         SEX CHAR(1),\n         INCOME FLOAT )\"\"\"\n \ncursor.execute(sql)\ndrop删除数据表\n# 使用 execute() 方法执行 SQL，如果表存在则删除\ncursor.execute(\"DROP TABLE IF EXISTS EMPLOYEE\")\n \nalter更改数据表\n2.4 TCL事务控制语言commit、rollback# SQL删除记录语句\nsql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; %s\" % (20)\ntry:\n   # 执行SQL语句\n   cursor.execute(sql)\n   # 向数据库提交\n   db.commit()\nexcept:\n   # 发生错误时回滚\n   db.rollback()\n","slug":"P2-PyMySQL","date":"2021-11-10T02:06:01.000Z","categories_index":"Python","tags_index":"MySQL","author_index":"YFR718"},{"id":"446bbf5d6e6c49aba6d56562199f8a0a","title":"XML解析","content":"1 xml.etree.ElementTree对Python的轻量级XML支持。\nXML是一种固有的分层数据格式，最自然的表示方法是使用树。这个模块有两个类用于此目的:\n\nElementTree将整个XML文档表示为树。\n元素表示此树中的单个节点。\n\n​        与整个文档的交互(对文件的读写)通常在ElementTree级别完成。与单个XML元素及其子元素的交互是在element级别上完成的。\n​        元素是一种灵活的容器对象，用于在内存中存储分层数据结构。它可以被描述为介于列表和字典之间的混合体。每个元素都有许多与之相关的属性:\n\n‘tag’——包含元素名称的字符串。\n‘attributes’——一个存储元素属性的Python字典。\n‘text’ -一个包含元素文本内容的字符串。\n‘tail’ -一个可选字符串，在元素的结束标签之后包含文本。以及一系列存储在Python序列中的子元素。\n\n​        要创建元素实例，请使用element构造函数或SubElement工厂函数。还可以使用ElementTree类包装元素结构，并将其与XML进行转换。\n1.1 导入数据从xml文件导入\nimport xml.etree.ElementTree as ET\ntree = ET.parse('country_data.xml')\nroot = tree.getroot()\n从html导入\nimport xml.etree.ElementTree as ET\n# 要爬取的地址\nurl = \"https://www.re3data.org/api/v1/repositories\"\nres = requests.get(url)\nroot = ET.fromstring(res.text)\n1.2 数据查询1.2.1 获取四个属性print(root.tag)\nprint(root.attrib)\nprint(root.tail)\nprint(res.text)\n1.2.2 访问子节点用 len(Element) 检查子节点个数\n用 Element[0] 访问第0个子节点，Element[1] 访问第1个子节点…\n用 for child in Element 遍历所有子节点\n用 Element.remove(child) 删除某个子节点\nfor i in root:\n    print(i.tag)\n1.2.3 查询指定标签\nElementt.iter() #递归迭代xml文件中所有节点（包含子节点，以及子节点的子节点），返回一个包含所有节点的迭代器\nElement.find(tag) #查找第一个节点为tag的直接子元素，返回一个节点对象\nElement.findall(tag) #查找节点为tag的所有直接子元素’，返回一个节点列表直接子元素的意思：只会查找当前节点的子节点那一级目录\n\nfor rep in root.findall('repository'):\n    # print(rep.find('id').text)\n    # print(rep.find('name').text)\n    print(rep.find('link').attrib['href'],rep.find('link').attrib['rel'])\n处理含namespace的文件\nnamespace = \"{http://www.re3data.org/schema/2-2}\"\nfor element in root.iter(namespace + \"re3data.orgIdentifier\"):  # ID\n    print(\"1#   \", element.text)\n    ID = element.text\n1.2.4 树结构与 XML 字符串的相互转换使用 xml.etree.ElementTree 包中的 tostring() 和 fromstring() 函数：\n\n如果 tostring() 参数不指定 encoding=\"unicode\"，函数将返回 byte 序列。\n\nfrom xml.etree.ElementTree import Element, tostring\n\ntree_str = tostring(root, encoding=\"unicode\")\n\nnew_root = fromstring(tree_str)\nprint(new_root.tag, new_root[0].tag, new_root[1].tag)\n1.3 数据创建1.3.1 创建树节点创建树节点时，一定要指定节点名：\ntree_node = Element(\"node1\")\nprint(tree_node.tag)    # 输出 node1\nprint(tree_node.text)   # 输出 None\nprint(tree_node.tail)   # 输出 None\nprint(tree_node.attrib) # 输出 {}\n也可在创建时指定属性（Element.attrib）：\ntree_node = Element(\"node2\", {\"attr1\": 1, \"attr2\": 2})\nprint(tree_node.tag)    # 输出 node2\nprint(tree_node.text)   # 输出 None\nprint(tree_node.tail)   # 输出 None\nprint(tree_node.attrib) # 输出 {'attr1': 1, 'attr2': 2}\n1.3.2 设置文本（Element.text）或附加文本（Element.tail）创建节点后，可以设置 text, tail 等类成员。这些成员的初始值为 None。\ntree_node = Element(\"node1\")\ntree_node.text = \"Hello world\"\ntree_node.tail = \"Bye\"\n1.3.3 添加子节点可以用 Element.append() 成员函数添加子节点：\nroot = Element(\"root\")\nchild1 = Element(\"child1\")\nchild2 = Element(\"child2\")\n\nroot.append(child1)\nroot.append(child2)\n","slug":"P1-XML解析","date":"2021-11-10T01:23:54.000Z","categories_index":"Python","tags_index":"XML","author_index":"YFR718"},{"id":"0e809b380a45c732473fb3fa1636bd4c","title":"ASCII码","content":"ASCII码表格：\n\n\n\n\nASCII值\n控制字符\nASCII值\n字符\nASCII值\n字符\nASCII值\n字符\n\n\n\n\n0\nNUT\n32\n(space)\n64\n@\n96\n、\n\n\n1\nSOH\n33\n!\n65\nA\n97\na\n\n\n2\nSTX\n34\n“\n66\nB\n98\nb\n\n\n3\nETX\n35\n#\n67\nC\n99\nc\n\n\n4\nEOT\n36\n$\n68\nD\n100\nd\n\n\n5\nENQ\n37\n%\n69\nE\n101\ne\n\n\n6\nACK\n38\n&amp;\n70\nF\n102\nf\n\n\n7\nBEL\n39\n,\n71\nG\n103\ng\n\n\n8\nBS\n40\n(\n72\nH\n104\nh\n\n\n9\nHT\n41\n)\n73\nI\n105\ni\n\n\n10\nLF\n42\n*\n74\nJ\n106\nj\n\n\n11\nVT\n43\n+\n75\nK\n107\nk\n\n\n12\nFF\n44\n,\n76\nL\n108\nl\n\n\n13\nCR\n45\n-\n77\nM\n109\nm\n\n\n14\nSO\n46\n.\n78\nN\n110\nn\n\n\n15\nSI\n47\n/\n79\nO\n111\no\n\n\n16\nDLE\n48\n0\n80\nP\n112\np\n\n\n17\nDCI\n49\n1\n81\nQ\n113\nq\n\n\n18\nDC2\n50\n2\n82\nR\n114\nr\n\n\n19\nDC3\n51\n3\n83\nS\n115\ns\n\n\n20\nDC4\n52\n4\n84\nT\n116\nt\n\n\n21\nNAK\n53\n5\n85\nU\n117\nu\n\n\n22\nSYN\n54\n6\n86\nV\n118\nv\n\n\n23\nTB\n55\n7\n87\nW\n119\nw\n\n\n24\nCAN\n56\n8\n88\nX\n120\nx\n\n\n25\nEM\n57\n9\n89\nY\n121\ny\n\n\n26\nSUB\n58\n:\n90\nZ\n122\nz\n\n\n27\nESC\n59\n;\n91\n[\n123\n{\n\n\n28\nFS\n60\n&lt;\n92\n/\n124\n\\\n\n\n\n29\nGS\n61\n=\n93\n]\n125\n}\n\n\n30\nRS\n62\n&gt;\n94\n^\n126\n`\n\n\n31\nUS\n63\n?\n95\n_\n127\nDEL\n\n\n\n\nASCII 码大致由以下两部分组成：\n\nASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。\nASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。\n\n","slug":"0-计算机基础","date":"2021-11-06T11:52:59.000Z","categories_index":"计算机基础","tags_index":"","author_index":"YFR718"},{"id":"fa82b363c947b237a81a51347767262e","title":"4. 寻找两个正序数组的中位数","content":"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n\n\n\n\n\n\n\n\n\n输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2\n\n\n\n\n\n\n\nsort\n将两数组合在一起，排序后直接输出中位数。\n\n\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int l1 = nums1.length, l2 = nums2.length;\n        int[] nums = new int[l1+l2];\n        for(int i = 0;i &lt; l1; i++) {\n            nums[i] = nums1[i];\n        }\n        for(int i = 0; i &lt; l2; i++) {\n            nums[l1+i] = nums2[i];\n        }\n        Arrays.sort(nums);\n\n        if((l1 + l2) % 2 == 1) {\n            return (double)nums[(l1 + l2) / 2];\n        }else{\n            return (double)(nums[(l1 + l2) / 2]+nums[(l1 + l2) / 2 - 1]) / 2.0;\n        }\n    }\n}\n\n\n\n\n\n\n\n 递归\n🚹\n\n\n:heart\n","slug":"l0004","date":"2021-11-05T12:34:37.000Z","categories_index":"LeetCode","tags_index":"双指针","author_index":"YFR718"},{"id":"02ad4c9c8b4647bd8676742f0e73d72a","title":"3. 无重复字符的最长子串","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n\n\n\n\n\n\n\n\n输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n\n\n\n\n\n\n双指针 \n\n设置左指针初值-1，右指针初值0，int数组对区间(l,r]出现过的字母计数\nfor循环对右指针指向的字母计数\n如果计数&lt;=1,更新答案\n如果计数&gt;1,左指针向右移，直到计数=1\n\n\n\n// 数组计数\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int a[] = new int[1000];\n        int l = -1, r = 0;\n        int maxl = 0;\n        for(r = 0; r&lt; s.length();r++){\n            a[(int)s.charAt(r)]+=1;     // 计数\n            if(a[(int)s.charAt(r)]&lt;=1){ // 不重复更新答案\n                maxl = maxl&gt; (r-l) ? maxl: r-l; \n            }else{                      //重复左指针向右移，直到不重复\n                while(a[(int)s.charAt(r)]&gt;1){\n                    l+=1;\n                    a[(int)s.charAt(l)]-=1;\n                }\n            }\n        }\n        return maxl;\n    }\n    \n}\n// 哈希集合\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set&lt;Character&gt; occ = new HashSet&lt;Character&gt;();\n        int len = s.length();\n        int l = -1, r = 0;\n        int maxl = 0;\n        for(r = 0; r&lt; s.length();r++){\n            while(occ.contains(s.charAt(r))) {\n                occ.remove(s.charAt(++l));\n            }\n            occ.add(s.charAt(r));\n            maxl = Math.max(maxl,r-l);\n        }\n        return maxl;\n    }\n    \n}\n","slug":"l0003","date":"2021-11-05T12:09:37.000Z","categories_index":"LeetCode","tags_index":"双指针","author_index":"YFR718"},{"id":"f8534e8f12d0bc66698739d3b7153c65","title":"J5.对象与类","content":"面向对象编程OOP类(Class)和对象(Object)是面向对象的核心概念。\n\n类是对一类事物的描述，是抽象的、概念上的定义\n对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。\n属 性：对应类中的成员变量\n行 为：对应类中的成员方法\n由类构造（construct）对象的过程称为创建类的实例（instance）。\n\n创建Java自定义类\n\n定义类（考虑修饰符、类名）\n编写类的属性（考虑修饰符、属性类型、属性名、初始化值）\n编写类的方法（考虑修饰符、返回值类型、方法名、形参等）\n\n对象的创建和使用\n创建对象语法： 类名 对象名 = new 类名();使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）\n属性修饰符 数据类型 属性名 = 初始化值 ; \n\n修饰符：常用的权限修饰符有：private、缺省、protected、public，其他修饰符：static、final (暂不考虑)\n数据类型：任何基本数据类型(如int、Boolean) 或 任何引用数据类型。\n属性名：属于标识符，符合命名规则和规范即可。\n\n变量的分类：成员变量与局部变量\n\n\n\n\n\n\n成员变量\n局部变量\n\n\n\n\n声明的位置\n直接声明在类中\n方法形参或内部、代码块内、构造器内等\n\n\n修饰符\nprivate、public、static、final等\n不能用权限修饰符修饰，可以用final修饰\n\n\n初始化值\n有默认初始化值\n没有默认初始化值，必须显式赋值，方可使用\n\n\n内存加载位置\n堆空间 或 静态域内\n栈空间\n\n\n\n\n方法\n方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。\n将功能封装为方法的目的是，可以实现代码重用，简化代码\nJava里的方法不能独立存在，所有的方法必须定义在类里。\n\n// 方法的声明格式：\n修饰符  返回值类型  方法名（参数类型形参1, 参数类型形参2, ….）｛\n    方法体程序代码\n    return 返回值;\n}\n修饰符：public,缺省,private, protected等返回值类型：\n返回值类型：没有返回值：void，有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用\n方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” \n形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开返回值：方法在执行完毕后返还给调用它的程序的数据。\nmain方法\n\n\n\nmain方法\n\n\n\n\n\npublic\n由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n\nstatic\n因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的\n\n\nString[] args\n该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数\n\n\n\n\n代码块代码块(或初始化块)的作用： 对Java类或对象进行初始化代码块(或初始化块)的分类：一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。\n// static代码块通常用于初始化static的属性\nclass Person {\n    public static int total; \n    static {\n        total = 100;//为total赋初值\n    }\n}\n\n静态代码块：用static 修饰的代码块\n\n\n可以有输出语句。\n可以对类的属性、类的声明进行初始化操作。\n不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。\n若有多个静态的代码块，那么按照从上到下的顺序依次执行。\n静态代码块的执行要先于非静态代码块。\n静态代码块随着类的加载而加载，且只执行一次。\n\n\n非静态代码块：没有static修饰的代码块\n\n\n可以有输出语句。\n可以对类的属性、类的声明进行初始化操作。\n除了调用非静态的结构外，还可以调用静态的变量或方法。\n若有多个非静态的代码块，那么按照从上到下的顺序依次执行。\n每次创建对象的时候，都会执行一次。且先于构造器执行。\n\n⭐程序中成员变量赋值的执行顺序\n\n声明成员变量的默认初始化\n显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）\n构造器再对成员进行初始化操作\n通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值\n\n重载 overload在同一个类中，允许存在一个以上的==同名方法==，只要它们的==参数个数或者参数类型==不同即可。\n==与返回值类型无关==，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。\n//返回两个整数的和\nint add(int x,int y){return x+y;}\n//返回三个整数的和\nint add(int x,int y,int z){return x+y+z;} \n//返回两个小数的和\ndouble add(double x,double y){return x+y;}\n可变个数的形参public static void test(int a ,String…books);\n\n可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个\n可变个数形参的方法与同名的方法之间，彼此构成重载\n可变参数方法的使用与方法参数部分使用数组是一致的\n方法的参数部分有可变形参，需要放在形参声明的最后\n在一个方法的形参位置，最多只能声明一个可变个数形参\n\n方法参数的值传递机制    形参：方法声明时的参数    实参：方法调用时实际传给形参的参数值\nJava里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。\n    形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参    形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参\nint[] arr = new int[10];\nSystem.out.println(arr);//地址值\nchar[] arr1 = new char[10]; System.out.println(arr1); //内容\n//源码解析\npublic void println(Object x) {\n    String s = String.valueOf(x);\n    synchronized (this) {\n        print(s);\n        newLine();\n    }\n}\npublic void println(char x[]) {\n    synchronized (this) {\n        print(x);\n        newLine();\n    }\n}\n构造器 (或构造方法)构造器的特征\n\n它具有与类相同的名称\n它不声明返回值类型。（与声明为void不同）\n不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值\n\n构造器的作用：创建对象；给对象进行初始化\n\n如：Order o = new Order();    Person p = new Person(“Peter”,15);\n如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。\n\n// 语法格式：\n修饰符 类名 (参数列表) {\n    初始化语句;\n}\n根据参数不同，构造器可以分为如下两类：    隐式无参构造器（系统默认提供）    显式定义一个或多个构造器（无参、有参）注 意：    Java语言中，每个类都至少有一个构造器    默认构造器的修饰符与所属类的修饰符一致    一旦显式定义了构造器，则系统不再提供默认构造器    一个类可以创建多个重载的构造器    父类的构造器不可被子类继承\n构造器重载\n构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。\n// 构造器重载举例：\npublic class Person{\n    public Person(String name, int age, Date d) {this(name,age);…} \n    public Person(String name, int age) {…}\n    public Person(String name, Date d) {…}\n    public Person(){…}\n}\n关键字—this    它在方法内部使用，即这个方法所属对象的引用；    它在构造器内部使用，表示该构造器正在初始化的对象。\nthis 可以调用类的属性、方法和构造器\n什么时候使用this关键字呢？    当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。比如：this.name = name;\n⭐this可以作为一个类中构造器相互调用的特殊格式\nclass Person{\n    //定义Person类\n    private String name ;\n    private int age ;\n    public Person(){\n        //无参构造器\n        System.out.println(\"新对象实例化\");\n    }\n    public Person(String name ){\n        this(); //调用本类中的无参构造器\n        this.name = name ;\n    }\n    public Person(String name,int age){\n        this(name); // 调用有一个参数的构造器\n        this.age = age;\n    }\n    public String getInfo(){\n    return \"姓名: \"+name+\"，年龄:\"+age;\n    }\n}\n\n    可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！    明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器    如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”    “this(形参列表)”必须声明在类的构造器的首行！    在类的一个构造器中，最多只能声明一个”this(形参列表)”\n封装与隐藏    高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；    低耦合 ：仅对外暴露少量的方法用于使用。\n隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。\nJava中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：\n    隐藏一个类中不需要对外提供的实现细节；    使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；    便于修改，增强代码的可维护性；\n\n\n\n\n修饰符\n类内部\n同一个包\n不同包的子类\n同一个工程\n\n\n\n\nprivate\n√\n\n\n\n\n\n(缺省)\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\n\n\n包(package)的管理与作用package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：package 顶层包名.子包名 ;\n//举例：pack1\\pack2\\PackageTest.java\npackage pack1.pack2;    //指定类PackageTest属于包pack1.pack2 \n\npublic class PackageTest{\n    public void display(){\n        System.out.println(\"in  method display()\");\n    }\n}\n    包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次；    包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx\n包的作用：\n    包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式    包可以包含类和子包，划分项目层次，便于管理    解决类命名冲突的问题    控制访问权限\n\n\n\n\n\nJDK中主要的包介绍\n\n\n\n\njava.lang\n包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能\n\n\njava.net\n包含执行与网络相关的操作的类和接口\n\n\njava.io\n包含能提供多种输入/输出功能的类\n\n\njava.util\n包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数\n\n\njava.text\n包含了一些java格式化相关的类\n\n\njava.sql\n包含了java进行JDBC数据库编程的相关类/接口\n\n\njava.awt\n包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)\n\n\n\n\n\n","slug":"J6-对象与类","date":"2021-11-05T06:23:36.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"Java数组数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组的常见概念\n\n数组名\n下标(或索引)\n元素\n数组的长度\n\n一维数组的创建与使用// 一维数组的声明方式：\ntype var[] 或 type[]  var;\n//Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： \nint a[5];  //非法\n//动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行\nint[] arr = new int[3];\nString names[]; names = new String[3];\n//静态初始化：在定义数组的同时就为数组元素分配空间并赋值。\nint arr[] = new int[]{ 3, 9, 8};\nint[] arr = {3,9,8};\n// 属性length\na.length 指明数组a的长度(元素个数)\n数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。\n\n对于基本数据类型而言，默认初始化值各有不同\n对于引用数据类型而言，默认初始化值为null(注意与0不同！\n\n\n\n\n\n\n\n\n\n\n数组元素类型\n元素默认初始值\n\n\n\n\nbyte\n0\n\n\nshort\n0\n\n\nint\n0\n\n\nlong\n0L\n\n\nfloat\n0.0F\n\n\ndouble\n0.0\n\n\nchar\n0 或写为:’\\u0000’(表现为空)\n\n\nboolean\nfalse\n\n\n引用类型\nnull\n\n\n\n\nfor each循环依次处理数组中的每个元素（其他类型的元素集合亦可）而不必为指定下标值而分心。\nfor (v : collection) statement;\n\nint[] ints = new int[100];\nfor (int anInt : ints) {\n    ;\n}\n数组的拷贝将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组：\nint[] ints = new int[100];\nint[] b = int;\n将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：\nint b = Arrays.copyof(a,a.length)\n多维数组// 格式1（动态初始化）：\nint[][] arr = new int[3][2];\n// 格式2（动态初始化）：\nint[][] arr = new int[3][];\n// 每个一维数组都是默认初始化值null (注意：区别于格式1）可以对这个三个一维数组分别进行初始化\narr[0] = new int[3];    \narr[1] = new int[1];   \narr[2] = new int[2];\n注：int[][]arr = new int[][3];  //非法\n// 格式3（静态初始化）：\nint[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}};\n// 注意特殊写法情况：\nint[] x,y[]; x是一维数组，y是二维数组。\n\n// 声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是：\nx[0] = y;  no\ny[0] = x;   yes\ny[0][0] = x;   no\nx[0][0] = y;  no\ny[0][0] = x[0];  yes\nx = y;   no\n// 提示：\n一维数组：int[] x  或者int x[]   \n二维数组：int[][] y 或者 int[] y[]  或者 int y[][]\n数组的默认初始化与内存分析操作数组的工具类Arraysjava.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\n\n\n\n\n工具类Arrays\n\n\n\n\n\nboolean equals(int[] a,int[] b)\n判断两个数组是否相等。\n\n\nString toString(int[] a)\n输出数组信息。\n\n\nvoid fill(int[] a,int val)\n将指定值填充到数组之中。\n\n\nvoid sort(int[] a)\n对数组进行排序。\n\n\nint binarySearch(int[] a,int key)\n对排序后的数组进行二分法检索指定的值。\n\n\nstatic type copyOf(type[] a, int length)\n\n\n\nstatic type copyOfRange(type[] a, int start, int end)\n\n\n\nstatic void sort(type[] a)\n优化的快速排序算法\n\n\nstatic int binarySearch(type[] a, type v)\n\n\n\nstatic int binarySearch(type[] a, int start, int end, type v)\n二分搜索算法查找值v\n\n\nstatic void fill(type[] a, type v)\n将数组的所有数据元素值设置为v。\n\n\nstatic boolean equals(type[] a, type[] b)\n如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"J5-数组","date":"2021-11-05T03:24:52.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"1d98d63915f551c9747efb3393617836","title":"控制流程","content":"块作用域 Block块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。\n注意：\n\n不能在嵌套的两个块中声明同名的变量。\n块内定义的变量块外不能使用。\n\n\n流程控制语句\n\n\n\n流程控制\n\n\n\n\n\n\n顺序结构\n\n\n\n\n分支语句\nif-else、switch-case\n\n\n\n循环结构\nfor、while、do-while\n\n\n\n特殊流程控制语句\nbreak、continue、return\n\n\n\n\nswitch (i){\n    case 0:...;\n        break;\n    case 1:...;\n        break;\n    default:...;\n        break;\n}\ncase标签可以是：\n● 类型为char、byte、short或int的常量表达式。\n● 枚举常量。\n● 从Java SE 7开始，case标签还可以是字符串字面量。\n带标签的break语句有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望跳到嵌套的所有循环语句之外。通过添加一些额外的条件判断实现各层循环的检测很不方便。\n这里有一个示例说明了break语句的工作状态。请注意，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。\nlabel:\n{\n    ...\n\tif (condition) break label; // exits b1ock\n\t...\n}\n\n大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。\n//使用静态的valueOf方法可以将普通的数值转换为大数值\nBigInteger a = BigInteger.valueOf(999999999999999999l);\n\n//使用大数值类中的add和multiply方法。\nBigInteger d = a.multiply(a);\nSystem.out.println(d);\n\n\n\n\nBigInteger\n\n\n\n\n\nBigInteger add(BigInteger other)\n+\n\n\nBigInteger subtract(BigInteger other)\n-\n\n\nBigInteger multiply(BigInteger other)\n*\n\n\nBigInteger divide(BigInteger other)\n/\n\n\nBigInteger divide(BigInteger other)\n%\n\n\nint compareTo(BigInteger other)\n相等，返回0；小于，返回负数；否则，返回正数。\n\n\nstatic BigInteger valueOf(long x)\n返回值等于x的大整数。\n\n\n\n\n\n\n\n\nBigInteger\n\n\n\n\n\nBigDecimal add(BigDecimal other)\n+\n\n\nBigDecimal subtract(BigDecimal other)\n-\n\n\nBigDecimal multiply(BigDecimal other)\n*\n\n\nBigDecimal multiply(BigDecimal other)\n/\n\n\nint compareTo(BigDecimal other)\n比较\n\n\nstatic BigDecimal valueOf(long x)\n\n\n\nstatic BigDecimal valueOf(long x, int scale)\n\n\n\n\n\n","slug":"J4-控制流程","date":"2021-11-05T02:34:28.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"9c8bf421039c727b1fd8f06884d0808c","title":"输入输出","content":"标准输入输出数据读入import java.util.Scanner;\nScanner in = new Scanner(System,in);\n// 读入一行\nString name = in.nextLine();\n//读入一个单词\nString name = in.next();\n//读入一个整数\n int a = sc.nextInt();\n\n\n\n\n\n方法\n功能\n\n\n\n\nScanner (InputStream in)\n用给定的输入流创建一个Scanner对象。\n\n\nString nextLine( )\n读取输入的下一行内容。\n\n\nString next( )\n读取输入的下一个单词（以空格作为分隔符）。\n\n\nint nextInt( ) int nextInt( )\n读取并转换下一个表示整数或浮点数的字符序列。\n\n\nboolean hasNext( )\n检测输入中是否还有其他单词。\n\n\nboolean hasNextInt( )boolean hasNextDouble( )\n检测是否还有表示整数或浮点数的下一个字符序列。\n\n\nstatic Console console( )\n\n\n\n\n格式化输出System.out.print(x)\n每一个以%字符开始的格式说明符都用相应的参数替换。格式说明符尾部的转换符将指示被格式化的数值类型：\n\n\n\n\n转换符\n类型\n\n\n\n\nd\n十进制\n\n\nx\n十六进制\n\n\no\n八进制\n\n\nf\n定点浮点数\n\n\ne\n指数浮点数\n\n\ng\n通用浮点数\n\n\na\n十六进制浮点数\n\n\ns\n字符串\n\n\nc\n字符\n\n\nb\n布尔\n\n\nh\n散列码\n\n\ntx/TX\n日期时间\n\n\n%\n百分号\n\n\nn\n行分隔符\n\n\n\n\n可以使用多个标志，例如，“%, ( .2f”使用分组的分隔符并将负数括在括号内。\n\n\n\n\n标志\n目的\n\n\n\n\n+\n打印正负号\n\n\n空格\n在正整数前加空格\n\n\n0\n数字前补0\n\n\n-\n左对齐\n\n\n(\n将负数扩在括号里\n\n\n,\n添加分组分隔符\n\n\n#(对f格式)\n包含小数点\n\n\n#(对x或0格式)\n添加前缀0x\n\n\n$\n给定被格式化的参数索引。例如，%ISd. %1$x 将以十进制和十六进制格式打印第1个参数\n\n\n&lt;\n格式化前面说明的数值。例如，%d%&lt;x以十进制和十六进制打印同一个数值\n\n\n\n\n\n\n\n文件输入与输出文件读取要想对文件进行读取，就需要一个用File对象构造一个Scanner对象，如下所示：\nScanner in = new Scanner(Paths.get(\"myfile.txt\"),\"UTF-8\");\n如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠：“c:\\mydirectory\\myfile.txt”。\n文件写入要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：\nPrintWriter out = new PrintWriter(\"myfile.txt\",\"UTF-8\");\n\n\n\n\n\n\n\n\n\n\nScanner(File f)\n构造一个从给定文件读取数据的Scanner。\n\n\nScanner(String data)\n构造一个从给定字符串读取数据的Scanner。\n\n\nPrintWriter(String fileName)\nPrintWriter(String fileName)\n\n\nstatic Path get(String pathname)\n根据给定的路径名构造一个Path。\n\n\n\n\n\n\n\n","slug":"J3-输入输出","date":"2021-11-05T01:34:37.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"4ec631ba9c8264548f541e9cb0021e69","title":"2. 两数相加","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n\n\n\n\n\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.\n\n\n\n\n\n\n\n模拟\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode ans = new ListNode();\n        ListNode a = ans;\n        int t = 0;\n        while(l1 != null || l2 != null){\n            if(l1 != null) {\n                t += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null) {\n                t += l2.val;\n                l2 = l2.next;\n            }\n            a.next = new ListNode(t%10);\n            a = a.next;\n            t = t/10;\n        }\n        if(t != 0) a.next = new ListNode(t);\n        return ans.next;\n\n    }\n}\n","slug":"l0002","date":"2021-11-04T14:51:28.000Z","categories_index":"LeetCode","tags_index":"链表","author_index":"YFR718"},{"id":"61e4c5a8a060ffe1cb587c8f535074c6","title":"String","content":"常用方法String s = \"123456\";\n\n\n\n\n常用方法\n功能\n示例/说明\n\n\n\n\ns.substring(x,y)\n获得字串[x,y-1]\na.substring(0,3)\n\n\ns1 + s2\n拼接字符串\ns + “789”\n\n\nString.jion(‘’,”,s1,s2,s3)\n多个字符串放在一起用分隔符\n静态方法\n\n\ns.equals(s1)\n检查两字符串是否相等\n\n\n\ns.equalsIgnoreCase(s1)\n检查两字符串是否相等，忽略大小写\n\n\n\ns.length()\n获取字符串长度\n空串：长度为0\n\n\ns.codePointCount(0，s.length();\n得到实际的长度，即码点数量\n\n\n\ns.charAt(n)\n返回位置n的代码单元\n\n\n\nint codePointAt(int index)\n返回从给定位置开始的码点。\n\n\n\nint offsetByCodePoints(int startIndex, int cpCount)\n返回从startIndex代码点开始，位移cpCount后的码点索引。\n\n\n\nint compareTo(String other)\n按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。\n\n\n\nIntStream codePoints()\n将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nboolean equalsIgnoreCase(String other)\nboolean equalsIgnoreCase(String other)\n\n\n\nboolean startsWith(String prefix)\n\n\n\n\nboolean endsWith(String suffix)\n如果字符串以suffix开头或结尾，则返回true。\n\n\n\nint index0f(String str, int fromIndex)\n返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。\n\n\n\nint lastIndex0f(String str, int fromIndex)\nint lastIndex0f(String str, int fromIndex)\n\n\n\nint codePointCount(int startIndex, int endIndex)\n返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。\n\n\n\nString replace(CharSequence oldString, CharSequence newString)\n返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。\n\n\n\nString toUpperCase( )String toUpperCase( )\n返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。\n\n\n\nString trim( )\n返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。\n\n\n\n\n\n\n\n\n\n注意事项：\n\nString没办法修改字符串，可以通过提取字串+拼接实现\n\n一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。\nif(s.substring(0,3) == \"123\") // false\n\n\nStringBuilder需要由较短的字符串构建字符串\nStringBuilder builder = new StringBuilder();\n//当每次需要添加一部分内容时，就调用append方法。\nbuilder.append(\"1\");\nbuilder.append(\"2\");\n//在需要构建字符串时就调用toString方法\nSystem.out.println(builder.toString());\n\n\n\n\n\n\n\n\n\n这个类的前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑（通常都是这样），则应该用StringBuilder替代它。这两个类的API是相同的。\nAPI\n\n\n\n\n方法\n功能\n\n\n\n\n\nStringBuilder()\n构造一个空的字符串构建器。\n\n\n\nint length()\n返回构建器或缓冲器中的代码单元数量。\n\n\n\nStringBuilder append(String str)\n追加一个字符串并返回this。\n\n\n\nStringBuilder append(char c)\n追加一个代码单元并返回this。\n\n\n\nStringBuilder appendCodePoint(int cp)\n追加一个代码点，并将其转换为一个或两个代码单元并返回this。\n\n\n\nvoid setCharAt(int i, char c)\n将第i个代码单元设置为c。\n\n\n\nStringBuilder insert(int offset, String str)\n在offset位置插入一个字符串并返回this。\n\n\n\nStringBuilder insert(int offset, Char c)\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n\n","slug":"J2-String","date":"2021-11-04T14:38:01.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"2a28fcbe1a17ab37c1c849fd02eb2771","title":"1. 两数之和","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n\n\n\n\n\n\n\n\n\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n\n\n\n\n\n暴力解法\n双重for循环\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0;i&lt;nums.length;i++) { \n            for(int j = i+1;j&lt;nums.length;j++) {\n                if(nums[i] + nums[j] == target) {\n                    return new int[] {i,j};\n                }\n            }\n        }\n        return new int[] {0};\n    }\n}\n\n\n\n\n\n\n\n 哈希表\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; hashTable = new HashMap&lt;Integer, Integer&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            if(hashTable.containsKey(target - nums[i])) {\n                return new int[]{hashTable.get(target - nums[i]),i};\n            }\n            hashTable.put(nums[i],i);\n        }\n        return new int[] {0};\n\n    }\n}\n# Python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            r = target-nums[i]\n            if r in d:\n                return [d[r],i]\n            else:\n                d[nums[i]]=i\n","slug":"l0001","date":"2021-11-04T12:06:25.000Z","categories_index":"LeetCode","tags_index":"哈希","author_index":"YFR718"},{"id":"234a650b9f919d31820f31482789a1da","title":"基本数据类型","content":"基本数据类型整数\n\n\n\n类型\n存储需求\n取值范围\n例\n\n\n\n\nint\n4字节\n（21亿）\n10\n\n\nshort\n2字节\n（32768）\n\n\n\nlong\n8字节\n\n10L\n\n\nbyte\n1字节\n（128）\n\n\n\n\n浮点数\n\n\n\n类型\n存储需求\n符号位\n指数位\n尾数位\n例\n\n\n\n\nfloat\n4字节\n1\n8\n23\n3.14F\n\n\ndouble\n8字节\n1\n11\n52\n3.14\n\n\n\n\n更详细\nchar类型\n\n\n\n类型\n存储需求\n\n\n\n\n\nchar\n2字节\n1\n\n\n\n\nchar类型的字面量值要用单引号括起来。例如：’A’.\n在Java中，char类型描述了UTF-16编码中的一个代码单元。对char类型字符运行时，直接当做ASCII表对应的整数来对待。\nUnicode 编码:一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。\nUnicode 的缺点：Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别 Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。\nUTF-8:一种变长的编码方式。它可以使用 1-6 个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则：1）对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。2）对于多字节的UTF-8编码，如果编码包含 n 个字节，那么第一个字节的前 n 位为1，第一个字节的第 n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。\nboolean\n\n\n\n类型\n存储需求\n\n\n\n\n\nboolean\n1位\ntrue/flase\n\n\n\n\n变量变量的声明与使用标识符：Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符定义合法标识符规则：\n\n由26个英文字母大小写，0-9 ，_或$ 组成\n数字不可以开头。\n不可以使用关键字和保留字，但能包含关键字和保留字。\nJava中严格区分大小写，长度无限制。\n标识符不能包含空格。\n\n变量的概念：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。变量的作用：用于在内存中保存数据\n使用变量注意：\n\nJava中每个变量必须先声明，后使用\n使用变量名来访问这块区域的数据\n变量的作用域：其定义所在的一对{ }内\n变量只有在其作用域内才有效\n同一个作用域内，不能定义重名的变量\n\n声明变量\n\n语法：&lt;数据类型&gt; &lt;变量名称&gt;;\n\n例如：int var;\n\n\n变量的赋值\n\n语法：&lt;变量名称&gt; =  &lt;值&gt;\n例如：var = 10;\n\n声明和赋值变量\n\n语法： &lt;数据类型&gt; &lt;变量名&gt; =  &lt;初始化值&gt;\n例如：int var = 10;\n\n变量的分类-按数据类型\n\n变量的分类-按声明的位置\n\n在方法体外，类体内声明的变量称为成员变量。\n在方法体内部声明的变量称为局部变量。\n\n\n常量在Java中，利用关键字final指示常量。\nfinal int A = 1000;\n数值类型之间的转换自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：\n\n\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\nbyte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。\nboolean类型不能与其它数据类型运算。\n当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。\n\nString str1 = 4; //判断对错: no\nString str2= 3.5f + \"\"; //判断str2对错: yes\nSystem.out.printIn(str2); //输出:”3.5”\nSystem.out .println(3+4+\"Hello!\"); //输出:7Hello!\nSystem.out.println(\"Hello!\" +3+4); //输出: Hello!34\nSystem.out.printIn('a'+ 1+\"Hello!\"); //输 出: 98Hello!\nSystem.out.printIn(\"Hello\"+'a'+1); //输出: Helloa1\n强制类型转换：将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。\n通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n// 判断是否能通过编译\nshort s = 5;\ns = s - 2; //报错：int 不能用short存储\ns = (short) (s - 2); //正确写法\n\nbyte b = 3;\nb = b + 4; //报错：int 不能用byte存储\nb = (byte) (b + 4); //正确写法\n\nchar a = 'a';\nint i = 5;\nfloat d = .314F;\ndouble result = a + i + d; //正确\n\nbyte b = 5;\nshort s = 3;\nshort t = s + b; //报错：int 不能用short存储\n进制与运算符\n\n\n\n进制\n\n\n\n\n\n\n二进制 (binary)\n0,1\n满2进1.以0b或0B开头\n\n\n十进制 (decimal)\n0-9\n满10进1\n\n\n八进制 (octal)：\n0-7\n满8进1. 以数字0开头表示\n\n\n十六进制 (hex) (hex)(hex)(hex)：\n0-9，A-F\n满16进1. 以0x或0X开头表示\n\n\n\n\n进制的基本转换    十进制 二进制互转       二进制转成十进制 乘以2的幂数       十进制转成二进制 除以2取余数    二进制 八进制互转    二进制 十六进制互转    十进制八进制互转    十进制十六进制互转\n\n\n\n\n运算符\n运算\n\n\n\n\n算术运算符\n+-*/%++–\n\n\n赋值运算符\n=,+=, -=, *=, /=, %=\n\n\n比较运算符（关系运算符）\n==,!=,&lt;,&gt;,&lt;=,&gt;=,instanceof\n\n\n逻辑运算符\n&amp;,\\\n,!,&amp;&amp;,\\\n\\\n,^\n\n\n位运算符\n&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,\\\n,^,~\n\n\n三元运算符\n(条件表达式)?表达式1：表达式2；\n\n\n\n\n\n\n\n\n\n位运算符的细节\n\n\n\n\n&lt;&lt;\n空位补0，被移除的高位丢弃，空缺位补0。\n\n\n&gt;&gt;\n被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。\n\n\n&gt;&gt;&gt;\n被移位二进制最高位无论是0或者是1，空缺位都用0补。\n\n\n&amp;\n二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;\n\n\n\\\n\n二进制位进行 \\\n运算，只有0 \\\n0时结果是0，否则是1;\n\n\n^\n相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1\n\n\n~\n正数取反，各二进制码按补码各位取反负数取反，各二进制码按补码各位取反\n\n\n\n\n运算优先级：\n思考1：\nshort s = 3; \ns = s+2;//s1+2运算结果是int型，需要强制转换类型   \n① s += 2;    //+= 不改变原本的数据类型\n\n思考2：\nint i = 1;\ni *= 0.1;  //*= 不改变原本的数据类型\nSystem.out.println(i);\ni++;\nSystem.out.println(i);\n\n思考3：\nint m = 2;\nint n = 3;\nn *= m++; \nSystem.out.println(\"m=\" + m); System.out.println(\"n=\" + n); 3，6\n    \n思考4：\nint n = 10;\nn += (n++) + (++n); //10 + 10 + 12\nSystem.out.println(n);\n“&amp;”和“&amp;&amp;”的区别：“|”和“||”的区别同理    单&amp;时，左边无论真假，右边都进行运算；    双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。\nint x = 1,y = 1;\nif(x++==2 &amp; ++y==2){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，2\nint x = 1,y = 1;\nif(x++==2 &amp;&amp; ++y==2){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，1\nint x = 1,y = 1;\nif(x++==1 | ++y==1){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，2\n\nint x = 1,y = 1;\nif(x++==1 || ++y==1){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，1\n\nclass Test {\n    public static void main (String [] args) {\n        boolean x=true;\n        boolean y=false;\n        short z=42;\n        //if(y == true)\n        if((z++==42)&amp;&amp;(y=true))z++;\n        if((x=false) || (++z==45)) z++;\n        System.out.println(\"z=\"+z);\n    }\n}\n// z=46\n","slug":"J1-数据类型","date":"2021-11-04T09:50:09.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"2646898c8ef5a9766cbd5f124442ee5c","title":"Java概述","content":"Java概述是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。\nJava语言特性\n特点一：面向对象\n两个基本概念：类、对象\n三大特性：封装、继承、多态\n\n特点二：健壮性\n吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制\n\n特点三：跨平台性\n跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”\n原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。\n因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。\n\n\n核心机制—Java虚拟机\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n对于不同的平台，有不同的虚拟机。\n只有某平台提供了对应的java虚拟机，java程序才可在此平台运行\nJava虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”\n\n核心机制—垃圾回收​        不再使用的内存空间应回收——垃圾回收。在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。\n\n\n\n\nJava语言的环境\n功能\n包含\n\n\n\n\nJDK(Java Development Kit    Java开发工具包)\nJDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。\nJRE + 开发工具集（编译工具javac.exe 打包工具jar.exe)\n\n\nJRE(Java Runtime Environment    Java运行环境)\n包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\nJVM + Java SE标准类库\n\n\nJVM (Java Virtal Machine Java虚拟机）\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n\n\n\n\nHello Java​        我们来编写第一个简单的Java程序：\npublic class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\npublic称为访问修饰符（accessmodifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。\nclass表明Java程序中的全部内容都包含在类中。\nHelloJava：类名。\nstatic：静态方法。\nvoid：无参数返回。\nmain：主方法，程序的入口。\nString[]：程序执行的参数。\nargs：参数名。\nSystem.out.println()：输出一行语句。\n\nJava运行步骤：\n将 Java 代码编写到扩展名为 .java 的文件中。\n通过 javac 命令对该 java 文件进行编译。\n通过 java 命令对生成的 class 文件进行运行。\n\nC:\\Users\\24378\\Desktop\\Java>javac f1.java\nC:\\Users\\24378\\Desktop\\Java>java f1\nhello Java\n一些规范Java命名规范\n\n\n\n类型(名)\n约束\n列\n\n\n\n\n项目\n全部小写，画线-分隔\nspring-cloud\n\n\n包\n全部小写\ncom.yfr.softmax\n\n\n类\n单次首字母大写\nNewWorld\n\n\n变量/方法\n首字母小写\nuserName\n\n\n常量\n全部大写，下划线_分隔\nINT_MAX\n\n\n\n\nJava代码编写规范public class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\n注意大括号的风格\n二元三元运算符两边用一个空格隔开\n逗号语句后如不换行，紧跟一个空格\n将类似操作，或一组操作放在一起不用空行隔开，而用空行隔开不同组的代码\n每个if while for等语句，都不要省略大括号{}\n\nJava注释\n\n\n\n注释类型\n\n\n\n\n\n\n单行注释\n//注释文字\n\n\n\n多行注释\n/  注释文字 /\n\n\n\n文档注释：\n/*@author  指定java程序的作者@version  指定源文件的版本/\n\n\n\n\n# 生成注释文档\nPS C:\\Users\\24378\\Desktop\\Java&gt; javadoc -d mydoc -author -version .\\f1.java\n正在加载源文件.\\f1.java...\n正在构造 Javadoc 信息...\n...\nJava注意事项\nJava源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本例中的HelloWorld类。\n\nJava应用程序的执行入口是main()方法。它有固定的书写格式：\npublic static void main(String[] args)  &#123;...&#125;\n\n\n\nJava语言严格区分大小写。\n\nJava方法由一条条语句构成，每个语句以“;”结束。\n\n大括号都是成对出现的，缺一不可。\n\n一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。\n\n\n","slug":"J0-Java概述","date":"2021-11-04T06:41:20.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"07213b6ca5497f88ac351468e0325797","title":"Hexo 个人博客搭建","content":"Hexo 个人博客搭建安装步骤\ngithub创建yfr718.github.io项目\n\n安装git、设置用户名和邮箱、ssh连接github\ngit config --global user.name &quot;你的GitHub用户名&quot;\ngit config --global user.email &quot;你的GitHub注册邮箱&quot;\nssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;\n#打开GitHub_Settings_keys 页面，新建new SSH Key\n#Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 \nssh git@github.com\n\n\n\n安装Node.js\n# 安装后，检测Node.js是否安装成功，在命令行中输入 \nnode -v\n\n安装Hexo\n# 在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。\n# 在相应文件夹安装Hexo\nnpm install -g hexo-cli \n# 初始化博客\nhexo init blog\n# 查看博客网页\nhexo g #生成网页\nhexo s #运行网页\n# 完成后，打开浏览器输入地址：\nlocalhost:4000\n\n\nHexo 常用命令博客管理npm install hexo -g # 安装Hexo\nnpm update hexo -g # 升级\nhexo init # 初始化博客\nhexo clean # 清除缓存文件 db.json 和已生成的静态文件 public\nhexo g # 自动生成网站静态文件，并部署到设定的仓库\nhexo s # 启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;\nhexo d # 自动生成网站静态文件，并部署到设定的仓库\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d # 本地更新后重新部署到github上\n文章管理# 新建文章\nhexo new 文章文件名\n一些markdown格式\n\n\n\n\n\n提示\nNormal Tips Container\n\n\n\n\n\n\n\n\n注意\nWarning!!!\n\n\n\n\n\n\n\n\naaa\nWarning!!!\n\n\n\n\n\n\n\n\n特别注意\nDanger!!!\n\n\nClick to see more\n\n隐藏内容\n\n\n\n引用块\n\n","slug":"0.Hexo个人博客搭建","date":"2021-11-02T09:47:00.000Z","categories_index":"前端","tags_index":"hexo","author_index":"YFR718"}]