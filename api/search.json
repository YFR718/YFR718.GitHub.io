[{"id":"4457571dadddcdacb8d9147804199b90","title":"J3.输入输出","content":"标准输入输出数据读入import java.util.Scanner;\nScanner in = new Scanner(System,in);\n// 读入一行\nString name = in.nextLine();\n//读入一个单词\nString name = in.next();\n//读入一个整数\n int a = sc.nextInt();\n\n\n\n\n\n方法\n功能\n\n\n\n\nScanner (InputStream in)\n用给定的输入流创建一个Scanner对象。\n\n\nString nextLine( )\n读取输入的下一行内容。\n\n\nString next( )\n读取输入的下一个单词（以空格作为分隔符）。\n\n\nint nextInt( ) int nextInt( )\n读取并转换下一个表示整数或浮点数的字符序列。\n\n\nboolean hasNext( )\n检测输入中是否还有其他单词。\n\n\nboolean hasNextInt( )boolean hasNextDouble( )\n检测是否还有表示整数或浮点数的下一个字符序列。\n\n\nstatic Console console( )\n\n\n\n\n格式化输出System.out.print(x)\n每一个以%字符开始的格式说明符都用相应的参数替换。格式说明符尾部的转换符将指示被格式化的数值类型：\n\n\n\n\n转换符\n类型\n\n\n\n\nd\n十进制\n\n\nx\n十六进制\n\n\no\n八进制\n\n\nf\n定点浮点数\n\n\ne\n指数浮点数\n\n\ng\n通用浮点数\n\n\na\n十六进制浮点数\n\n\ns\n字符串\n\n\nc\n字符\n\n\nb\n布尔\n\n\nh\n散列码\n\n\ntx/TX\n日期时间\n\n\n%\n百分号\n\n\nn\n行分隔符\n\n\n\n\n可以使用多个标志，例如，“%, ( .2f”使用分组的分隔符并将负数括在括号内。\n\n\n\n\n标志\n目的\n\n\n\n\n+\n打印正负号\n\n\n空格\n在正整数前加空格\n\n\n0\n数字前补0\n\n\n-\n左对齐\n\n\n(\n将负数扩在括号里\n\n\n,\n添加分组分隔符\n\n\n#(对f格式)\n包含小数点\n\n\n#(对x或0格式)\n添加前缀0x\n\n\n$\n给定被格式化的参数索引。例如，%ISd. %1$x 将以十进制和十六进制格式打印第1个参数\n\n\n&lt;\n格式化前面说明的数值。例如，%d%&lt;x以十进制和十六进制打印同一个数值\n\n\n\n\n\n\n\n文件输入与输出文件读取要想对文件进行读取，就需要一个用File对象构造一个Scanner对象，如下所示：\nScanner in = new Scanner(Paths.get(\"myfile.txt\"),\"UTF-8\");\n如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠：“c:\\mydirectory\\myfile.txt”。\n文件写入要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：\nPrintWriter out = new PrintWriter(\"myfile.txt\",\"UTF-8\");\n\n\n\n\n\n\n\n\n\n\nScanner(File f)\n构造一个从给定文件读取数据的Scanner。\n\n\nScanner(String data)\n构造一个从给定字符串读取数据的Scanner。\n\n\nPrintWriter(String fileName)\nPrintWriter(String fileName)\n\n\nstatic Path get(String pathname)\n根据给定的路径名构造一个Path。\n\n\n\n\n\n\n\n","slug":"J3-输入输出","date":"2021-11-05T01:34:37.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"4ec631ba9c8264548f541e9cb0021e69","title":"2. 两数相加","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n\n\n\n\n\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.\n\n\n\n\n\n\n\n模拟\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode ans = new ListNode();\n        ListNode a = ans;\n        int t = 0;\n        while(l1 != null || l2 != null){\n            if(l1 != null) {\n                t += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null) {\n                t += l2.val;\n                l2 = l2.next;\n            }\n            a.next = new ListNode(t%10);\n            a = a.next;\n            t = t/10;\n        }\n        if(t != 0) a.next = new ListNode(t);\n        return ans.next;\n\n    }\n}\n","slug":"l0002","date":"2021-11-04T14:51:28.000Z","categories_index":"LeetCode","tags_index":"链表","author_index":"YFR718"},{"id":"15a0155fa67527b15b9ba7adec8d8cf0","title":"J2.String","content":"常用方法String s = \"123456\";\n\n\n\n\n常用方法\n功能\n示例/说明\n\n\n\n\ns.substring(x,y)\n获得字串[x,y-1]\na.substring(0,3)\n\n\ns1 + s2\n拼接字符串\ns + “789”\n\n\nString.jion(‘’,”,s1,s2,s3)\n多个字符串放在一起用分隔符\n静态方法\n\n\ns.equals(s1)\n检查两字符串是否相等\n\n\n\ns.equalsIgnoreCase(s1)\n检查两字符串是否相等，忽略大小写\n\n\n\ns.length()\n获取字符串长度\n空串：长度为0\n\n\ns.codePointCount(0，s.length();\n得到实际的长度，即码点数量\n\n\n\ns.charAt(n)\n返回位置n的代码单元\n\n\n\nint codePointAt(int index)\n返回从给定位置开始的码点。\n\n\n\nint offsetByCodePoints(int startIndex, int cpCount)\n返回从startIndex代码点开始，位移cpCount后的码点索引。\n\n\n\nint compareTo(String other)\n按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。\n\n\n\nIntStream codePoints()\n将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nboolean equalsIgnoreCase(String other)\nboolean equalsIgnoreCase(String other)\n\n\n\nboolean startsWith(String prefix)\n\n\n\n\nboolean endsWith(String suffix)\n如果字符串以suffix开头或结尾，则返回true。\n\n\n\nint index0f(String str, int fromIndex)\n返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。\n\n\n\nint lastIndex0f(String str, int fromIndex)\nint lastIndex0f(String str, int fromIndex)\n\n\n\nint codePointCount(int startIndex, int endIndex)\n返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。\n\n\n\nString replace(CharSequence oldString, CharSequence newString)\n返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。\n\n\n\nString toUpperCase( )String toUpperCase( )\n返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。\n\n\n\nString trim( )\n返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。\n\n\n\n\n\n\n\n\n\n注意事项：\n\nString没办法修改字符串，可以通过提取字串+拼接实现\n\n一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。\nif(s.substring(0,3) == \"123\") // false\n\n\nStringBuilder需要由较短的字符串构建字符串\nStringBuilder builder = new StringBuilder();\n//当每次需要添加一部分内容时，就调用append方法。\nbuilder.append(\"1\");\nbuilder.append(\"2\");\n//在需要构建字符串时就调用toString方法\nSystem.out.println(builder.toString());\n\n\n\n\n\n\n\n\n\n这个类的前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑（通常都是这样），则应该用StringBuilder替代它。这两个类的API是相同的。\nAPI\n\n\n\n\n方法\n功能\n\n\n\n\n\nStringBuilder()\n构造一个空的字符串构建器。\n\n\n\nint length()\n返回构建器或缓冲器中的代码单元数量。\n\n\n\nStringBuilder append(String str)\n追加一个字符串并返回this。\n\n\n\nStringBuilder append(char c)\n追加一个代码单元并返回this。\n\n\n\nStringBuilder appendCodePoint(int cp)\n追加一个代码点，并将其转换为一个或两个代码单元并返回this。\n\n\n\nvoid setCharAt(int i, char c)\n将第i个代码单元设置为c。\n\n\n\nStringBuilder insert(int offset, String str)\n在offset位置插入一个字符串并返回this。\n\n\n\nStringBuilder insert(int offset, Char c)\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n\n","slug":"J2-String","date":"2021-11-04T14:38:01.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"2a28fcbe1a17ab37c1c849fd02eb2771","title":"1. 两数之和","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n\n\n\n\n\n\n\n\n\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n\n\n\n\n\n暴力解法\n双重for循环\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0;i&lt;nums.length;i++) { \n            for(int j = i+1;j&lt;nums.length;j++) {\n                if(nums[i] + nums[j] == target) {\n                    return new int[] {i,j};\n                }\n            }\n        }\n        return new int[] {0};\n    }\n}\n\n\n\n\n\n\n\n 哈希表\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; hashTable = new HashMap&lt;Integer, Integer&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            if(hashTable.containsKey(target - nums[i])) {\n                return new int[]{hashTable.get(target - nums[i]),i};\n            }\n            hashTable.put(nums[i],i);\n        }\n        return new int[] {0};\n\n    }\n}\n# Python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            r = target-nums[i]\n            if r in d:\n                return [d[r],i]\n            else:\n                d[nums[i]]=i\n","slug":"l0001","date":"2021-11-04T12:06:25.000Z","categories_index":"LeetCode","tags_index":"哈希","author_index":"YFR718"},{"id":"234a650b9f919d31820f31482789a1da","title":"基本数据类型","content":"基本数据类型整数\n\n\n\n类型\n存储需求\n取值范围\n例\n\n\n\n\nint\n4字节\n（21亿）\n10\n\n\nshort\n2字节\n（32768）\n\n\n\nlong\n8字节\n\n10L\n\n\nbyte\n1字节\n（128）\n\n\n\n\n浮点数\n\n\n\n类型\n存储需求\n符号位\n指数位\n尾数位\n例\n\n\n\n\nfloat\n4字节\n1\n8\n23\n3.14F\n\n\ndouble\n8字节\n1\n11\n52\n3.14\n\n\n\n\n更详细\nchar类型\n\n\n\n类型\n存储需求\n\n\n\n\n\nchar\n2字节\n1\n\n\n\n\nchar类型的字面量值要用单引号括起来。例如：’A’.\n在Java中，char类型描述了UTF-16编码中的一个代码单元。对char类型字符运行时，直接当做ASCII表对应的整数来对待。\nUnicode 编码:一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。\nUnicode 的缺点：Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别 Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。\nUTF-8:一种变长的编码方式。它可以使用 1-6 个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则：1）对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。2）对于多字节的UTF-8编码，如果编码包含 n 个字节，那么第一个字节的前 n 位为1，第一个字节的第 n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。\nboolean\n\n\n\n类型\n存储需求\n\n\n\n\n\nboolean\n1位\ntrue/flase\n\n\n\n\n变量变量的声明与使用标识符：Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符定义合法标识符规则：\n\n由26个英文字母大小写，0-9 ，_或$ 组成\n数字不可以开头。\n不可以使用关键字和保留字，但能包含关键字和保留字。\nJava中严格区分大小写，长度无限制。\n标识符不能包含空格。\n\n变量的概念：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。变量的作用：用于在内存中保存数据\n使用变量注意：\n\nJava中每个变量必须先声明，后使用\n使用变量名来访问这块区域的数据\n变量的作用域：其定义所在的一对{ }内\n变量只有在其作用域内才有效\n同一个作用域内，不能定义重名的变量\n\n声明变量\n\n语法：&lt;数据类型&gt; &lt;变量名称&gt;;\n\n例如：int var;\n\n\n变量的赋值\n\n语法：&lt;变量名称&gt; =  &lt;值&gt;\n例如：var = 10;\n\n声明和赋值变量\n\n语法： &lt;数据类型&gt; &lt;变量名&gt; =  &lt;初始化值&gt;\n例如：int var = 10;\n\n变量的分类-按数据类型\n\n变量的分类-按声明的位置\n\n在方法体外，类体内声明的变量称为成员变量。\n在方法体内部声明的变量称为局部变量。\n\n\n常量在Java中，利用关键字final指示常量。\nfinal int A = 1000;\n数值类型之间的转换自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：\n\n\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\nbyte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。\nboolean类型不能与其它数据类型运算。\n当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。\n\nString str1 = 4; //判断对错: no\nString str2= 3.5f + \"\"; //判断str2对错: yes\nSystem.out.printIn(str2); //输出:”3.5”\nSystem.out .println(3+4+\"Hello!\"); //输出:7Hello!\nSystem.out.println(\"Hello!\" +3+4); //输出: Hello!34\nSystem.out.printIn('a'+ 1+\"Hello!\"); //输 出: 98Hello!\nSystem.out.printIn(\"Hello\"+'a'+1); //输出: Helloa1\n强制类型转换：将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。\n通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n// 判断是否能通过编译\nshort s = 5;\ns = s - 2; //报错：int 不能用short存储\ns = (short) (s - 2); //正确写法\n\nbyte b = 3;\nb = b + 4; //报错：int 不能用byte存储\nb = (byte) (b + 4); //正确写法\n\nchar a = 'a';\nint i = 5;\nfloat d = .314F;\ndouble result = a + i + d; //正确\n\nbyte b = 5;\nshort s = 3;\nshort t = s + b; //报错：int 不能用short存储\n进制与运算符\n\n\n\n进制\n\n\n\n\n\n\n二进制 (binary)\n0,1\n满2进1.以0b或0B开头\n\n\n十进制 (decimal)\n0-9\n满10进1\n\n\n八进制 (octal)：\n0-7\n满8进1. 以数字0开头表示\n\n\n十六进制 (hex) (hex)(hex)(hex)：\n0-9，A-F\n满16进1. 以0x或0X开头表示\n\n\n\n\n进制的基本转换    十进制 二进制互转       二进制转成十进制 乘以2的幂数       十进制转成二进制 除以2取余数    二进制 八进制互转    二进制 十六进制互转    十进制八进制互转    十进制十六进制互转\n\n\n\n\n运算符\n运算\n\n\n\n\n算术运算符\n+-*/%++–\n\n\n赋值运算符\n=,+=, -=, *=, /=, %=\n\n\n比较运算符（关系运算符）\n==,!=,&lt;,&gt;,&lt;=,&gt;=,instanceof\n\n\n逻辑运算符\n&amp;,\\\n,!,&amp;&amp;,\\\n\\\n,^\n\n\n位运算符\n&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,\\\n,^,~\n\n\n三元运算符\n(条件表达式)?表达式1：表达式2；\n\n\n\n\n\n\n\n\n\n位运算符的细节\n\n\n\n\n&lt;&lt;\n空位补0，被移除的高位丢弃，空缺位补0。\n\n\n&gt;&gt;\n被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。\n\n\n&gt;&gt;&gt;\n被移位二进制最高位无论是0或者是1，空缺位都用0补。\n\n\n&amp;\n二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;\n\n\n\\\n\n二进制位进行 \\\n运算，只有0 \\\n0时结果是0，否则是1;\n\n\n^\n相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1\n\n\n~\n正数取反，各二进制码按补码各位取反负数取反，各二进制码按补码各位取反\n\n\n\n\n运算优先级：\n思考1：\nshort s = 3; \ns = s+2;//s1+2运算结果是int型，需要强制转换类型   \n① s += 2;    //+= 不改变原本的数据类型\n\n思考2：\nint i = 1;\ni *= 0.1;  //*= 不改变原本的数据类型\nSystem.out.println(i);\ni++;\nSystem.out.println(i);\n\n思考3：\nint m = 2;\nint n = 3;\nn *= m++; \nSystem.out.println(\"m=\" + m); System.out.println(\"n=\" + n); 3，6\n    \n思考4：\nint n = 10;\nn += (n++) + (++n); //10 + 10 + 12\nSystem.out.println(n);\n“&amp;”和“&amp;&amp;”的区别：“|”和“||”的区别同理    单&amp;时，左边无论真假，右边都进行运算；    双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。\nint x = 1,y = 1;\nif(x++==2 &amp; ++y==2){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，2\nint x = 1,y = 1;\nif(x++==2 &amp;&amp; ++y==2){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，1\nint x = 1,y = 1;\nif(x++==1 | ++y==1){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，2\n\nint x = 1,y = 1;\nif(x++==1 || ++y==1){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，1\n\nclass Test {\n    public static void main (String [] args) {\n        boolean x=true;\n        boolean y=false;\n        short z=42;\n        //if(y == true)\n        if((z++==42)&amp;&amp;(y=true))z++;\n        if((x=false) || (++z==45)) z++;\n        System.out.println(\"z=\"+z);\n    }\n}\n// z=46\n","slug":"J1-数据类型","date":"2021-11-04T09:50:09.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"2646898c8ef5a9766cbd5f124442ee5c","title":"Java概述","content":"Java概述是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。\nJava语言特性\n特点一：面向对象\n两个基本概念：类、对象\n三大特性：封装、继承、多态\n\n特点二：健壮性\n吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制\n\n特点三：跨平台性\n跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”\n原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。\n因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。\n\n\n核心机制—Java虚拟机\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n对于不同的平台，有不同的虚拟机。\n只有某平台提供了对应的java虚拟机，java程序才可在此平台运行\nJava虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”\n\n核心机制—垃圾回收​        不再使用的内存空间应回收——垃圾回收。在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。\n\n\n\n\nJava语言的环境\n功能\n包含\n\n\n\n\nJDK(Java Development Kit    Java开发工具包)\nJDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。\nJRE + 开发工具集（编译工具javac.exe 打包工具jar.exe)\n\n\nJRE(Java Runtime Environment    Java运行环境)\n包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\nJVM + Java SE标准类库\n\n\nJVM (Java Virtal Machine Java虚拟机）\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n\n\n\n\nHello Java​        我们来编写第一个简单的Java程序：\npublic class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\npublic称为访问修饰符（accessmodifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。\nclass表明Java程序中的全部内容都包含在类中。\nHelloJava：类名。\nstatic：静态方法。\nvoid：无参数返回。\nmain：主方法，程序的入口。\nString[]：程序执行的参数。\nargs：参数名。\nSystem.out.println()：输出一行语句。\n\nJava运行步骤：\n将 Java 代码编写到扩展名为 .java 的文件中。\n通过 javac 命令对该 java 文件进行编译。\n通过 java 命令对生成的 class 文件进行运行。\n\nC:\\Users\\24378\\Desktop\\Java>javac f1.java\nC:\\Users\\24378\\Desktop\\Java>java f1\nhello Java\n一些规范Java命名规范\n\n\n\n类型(名)\n约束\n列\n\n\n\n\n项目\n全部小写，画线-分隔\nspring-cloud\n\n\n包\n全部小写\ncom.yfr.softmax\n\n\n类\n单次首字母大写\nNewWorld\n\n\n变量/方法\n首字母小写\nuserName\n\n\n常量\n全部大写，下划线_分隔\nINT_MAX\n\n\n\n\nJava代码编写规范public class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\n注意大括号的风格\n二元三元运算符两边用一个空格隔开\n逗号语句后如不换行，紧跟一个空格\n将类似操作，或一组操作放在一起不用空行隔开，而用空行隔开不同组的代码\n每个if while for等语句，都不要省略大括号{}\n\nJava注释\n\n\n\n注释类型\n\n\n\n\n\n\n单行注释\n//注释文字\n\n\n\n多行注释\n/  注释文字 /\n\n\n\n文档注释：\n/*@author  指定java程序的作者@version  指定源文件的版本/\n\n\n\n\n# 生成注释文档\nPS C:\\Users\\24378\\Desktop\\Java&gt; javadoc -d mydoc -author -version .\\f1.java\n正在加载源文件.\\f1.java...\n正在构造 Javadoc 信息...\n...\nJava注意事项\nJava源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本例中的HelloWorld类。\n\nJava应用程序的执行入口是main()方法。它有固定的书写格式：\npublic static void main(String[] args)  &#123;...&#125;\n\n\n\nJava语言严格区分大小写。\n\nJava方法由一条条语句构成，每个语句以“;”结束。\n\n大括号都是成对出现的，缺一不可。\n\n一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。\n\n\n","slug":"J0-Java概述","date":"2021-11-04T06:41:20.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"71dcb878b30b2fb16e5265f7515744d5","title":"疑难杂症队列","content":"Java\n整理笔记，等待发布\n尚硅谷整理的Java学习\n\nLinux\n笔记整理，待发布\nshell编程笔记整理，待发布\n\n算法\nleetcode每日三道题\nACwing课程学习\n\n","slug":"1-疑难杂症队列","date":"2021-11-04T05:27:30.000Z","categories_index":"学习规划","tags_index":"","author_index":"YFR718"},{"id":"07213b6ca5497f88ac351468e0325797","title":"Hexo 个人博客搭建","content":"Hexo 个人博客搭建安装步骤\ngithub创建yfr718.github.io项目\n\n安装git、设置用户名和邮箱、ssh连接github\ngit config --global user.name &quot;你的GitHub用户名&quot;\ngit config --global user.email &quot;你的GitHub注册邮箱&quot;\nssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;\n#打开GitHub_Settings_keys 页面，新建new SSH Key\n#Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 \nssh git@github.com\n\n\n\n安装Node.js\n# 安装后，检测Node.js是否安装成功，在命令行中输入 \nnode -v\n\n安装Hexo\n# 在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。\n# 在相应文件夹安装Hexo\nnpm install -g hexo-cli \n# 初始化博客\nhexo init blog\n# 查看博客网页\nhexo g #生成网页\nhexo s #运行网页\n# 完成后，打开浏览器输入地址：\nlocalhost:4000\n\n\nHexo 常用命令博客管理npm install hexo -g # 安装Hexo\nnpm update hexo -g # 升级\nhexo init # 初始化博客\nhexo clean # 清除缓存文件 db.json 和已生成的静态文件 public\nhexo g # 自动生成网站静态文件，并部署到设定的仓库\nhexo s # 启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;\nhexo d # 自动生成网站静态文件，并部署到设定的仓库\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d # 本地更新后重新部署到github上\n文章管理# 新建文章\nhexo new 文章文件名\n一些markdown格式\n\n\n\n\n\n提示\nNormal Tips Container\n\n\n\n\n\n\n\n\n注意\nWarning!!!\n\n\n\n\n\n\n\n\naaa\nWarning!!!\n\n\n\n\n\n\n\n\n特别注意\nDanger!!!\n\n\nClick to see more\n\n隐藏内容\n\n\n\n引用块\n\n","slug":"0.Hexo个人博客搭建","date":"2021-11-02T09:47:00.000Z","categories_index":"前端","tags_index":"hexo","author_index":"YFR718"}]