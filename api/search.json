[{"id":"31135c47a98e6bfd7ef6f55be399b5e8","title":"PyMySQL","content":"","slug":"PyMySQL","date":"2021-11-10T02:06:01.000Z","categories_index":"Python","tags_index":"MySQL","author_index":"YFR718"},{"id":"a3f5b417ccee185425acbc3a549133c3","title":"LeetCode做题记录","content":"刷题汇总\n\n\n\n题号\n题目\n算法\n最优解\n时间复杂度\n\n\n\n\n1\n两数之和\n哈希\n:green_heart:\n$$\n\n\n2\n两数相加\n模拟\n:green_heart:\n\n\n\n3\n无重复字符的最长子串\n\n\n\n\n\n4\n\n\n\n\n\n\n5\n\n\n\n\n\n\n6\n\n\n\n\n\n\n7\n\n\n\n\n\n\n8\n\n\n\n\n\n\n9\n\n\n\n\n\n\n10\n\n\n\n\n\n\n11\n\n\n\n\n\n\n12\n\n\n\n\n\n\n13\n\n\n\n\n\n\n14\n\n\n\n\n\n\n15\n\n\n\n\n\n\n16\n\n\n\n\n\n\n17\n\n\n\n\n\n\n18\n\n\n\n\n\n\n19\n\n\n\n\n\n\n20\n\n\n\n\n\n\n21\n\n\n\n\n\n\n22\n\n\n\n\n\n\n23\n\n\n\n\n\n\n24\n\n\n\n\n\n\n25\n\n\n\n\n\n\n26\n\n\n\n\n\n\n27\n\n\n\n\n\n\n28\n\n\n\n\n\n\n29\n\n\n\n\n\n\n30\n\n\n\n\n\n\n31\n\n\n\n\n\n\n32\n\n\n\n\n\n\n33\n\n\n\n\n\n\n34\n\n\n\n\n\n\n35\n\n\n\n\n\n\n36\n\n\n\n\n\n\n37\n\n\n\n\n\n\n38\n\n\n\n\n\n\n39\n\n\n\n\n\n\n40\n\n\n\n\n\n\n41\n\n\n\n\n\n\n42\n\n\n\n\n\n\n43\n\n\n\n\n\n\n44\n\n\n\n\n\n\n45\n\n\n\n\n\n\n46\n\n\n\n\n\n\n47\n\n\n\n\n\n\n48\n\n\n\n\n\n\n49\n\n\n\n\n\n\n50\n\n\n\n\n\n\n51\n\n\n\n\n\n\n52\n\n\n\n\n\n\n53\n\n\n\n\n\n\n54\n\n\n\n\n\n\n55\n\n\n\n\n\n\n56\n\n\n\n\n\n\n57\n\n\n\n\n\n\n58\n\n\n\n\n\n\n59\n\n\n\n\n\n\n60\n\n\n\n\n\n\n61\n\n\n\n\n\n\n62\n\n\n\n\n\n\n63\n\n\n\n\n\n\n64\n\n\n\n\n\n\n65\n\n\n\n\n\n\n66\n\n\n\n\n\n\n67\n\n\n\n\n\n\n68\n\n\n\n\n\n\n69\n\n\n\n\n\n\n70\n\n\n\n\n\n\n71\n\n\n\n\n\n\n72\n\n\n\n\n\n\n73\n\n\n\n\n\n\n74\n\n\n\n\n\n\n75\n\n\n\n\n\n\n76\n\n\n\n\n\n\n77\n\n\n\n\n\n\n78\n\n\n\n\n\n\n79\n\n\n\n\n\n\n80\n\n\n\n\n\n\n81\n\n\n\n\n\n\n82\n\n\n\n\n\n\n83\n\n\n\n\n\n\n84\n\n\n\n\n\n\n85\n\n\n\n\n\n\n86\n\n\n\n\n\n\n87\n\n\n\n\n\n\n88\n\n\n\n\n\n\n89\n\n\n\n\n\n\n90\n\n\n\n\n\n\n91\n\n\n\n\n\n\n92\n\n\n\n\n\n\n93\n\n\n\n\n\n\n94\n\n\n\n\n\n\n95\n\n\n\n\n\n\n96\n\n\n\n\n\n\n97\n\n\n\n\n\n\n98\n\n\n\n\n\n\n\n算法分类对应题目分类","slug":"l0000","date":"2021-11-05T13:51:29.000Z","categories_index":"LeetCode","tags_index":"","author_index":"YFR718"},{"id":"71dcb878b30b2fb16e5265f7515744d5","title":"疑难杂症队列","content":"Java\n整理笔记，等待发布\n尚硅谷整理的Java学习\n书5.7跳过\n\nLinux\n笔记整理，待发布\nshell编程笔记整理，待发布\n\n算法\nleetcode每日三道题\nACwing课程学习\n\nHadoop\nP88 job提交源码\nP89 切片源码\nP97 、98自定义分区\nP100~102\nP104 Combiner\nP107 OutPutFormat\nP101 源码解析\n\n\n","slug":"1-疑难杂症队列","date":"2021-11-04T05:27:30.000Z","categories_index":"学习规划","tags_index":"","author_index":"YFR718"},{"id":"446bbf5d6e6c49aba6d56562199f8a0a","title":"XML解析","content":"1 xml.etree.ElementTree对Python的轻量级XML支持。\nXML是一种固有的分层数据格式，最自然的表示方法是使用树。这个模块有两个类用于此目的:\n\nElementTree将整个XML文档表示为树。\n元素表示此树中的单个节点。\n\n​        与整个文档的交互(对文件的读写)通常在ElementTree级别完成。与单个XML元素及其子元素的交互是在element级别上完成的。\n​        元素是一种灵活的容器对象，用于在内存中存储分层数据结构。它可以被描述为介于列表和字典之间的混合体。每个元素都有许多与之相关的属性:\n\n‘tag’——包含元素名称的字符串。\n‘attributes’——一个存储元素属性的Python字典。\n‘text’ -一个包含元素文本内容的字符串。\n‘tail’ -一个可选字符串，在元素的结束标签之后包含文本。以及一系列存储在Python序列中的子元素。\n\n​        要创建元素实例，请使用element构造函数或SubElement工厂函数。还可以使用ElementTree类包装元素结构，并将其与XML进行转换。\n1.1 导入数据从xml文件导入\nimport xml.etree.ElementTree as ET\ntree = ET.parse('country_data.xml')\nroot = tree.getroot()\n从html导入\nimport xml.etree.ElementTree as ET\n# 要爬取的地址\nurl = \"https://www.re3data.org/api/v1/repositories\"\nres = requests.get(url)\nroot = ET.fromstring(res.text)\n1.2 数据查询1.2.1 获取四个属性print(root.tag)\nprint(root.attrib)\nprint(root.tail)\nprint(res.text)\n1.2.2 访问子节点用 len(Element) 检查子节点个数\n用 Element[0] 访问第0个子节点，Element[1] 访问第1个子节点…\n用 for child in Element 遍历所有子节点\n用 Element.remove(child) 删除某个子节点\nfor i in root:\n    print(i.tag)\n1.2.3 查询指定标签\nElementt.iter() #递归迭代xml文件中所有节点（包含子节点，以及子节点的子节点），返回一个包含所有节点的迭代器\nElement.find(tag) #查找第一个节点为tag的直接子元素，返回一个节点对象\nElement.findall(tag) #查找节点为tag的所有直接子元素’，返回一个节点列表直接子元素的意思：只会查找当前节点的子节点那一级目录\n\nfor rep in root.findall('repository'):\n    # print(rep.find('id').text)\n    # print(rep.find('name').text)\n    print(rep.find('link').attrib['href'],rep.find('link').attrib['rel'])\n处理含namespace的文件\nnamespace = \"{http://www.re3data.org/schema/2-2}\"\nfor element in root.iter(namespace + \"re3data.orgIdentifier\"):  # ID\n    print(\"1#   \", element.text)\n    ID = element.text\n1.2.4 树结构与 XML 字符串的相互转换使用 xml.etree.ElementTree 包中的 tostring() 和 fromstring() 函数：\n\n如果 tostring() 参数不指定 encoding=\"unicode\"，函数将返回 byte 序列。\n\nfrom xml.etree.ElementTree import Element, tostring\n\ntree_str = tostring(root, encoding=\"unicode\")\n\nnew_root = fromstring(tree_str)\nprint(new_root.tag, new_root[0].tag, new_root[1].tag)\n1.3 数据创建1.3.1 创建树节点创建树节点时，一定要指定节点名：\ntree_node = Element(\"node1\")\nprint(tree_node.tag)    # 输出 node1\nprint(tree_node.text)   # 输出 None\nprint(tree_node.tail)   # 输出 None\nprint(tree_node.attrib) # 输出 {}\n也可在创建时指定属性（Element.attrib）：\ntree_node = Element(\"node2\", {\"attr1\": 1, \"attr2\": 2})\nprint(tree_node.tag)    # 输出 node2\nprint(tree_node.text)   # 输出 None\nprint(tree_node.tail)   # 输出 None\nprint(tree_node.attrib) # 输出 {'attr1': 1, 'attr2': 2}\n1.3.2 设置文本（Element.text）或附加文本（Element.tail）创建节点后，可以设置 text, tail 等类成员。这些成员的初始值为 None。\ntree_node = Element(\"node1\")\ntree_node.text = \"Hello world\"\ntree_node.tail = \"Bye\"\n1.3.3 添加子节点可以用 Element.append() 成员函数添加子节点：\nroot = Element(\"root\")\nchild1 = Element(\"child1\")\nchild2 = Element(\"child2\")\n\nroot.append(child1)\nroot.append(child2)\n","slug":"P0-XML解析","date":"2021-11-10T01:23:54.000Z","categories_index":"Python","tags_index":"XML","author_index":"YFR718"},{"id":"0e809b380a45c732473fb3fa1636bd4c","title":"ASCII码","content":"ASCII码表格：\n\n\n\n\nASCII值\n控制字符\nASCII值\n字符\nASCII值\n字符\nASCII值\n字符\n\n\n\n\n0\nNUT\n32\n(space)\n64\n@\n96\n、\n\n\n1\nSOH\n33\n!\n65\nA\n97\na\n\n\n2\nSTX\n34\n“\n66\nB\n98\nb\n\n\n3\nETX\n35\n#\n67\nC\n99\nc\n\n\n4\nEOT\n36\n$\n68\nD\n100\nd\n\n\n5\nENQ\n37\n%\n69\nE\n101\ne\n\n\n6\nACK\n38\n&amp;\n70\nF\n102\nf\n\n\n7\nBEL\n39\n,\n71\nG\n103\ng\n\n\n8\nBS\n40\n(\n72\nH\n104\nh\n\n\n9\nHT\n41\n)\n73\nI\n105\ni\n\n\n10\nLF\n42\n*\n74\nJ\n106\nj\n\n\n11\nVT\n43\n+\n75\nK\n107\nk\n\n\n12\nFF\n44\n,\n76\nL\n108\nl\n\n\n13\nCR\n45\n-\n77\nM\n109\nm\n\n\n14\nSO\n46\n.\n78\nN\n110\nn\n\n\n15\nSI\n47\n/\n79\nO\n111\no\n\n\n16\nDLE\n48\n0\n80\nP\n112\np\n\n\n17\nDCI\n49\n1\n81\nQ\n113\nq\n\n\n18\nDC2\n50\n2\n82\nR\n114\nr\n\n\n19\nDC3\n51\n3\n83\nS\n115\ns\n\n\n20\nDC4\n52\n4\n84\nT\n116\nt\n\n\n21\nNAK\n53\n5\n85\nU\n117\nu\n\n\n22\nSYN\n54\n6\n86\nV\n118\nv\n\n\n23\nTB\n55\n7\n87\nW\n119\nw\n\n\n24\nCAN\n56\n8\n88\nX\n120\nx\n\n\n25\nEM\n57\n9\n89\nY\n121\ny\n\n\n26\nSUB\n58\n:\n90\nZ\n122\nz\n\n\n27\nESC\n59\n;\n91\n[\n123\n{\n\n\n28\nFS\n60\n&lt;\n92\n/\n124\n\\\n\n\n\n29\nGS\n61\n=\n93\n]\n125\n}\n\n\n30\nRS\n62\n&gt;\n94\n^\n126\n`\n\n\n31\nUS\n63\n?\n95\n_\n127\nDEL\n\n\n\n\nASCII 码大致由以下两部分组成：\n\nASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。\nASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。\n\n","slug":"0-计算机基础","date":"2021-11-06T11:52:59.000Z","categories_index":"计算机基础","tags_index":"","author_index":"YFR718"},{"id":"fa82b363c947b237a81a51347767262e","title":"4. 寻找两个正序数组的中位数","content":"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n\n\n\n\n\n\n\n\n\n输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2\n\n\n\n\n\n\n\nsort\n将两数组合在一起，排序后直接输出中位数。\n\n\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int l1 = nums1.length, l2 = nums2.length;\n        int[] nums = new int[l1+l2];\n        for(int i = 0;i &lt; l1; i++) {\n            nums[i] = nums1[i];\n        }\n        for(int i = 0; i &lt; l2; i++) {\n            nums[l1+i] = nums2[i];\n        }\n        Arrays.sort(nums);\n\n        if((l1 + l2) % 2 == 1) {\n            return (double)nums[(l1 + l2) / 2];\n        }else{\n            return (double)(nums[(l1 + l2) / 2]+nums[(l1 + l2) / 2 - 1]) / 2.0;\n        }\n    }\n}\n\n\n\n\n\n\n\n 递归\n🚹\n\n\n:heart\n","slug":"l0004","date":"2021-11-05T12:34:37.000Z","categories_index":"LeetCode","tags_index":"双指针","author_index":"YFR718"},{"id":"02ad4c9c8b4647bd8676742f0e73d72a","title":"3. 无重复字符的最长子串","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n\n\n\n\n\n\n\n\n输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n\n\n\n\n\n\n双指针 \n\n设置左指针初值-1，右指针初值0，int数组对区间(l,r]出现过的字母计数\nfor循环对右指针指向的字母计数\n如果计数&lt;=1,更新答案\n如果计数&gt;1,左指针向右移，直到计数=1\n\n\n\n// 数组计数\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int a[] = new int[1000];\n        int l = -1, r = 0;\n        int maxl = 0;\n        for(r = 0; r&lt; s.length();r++){\n            a[(int)s.charAt(r)]+=1;     // 计数\n            if(a[(int)s.charAt(r)]&lt;=1){ // 不重复更新答案\n                maxl = maxl&gt; (r-l) ? maxl: r-l; \n            }else{                      //重复左指针向右移，直到不重复\n                while(a[(int)s.charAt(r)]&gt;1){\n                    l+=1;\n                    a[(int)s.charAt(l)]-=1;\n                }\n            }\n        }\n        return maxl;\n    }\n    \n}\n// 哈希集合\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set&lt;Character&gt; occ = new HashSet&lt;Character&gt;();\n        int len = s.length();\n        int l = -1, r = 0;\n        int maxl = 0;\n        for(r = 0; r&lt; s.length();r++){\n            while(occ.contains(s.charAt(r))) {\n                occ.remove(s.charAt(++l));\n            }\n            occ.add(s.charAt(r));\n            maxl = Math.max(maxl,r-l);\n        }\n        return maxl;\n    }\n    \n}\n","slug":"l0003","date":"2021-11-05T12:09:37.000Z","categories_index":"LeetCode","tags_index":"双指针","author_index":"YFR718"},{"id":"f8534e8f12d0bc66698739d3b7153c65","title":"J5.对象与类","content":"面向对象编程OOP类(Class)和对象(Object)是面向对象的核心概念。\n\n类是对一类事物的描述，是抽象的、概念上的定义\n对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。\n属 性：对应类中的成员变量\n行 为：对应类中的成员方法\n由类构造（construct）对象的过程称为创建类的实例（instance）。\n\n创建Java自定义类\n\n定义类（考虑修饰符、类名）\n编写类的属性（考虑修饰符、属性类型、属性名、初始化值）\n编写类的方法（考虑修饰符、返回值类型、方法名、形参等）\n\n对象的创建和使用\n创建对象语法： 类名 对象名 = new 类名();使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）\n属性修饰符 数据类型 属性名 = 初始化值 ; \n\n修饰符：常用的权限修饰符有：private、缺省、protected、public，其他修饰符：static、final (暂不考虑)\n数据类型：任何基本数据类型(如int、Boolean) 或 任何引用数据类型。\n属性名：属于标识符，符合命名规则和规范即可。\n\n变量的分类：成员变量与局部变量\n\n\n\n\n\n\n成员变量\n局部变量\n\n\n\n\n声明的位置\n直接声明在类中\n方法形参或内部、代码块内、构造器内等\n\n\n修饰符\nprivate、public、static、final等\n不能用权限修饰符修饰，可以用final修饰\n\n\n初始化值\n有默认初始化值\n没有默认初始化值，必须显式赋值，方可使用\n\n\n内存加载位置\n堆空间 或 静态域内\n栈空间\n\n\n\n\n方法\n方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。\n将功能封装为方法的目的是，可以实现代码重用，简化代码\nJava里的方法不能独立存在，所有的方法必须定义在类里。\n\n// 方法的声明格式：\n修饰符  返回值类型  方法名（参数类型形参1, 参数类型形参2, ….）｛\n    方法体程序代码\n    return 返回值;\n}\n修饰符：public,缺省,private, protected等返回值类型：\n返回值类型：没有返回值：void，有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用\n方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” \n形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开返回值：方法在执行完毕后返还给调用它的程序的数据。\nmain方法\n\n\n\nmain方法\n\n\n\n\n\npublic\n由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n\nstatic\n因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的\n\n\nString[] args\n该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数\n\n\n\n\n代码块代码块(或初始化块)的作用： 对Java类或对象进行初始化代码块(或初始化块)的分类：一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。\n// static代码块通常用于初始化static的属性\nclass Person {\n    public static int total; \n    static {\n        total = 100;//为total赋初值\n    }\n}\n\n静态代码块：用static 修饰的代码块\n\n\n可以有输出语句。\n可以对类的属性、类的声明进行初始化操作。\n不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。\n若有多个静态的代码块，那么按照从上到下的顺序依次执行。\n静态代码块的执行要先于非静态代码块。\n静态代码块随着类的加载而加载，且只执行一次。\n\n\n非静态代码块：没有static修饰的代码块\n\n\n可以有输出语句。\n可以对类的属性、类的声明进行初始化操作。\n除了调用非静态的结构外，还可以调用静态的变量或方法。\n若有多个非静态的代码块，那么按照从上到下的顺序依次执行。\n每次创建对象的时候，都会执行一次。且先于构造器执行。\n\n⭐程序中成员变量赋值的执行顺序\n\n声明成员变量的默认初始化\n显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）\n构造器再对成员进行初始化操作\n通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值\n\n重载 overload在同一个类中，允许存在一个以上的==同名方法==，只要它们的==参数个数或者参数类型==不同即可。\n==与返回值类型无关==，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。\n//返回两个整数的和\nint add(int x,int y){return x+y;}\n//返回三个整数的和\nint add(int x,int y,int z){return x+y+z;} \n//返回两个小数的和\ndouble add(double x,double y){return x+y;}\n可变个数的形参public static void test(int a ,String…books);\n\n可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个\n可变个数形参的方法与同名的方法之间，彼此构成重载\n可变参数方法的使用与方法参数部分使用数组是一致的\n方法的参数部分有可变形参，需要放在形参声明的最后\n在一个方法的形参位置，最多只能声明一个可变个数形参\n\n方法参数的值传递机制    形参：方法声明时的参数    实参：方法调用时实际传给形参的参数值\nJava里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。\n    形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参    形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参\nint[] arr = new int[10];\nSystem.out.println(arr);//地址值\nchar[] arr1 = new char[10]; System.out.println(arr1); //内容\n//源码解析\npublic void println(Object x) {\n    String s = String.valueOf(x);\n    synchronized (this) {\n        print(s);\n        newLine();\n    }\n}\npublic void println(char x[]) {\n    synchronized (this) {\n        print(x);\n        newLine();\n    }\n}\n构造器 (或构造方法)构造器的特征\n\n它具有与类相同的名称\n它不声明返回值类型。（与声明为void不同）\n不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值\n\n构造器的作用：创建对象；给对象进行初始化\n\n如：Order o = new Order();    Person p = new Person(“Peter”,15);\n如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。\n\n// 语法格式：\n修饰符 类名 (参数列表) {\n    初始化语句;\n}\n根据参数不同，构造器可以分为如下两类：    隐式无参构造器（系统默认提供）    显式定义一个或多个构造器（无参、有参）注 意：    Java语言中，每个类都至少有一个构造器    默认构造器的修饰符与所属类的修饰符一致    一旦显式定义了构造器，则系统不再提供默认构造器    一个类可以创建多个重载的构造器    父类的构造器不可被子类继承\n构造器重载\n构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。\n// 构造器重载举例：\npublic class Person{\n    public Person(String name, int age, Date d) {this(name,age);…} \n    public Person(String name, int age) {…}\n    public Person(String name, Date d) {…}\n    public Person(){…}\n}\n关键字—this    它在方法内部使用，即这个方法所属对象的引用；    它在构造器内部使用，表示该构造器正在初始化的对象。\nthis 可以调用类的属性、方法和构造器\n什么时候使用this关键字呢？    当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。比如：this.name = name;\n⭐this可以作为一个类中构造器相互调用的特殊格式\nclass Person{\n    //定义Person类\n    private String name ;\n    private int age ;\n    public Person(){\n        //无参构造器\n        System.out.println(\"新对象实例化\");\n    }\n    public Person(String name ){\n        this(); //调用本类中的无参构造器\n        this.name = name ;\n    }\n    public Person(String name,int age){\n        this(name); // 调用有一个参数的构造器\n        this.age = age;\n    }\n    public String getInfo(){\n    return \"姓名: \"+name+\"，年龄:\"+age;\n    }\n}\n\n    可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！    明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器    如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”    “this(形参列表)”必须声明在类的构造器的首行！    在类的一个构造器中，最多只能声明一个”this(形参列表)”\n封装与隐藏    高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；    低耦合 ：仅对外暴露少量的方法用于使用。\n隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。\nJava中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：\n    隐藏一个类中不需要对外提供的实现细节；    使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；    便于修改，增强代码的可维护性；\n\n\n\n\n修饰符\n类内部\n同一个包\n不同包的子类\n同一个工程\n\n\n\n\nprivate\n√\n\n\n\n\n\n(缺省)\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\n\n\n包(package)的管理与作用package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：package 顶层包名.子包名 ;\n//举例：pack1\\pack2\\PackageTest.java\npackage pack1.pack2;    //指定类PackageTest属于包pack1.pack2 \n\npublic class PackageTest{\n    public void display(){\n        System.out.println(\"in  method display()\");\n    }\n}\n    包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次；    包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx\n包的作用：\n    包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式    包可以包含类和子包，划分项目层次，便于管理    解决类命名冲突的问题    控制访问权限\n\n\n\n\n\nJDK中主要的包介绍\n\n\n\n\njava.lang\n包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能\n\n\njava.net\n包含执行与网络相关的操作的类和接口\n\n\njava.io\n包含能提供多种输入/输出功能的类\n\n\njava.util\n包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数\n\n\njava.text\n包含了一些java格式化相关的类\n\n\njava.sql\n包含了java进行JDBC数据库编程的相关类/接口\n\n\njava.awt\n包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)\n\n\n\n\n\n","slug":"J6-对象与类","date":"2021-11-05T06:23:36.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"Java数组数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组的常见概念\n\n数组名\n下标(或索引)\n元素\n数组的长度\n\n一维数组的创建与使用// 一维数组的声明方式：\ntype var[] 或 type[]  var;\n//Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： \nint a[5];  //非法\n//动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行\nint[] arr = new int[3];\nString names[]; names = new String[3];\n//静态初始化：在定义数组的同时就为数组元素分配空间并赋值。\nint arr[] = new int[]{ 3, 9, 8};\nint[] arr = {3,9,8};\n// 属性length\na.length 指明数组a的长度(元素个数)\n数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。\n\n对于基本数据类型而言，默认初始化值各有不同\n对于引用数据类型而言，默认初始化值为null(注意与0不同！\n\n\n\n\n\n\n\n\n\n\n数组元素类型\n元素默认初始值\n\n\n\n\nbyte\n0\n\n\nshort\n0\n\n\nint\n0\n\n\nlong\n0L\n\n\nfloat\n0.0F\n\n\ndouble\n0.0\n\n\nchar\n0 或写为:’\\u0000’(表现为空)\n\n\nboolean\nfalse\n\n\n引用类型\nnull\n\n\n\n\nfor each循环依次处理数组中的每个元素（其他类型的元素集合亦可）而不必为指定下标值而分心。\nfor (v : collection) statement;\n\nint[] ints = new int[100];\nfor (int anInt : ints) {\n    ;\n}\n数组的拷贝将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组：\nint[] ints = new int[100];\nint[] b = int;\n将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：\nint b = Arrays.copyof(a,a.length)\n多维数组// 格式1（动态初始化）：\nint[][] arr = new int[3][2];\n// 格式2（动态初始化）：\nint[][] arr = new int[3][];\n// 每个一维数组都是默认初始化值null (注意：区别于格式1）可以对这个三个一维数组分别进行初始化\narr[0] = new int[3];    \narr[1] = new int[1];   \narr[2] = new int[2];\n注：int[][]arr = new int[][3];  //非法\n// 格式3（静态初始化）：\nint[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}};\n// 注意特殊写法情况：\nint[] x,y[]; x是一维数组，y是二维数组。\n\n// 声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是：\nx[0] = y;  no\ny[0] = x;   yes\ny[0][0] = x;   no\nx[0][0] = y;  no\ny[0][0] = x[0];  yes\nx = y;   no\n// 提示：\n一维数组：int[] x  或者int x[]   \n二维数组：int[][] y 或者 int[] y[]  或者 int y[][]\n数组的默认初始化与内存分析操作数组的工具类Arraysjava.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\n\n\n\n\n工具类Arrays\n\n\n\n\n\nboolean equals(int[] a,int[] b)\n判断两个数组是否相等。\n\n\nString toString(int[] a)\n输出数组信息。\n\n\nvoid fill(int[] a,int val)\n将指定值填充到数组之中。\n\n\nvoid sort(int[] a)\n对数组进行排序。\n\n\nint binarySearch(int[] a,int key)\n对排序后的数组进行二分法检索指定的值。\n\n\nstatic type copyOf(type[] a, int length)\n\n\n\nstatic type copyOfRange(type[] a, int start, int end)\n\n\n\nstatic void sort(type[] a)\n优化的快速排序算法\n\n\nstatic int binarySearch(type[] a, type v)\n\n\n\nstatic int binarySearch(type[] a, int start, int end, type v)\n二分搜索算法查找值v\n\n\nstatic void fill(type[] a, type v)\n将数组的所有数据元素值设置为v。\n\n\nstatic boolean equals(type[] a, type[] b)\n如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"J5-数组","date":"2021-11-05T03:24:52.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"1d98d63915f551c9747efb3393617836","title":"控制流程","content":"块作用域 Block块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。\n注意：\n\n不能在嵌套的两个块中声明同名的变量。\n块内定义的变量块外不能使用。\n\n\n流程控制语句\n\n\n\n流程控制\n\n\n\n\n\n\n顺序结构\n\n\n\n\n分支语句\nif-else、switch-case\n\n\n\n循环结构\nfor、while、do-while\n\n\n\n特殊流程控制语句\nbreak、continue、return\n\n\n\n\nswitch (i){\n    case 0:...;\n        break;\n    case 1:...;\n        break;\n    default:...;\n        break;\n}\ncase标签可以是：\n● 类型为char、byte、short或int的常量表达式。\n● 枚举常量。\n● 从Java SE 7开始，case标签还可以是字符串字面量。\n带标签的break语句有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望跳到嵌套的所有循环语句之外。通过添加一些额外的条件判断实现各层循环的检测很不方便。\n这里有一个示例说明了break语句的工作状态。请注意，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。\nlabel:\n{\n    ...\n\tif (condition) break label; // exits b1ock\n\t...\n}\n\n大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。\n//使用静态的valueOf方法可以将普通的数值转换为大数值\nBigInteger a = BigInteger.valueOf(999999999999999999l);\n\n//使用大数值类中的add和multiply方法。\nBigInteger d = a.multiply(a);\nSystem.out.println(d);\n\n\n\n\nBigInteger\n\n\n\n\n\nBigInteger add(BigInteger other)\n+\n\n\nBigInteger subtract(BigInteger other)\n-\n\n\nBigInteger multiply(BigInteger other)\n*\n\n\nBigInteger divide(BigInteger other)\n/\n\n\nBigInteger divide(BigInteger other)\n%\n\n\nint compareTo(BigInteger other)\n相等，返回0；小于，返回负数；否则，返回正数。\n\n\nstatic BigInteger valueOf(long x)\n返回值等于x的大整数。\n\n\n\n\n\n\n\n\nBigInteger\n\n\n\n\n\nBigDecimal add(BigDecimal other)\n+\n\n\nBigDecimal subtract(BigDecimal other)\n-\n\n\nBigDecimal multiply(BigDecimal other)\n*\n\n\nBigDecimal multiply(BigDecimal other)\n/\n\n\nint compareTo(BigDecimal other)\n比较\n\n\nstatic BigDecimal valueOf(long x)\n\n\n\nstatic BigDecimal valueOf(long x, int scale)\n\n\n\n\n\n","slug":"J4-控制流程","date":"2021-11-05T02:34:28.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"9c8bf421039c727b1fd8f06884d0808c","title":"输入输出","content":"标准输入输出数据读入import java.util.Scanner;\nScanner in = new Scanner(System,in);\n// 读入一行\nString name = in.nextLine();\n//读入一个单词\nString name = in.next();\n//读入一个整数\n int a = sc.nextInt();\n\n\n\n\n\n方法\n功能\n\n\n\n\nScanner (InputStream in)\n用给定的输入流创建一个Scanner对象。\n\n\nString nextLine( )\n读取输入的下一行内容。\n\n\nString next( )\n读取输入的下一个单词（以空格作为分隔符）。\n\n\nint nextInt( ) int nextInt( )\n读取并转换下一个表示整数或浮点数的字符序列。\n\n\nboolean hasNext( )\n检测输入中是否还有其他单词。\n\n\nboolean hasNextInt( )boolean hasNextDouble( )\n检测是否还有表示整数或浮点数的下一个字符序列。\n\n\nstatic Console console( )\n\n\n\n\n格式化输出System.out.print(x)\n每一个以%字符开始的格式说明符都用相应的参数替换。格式说明符尾部的转换符将指示被格式化的数值类型：\n\n\n\n\n转换符\n类型\n\n\n\n\nd\n十进制\n\n\nx\n十六进制\n\n\no\n八进制\n\n\nf\n定点浮点数\n\n\ne\n指数浮点数\n\n\ng\n通用浮点数\n\n\na\n十六进制浮点数\n\n\ns\n字符串\n\n\nc\n字符\n\n\nb\n布尔\n\n\nh\n散列码\n\n\ntx/TX\n日期时间\n\n\n%\n百分号\n\n\nn\n行分隔符\n\n\n\n\n可以使用多个标志，例如，“%, ( .2f”使用分组的分隔符并将负数括在括号内。\n\n\n\n\n标志\n目的\n\n\n\n\n+\n打印正负号\n\n\n空格\n在正整数前加空格\n\n\n0\n数字前补0\n\n\n-\n左对齐\n\n\n(\n将负数扩在括号里\n\n\n,\n添加分组分隔符\n\n\n#(对f格式)\n包含小数点\n\n\n#(对x或0格式)\n添加前缀0x\n\n\n$\n给定被格式化的参数索引。例如，%ISd. %1$x 将以十进制和十六进制格式打印第1个参数\n\n\n&lt;\n格式化前面说明的数值。例如，%d%&lt;x以十进制和十六进制打印同一个数值\n\n\n\n\n\n\n\n文件输入与输出文件读取要想对文件进行读取，就需要一个用File对象构造一个Scanner对象，如下所示：\nScanner in = new Scanner(Paths.get(\"myfile.txt\"),\"UTF-8\");\n如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠：“c:\\mydirectory\\myfile.txt”。\n文件写入要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：\nPrintWriter out = new PrintWriter(\"myfile.txt\",\"UTF-8\");\n\n\n\n\n\n\n\n\n\n\nScanner(File f)\n构造一个从给定文件读取数据的Scanner。\n\n\nScanner(String data)\n构造一个从给定字符串读取数据的Scanner。\n\n\nPrintWriter(String fileName)\nPrintWriter(String fileName)\n\n\nstatic Path get(String pathname)\n根据给定的路径名构造一个Path。\n\n\n\n\n\n\n\n","slug":"J3-输入输出","date":"2021-11-05T01:34:37.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"4ec631ba9c8264548f541e9cb0021e69","title":"2. 两数相加","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n\n\n\n\n\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.\n\n\n\n\n\n\n\n模拟\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode ans = new ListNode();\n        ListNode a = ans;\n        int t = 0;\n        while(l1 != null || l2 != null){\n            if(l1 != null) {\n                t += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null) {\n                t += l2.val;\n                l2 = l2.next;\n            }\n            a.next = new ListNode(t%10);\n            a = a.next;\n            t = t/10;\n        }\n        if(t != 0) a.next = new ListNode(t);\n        return ans.next;\n\n    }\n}\n","slug":"l0002","date":"2021-11-04T14:51:28.000Z","categories_index":"LeetCode","tags_index":"链表","author_index":"YFR718"},{"id":"61e4c5a8a060ffe1cb587c8f535074c6","title":"String","content":"常用方法String s = \"123456\";\n\n\n\n\n常用方法\n功能\n示例/说明\n\n\n\n\ns.substring(x,y)\n获得字串[x,y-1]\na.substring(0,3)\n\n\ns1 + s2\n拼接字符串\ns + “789”\n\n\nString.jion(‘’,”,s1,s2,s3)\n多个字符串放在一起用分隔符\n静态方法\n\n\ns.equals(s1)\n检查两字符串是否相等\n\n\n\ns.equalsIgnoreCase(s1)\n检查两字符串是否相等，忽略大小写\n\n\n\ns.length()\n获取字符串长度\n空串：长度为0\n\n\ns.codePointCount(0，s.length();\n得到实际的长度，即码点数量\n\n\n\ns.charAt(n)\n返回位置n的代码单元\n\n\n\nint codePointAt(int index)\n返回从给定位置开始的码点。\n\n\n\nint offsetByCodePoints(int startIndex, int cpCount)\n返回从startIndex代码点开始，位移cpCount后的码点索引。\n\n\n\nint compareTo(String other)\n按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。\n\n\n\nIntStream codePoints()\n将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nnew String(int[ ] codePoints, int offset, int count)\nnew String(int[ ] codePoints, int offset, int count)\n\n\n\nboolean equalsIgnoreCase(String other)\nboolean equalsIgnoreCase(String other)\n\n\n\nboolean startsWith(String prefix)\n\n\n\n\nboolean endsWith(String suffix)\n如果字符串以suffix开头或结尾，则返回true。\n\n\n\nint index0f(String str, int fromIndex)\n返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。\n\n\n\nint lastIndex0f(String str, int fromIndex)\nint lastIndex0f(String str, int fromIndex)\n\n\n\nint codePointCount(int startIndex, int endIndex)\n返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。\n\n\n\nString replace(CharSequence oldString, CharSequence newString)\n返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。\n\n\n\nString toUpperCase( )String toUpperCase( )\n返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。\n\n\n\nString trim( )\n返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。\n\n\n\n\n\n\n\n\n\n注意事项：\n\nString没办法修改字符串，可以通过提取字串+拼接实现\n\n一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。\nif(s.substring(0,3) == \"123\") // false\n\n\nStringBuilder需要由较短的字符串构建字符串\nStringBuilder builder = new StringBuilder();\n//当每次需要添加一部分内容时，就调用append方法。\nbuilder.append(\"1\");\nbuilder.append(\"2\");\n//在需要构建字符串时就调用toString方法\nSystem.out.println(builder.toString());\n\n\n\n\n\n\n\n\n\n这个类的前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑（通常都是这样），则应该用StringBuilder替代它。这两个类的API是相同的。\nAPI\n\n\n\n\n方法\n功能\n\n\n\n\n\nStringBuilder()\n构造一个空的字符串构建器。\n\n\n\nint length()\n返回构建器或缓冲器中的代码单元数量。\n\n\n\nStringBuilder append(String str)\n追加一个字符串并返回this。\n\n\n\nStringBuilder append(char c)\n追加一个代码单元并返回this。\n\n\n\nStringBuilder appendCodePoint(int cp)\n追加一个代码点，并将其转换为一个或两个代码单元并返回this。\n\n\n\nvoid setCharAt(int i, char c)\n将第i个代码单元设置为c。\n\n\n\nStringBuilder insert(int offset, String str)\n在offset位置插入一个字符串并返回this。\n\n\n\nStringBuilder insert(int offset, Char c)\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n在offset位置插入一个代码单元并返回this。\n在offset位置插入一个代码单元并返回this。\n\n\n\n\n","slug":"J2-String","date":"2021-11-04T14:38:01.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"2a28fcbe1a17ab37c1c849fd02eb2771","title":"1. 两数之和","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n\n\n\n\n\n\n\n\n\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n\n\n\n\n\n暴力解法\n双重for循环\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0;i&lt;nums.length;i++) { \n            for(int j = i+1;j&lt;nums.length;j++) {\n                if(nums[i] + nums[j] == target) {\n                    return new int[] {i,j};\n                }\n            }\n        }\n        return new int[] {0};\n    }\n}\n\n\n\n\n\n\n\n 哈希表\n\n\n// Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; hashTable = new HashMap&lt;Integer, Integer&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            if(hashTable.containsKey(target - nums[i])) {\n                return new int[]{hashTable.get(target - nums[i]),i};\n            }\n            hashTable.put(nums[i],i);\n        }\n        return new int[] {0};\n\n    }\n}\n# Python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            r = target-nums[i]\n            if r in d:\n                return [d[r],i]\n            else:\n                d[nums[i]]=i\n","slug":"l0001","date":"2021-11-04T12:06:25.000Z","categories_index":"LeetCode","tags_index":"哈希","author_index":"YFR718"},{"id":"234a650b9f919d31820f31482789a1da","title":"基本数据类型","content":"基本数据类型整数\n\n\n\n类型\n存储需求\n取值范围\n例\n\n\n\n\nint\n4字节\n（21亿）\n10\n\n\nshort\n2字节\n（32768）\n\n\n\nlong\n8字节\n\n10L\n\n\nbyte\n1字节\n（128）\n\n\n\n\n浮点数\n\n\n\n类型\n存储需求\n符号位\n指数位\n尾数位\n例\n\n\n\n\nfloat\n4字节\n1\n8\n23\n3.14F\n\n\ndouble\n8字节\n1\n11\n52\n3.14\n\n\n\n\n更详细\nchar类型\n\n\n\n类型\n存储需求\n\n\n\n\n\nchar\n2字节\n1\n\n\n\n\nchar类型的字面量值要用单引号括起来。例如：’A’.\n在Java中，char类型描述了UTF-16编码中的一个代码单元。对char类型字符运行时，直接当做ASCII表对应的整数来对待。\nUnicode 编码:一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。\nUnicode 的缺点：Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别 Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。\nUTF-8:一种变长的编码方式。它可以使用 1-6 个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则：1）对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。2）对于多字节的UTF-8编码，如果编码包含 n 个字节，那么第一个字节的前 n 位为1，第一个字节的第 n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。\nboolean\n\n\n\n类型\n存储需求\n\n\n\n\n\nboolean\n1位\ntrue/flase\n\n\n\n\n变量变量的声明与使用标识符：Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符定义合法标识符规则：\n\n由26个英文字母大小写，0-9 ，_或$ 组成\n数字不可以开头。\n不可以使用关键字和保留字，但能包含关键字和保留字。\nJava中严格区分大小写，长度无限制。\n标识符不能包含空格。\n\n变量的概念：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。变量的作用：用于在内存中保存数据\n使用变量注意：\n\nJava中每个变量必须先声明，后使用\n使用变量名来访问这块区域的数据\n变量的作用域：其定义所在的一对{ }内\n变量只有在其作用域内才有效\n同一个作用域内，不能定义重名的变量\n\n声明变量\n\n语法：&lt;数据类型&gt; &lt;变量名称&gt;;\n\n例如：int var;\n\n\n变量的赋值\n\n语法：&lt;变量名称&gt; =  &lt;值&gt;\n例如：var = 10;\n\n声明和赋值变量\n\n语法： &lt;数据类型&gt; &lt;变量名&gt; =  &lt;初始化值&gt;\n例如：int var = 10;\n\n变量的分类-按数据类型\n\n变量的分类-按声明的位置\n\n在方法体外，类体内声明的变量称为成员变量。\n在方法体内部声明的变量称为局部变量。\n\n\n常量在Java中，利用关键字final指示常量。\nfinal int A = 1000;\n数值类型之间的转换自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：\n\n\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\nbyte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。\nboolean类型不能与其它数据类型运算。\n当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。\n\nString str1 = 4; //判断对错: no\nString str2= 3.5f + \"\"; //判断str2对错: yes\nSystem.out.printIn(str2); //输出:”3.5”\nSystem.out .println(3+4+\"Hello!\"); //输出:7Hello!\nSystem.out.println(\"Hello!\" +3+4); //输出: Hello!34\nSystem.out.printIn('a'+ 1+\"Hello!\"); //输 出: 98Hello!\nSystem.out.printIn(\"Hello\"+'a'+1); //输出: Helloa1\n强制类型转换：将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。\n通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n// 判断是否能通过编译\nshort s = 5;\ns = s - 2; //报错：int 不能用short存储\ns = (short) (s - 2); //正确写法\n\nbyte b = 3;\nb = b + 4; //报错：int 不能用byte存储\nb = (byte) (b + 4); //正确写法\n\nchar a = 'a';\nint i = 5;\nfloat d = .314F;\ndouble result = a + i + d; //正确\n\nbyte b = 5;\nshort s = 3;\nshort t = s + b; //报错：int 不能用short存储\n进制与运算符\n\n\n\n进制\n\n\n\n\n\n\n二进制 (binary)\n0,1\n满2进1.以0b或0B开头\n\n\n十进制 (decimal)\n0-9\n满10进1\n\n\n八进制 (octal)：\n0-7\n满8进1. 以数字0开头表示\n\n\n十六进制 (hex) (hex)(hex)(hex)：\n0-9，A-F\n满16进1. 以0x或0X开头表示\n\n\n\n\n进制的基本转换    十进制 二进制互转       二进制转成十进制 乘以2的幂数       十进制转成二进制 除以2取余数    二进制 八进制互转    二进制 十六进制互转    十进制八进制互转    十进制十六进制互转\n\n\n\n\n运算符\n运算\n\n\n\n\n算术运算符\n+-*/%++–\n\n\n赋值运算符\n=,+=, -=, *=, /=, %=\n\n\n比较运算符（关系运算符）\n==,!=,&lt;,&gt;,&lt;=,&gt;=,instanceof\n\n\n逻辑运算符\n&amp;,\\\n,!,&amp;&amp;,\\\n\\\n,^\n\n\n位运算符\n&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,\\\n,^,~\n\n\n三元运算符\n(条件表达式)?表达式1：表达式2；\n\n\n\n\n\n\n\n\n\n位运算符的细节\n\n\n\n\n&lt;&lt;\n空位补0，被移除的高位丢弃，空缺位补0。\n\n\n&gt;&gt;\n被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。\n\n\n&gt;&gt;&gt;\n被移位二进制最高位无论是0或者是1，空缺位都用0补。\n\n\n&amp;\n二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;\n\n\n\\\n\n二进制位进行 \\\n运算，只有0 \\\n0时结果是0，否则是1;\n\n\n^\n相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1\n\n\n~\n正数取反，各二进制码按补码各位取反负数取反，各二进制码按补码各位取反\n\n\n\n\n运算优先级：\n思考1：\nshort s = 3; \ns = s+2;//s1+2运算结果是int型，需要强制转换类型   \n① s += 2;    //+= 不改变原本的数据类型\n\n思考2：\nint i = 1;\ni *= 0.1;  //*= 不改变原本的数据类型\nSystem.out.println(i);\ni++;\nSystem.out.println(i);\n\n思考3：\nint m = 2;\nint n = 3;\nn *= m++; \nSystem.out.println(\"m=\" + m); System.out.println(\"n=\" + n); 3，6\n    \n思考4：\nint n = 10;\nn += (n++) + (++n); //10 + 10 + 12\nSystem.out.println(n);\n“&amp;”和“&amp;&amp;”的区别：“|”和“||”的区别同理    单&amp;时，左边无论真假，右边都进行运算；    双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。\nint x = 1,y = 1;\nif(x++==2 &amp; ++y==2){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，2\nint x = 1,y = 1;\nif(x++==2 &amp;&amp; ++y==2){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 2，1\nint x = 1,y = 1;\nif(x++==1 | ++y==1){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，2\n\nint x = 1,y = 1;\nif(x++==1 || ++y==1){\n    x =7;\n}\nSystem.out.println(\"x=\"+x+\",y=\"+y);\n// 7，1\n\nclass Test {\n    public static void main (String [] args) {\n        boolean x=true;\n        boolean y=false;\n        short z=42;\n        //if(y == true)\n        if((z++==42)&amp;&amp;(y=true))z++;\n        if((x=false) || (++z==45)) z++;\n        System.out.println(\"z=\"+z);\n    }\n}\n// z=46\n","slug":"J1-数据类型","date":"2021-11-04T09:50:09.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"2646898c8ef5a9766cbd5f124442ee5c","title":"Java概述","content":"Java概述是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。\nJava语言特性\n特点一：面向对象\n两个基本概念：类、对象\n三大特性：封装、继承、多态\n\n特点二：健壮性\n吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制\n\n特点三：跨平台性\n跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”\n原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。\n因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。\n\n\n核心机制—Java虚拟机\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n对于不同的平台，有不同的虚拟机。\n只有某平台提供了对应的java虚拟机，java程序才可在此平台运行\nJava虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”\n\n核心机制—垃圾回收​        不再使用的内存空间应回收——垃圾回收。在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。\n\n\n\n\nJava语言的环境\n功能\n包含\n\n\n\n\nJDK(Java Development Kit    Java开发工具包)\nJDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。\nJRE + 开发工具集（编译工具javac.exe 打包工具jar.exe)\n\n\nJRE(Java Runtime Environment    Java运行环境)\n包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\nJVM + Java SE标准类库\n\n\nJVM (Java Virtal Machine Java虚拟机）\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n\n\n\n\nHello Java​        我们来编写第一个简单的Java程序：\npublic class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\npublic称为访问修饰符（accessmodifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。\nclass表明Java程序中的全部内容都包含在类中。\nHelloJava：类名。\nstatic：静态方法。\nvoid：无参数返回。\nmain：主方法，程序的入口。\nString[]：程序执行的参数。\nargs：参数名。\nSystem.out.println()：输出一行语句。\n\nJava运行步骤：\n将 Java 代码编写到扩展名为 .java 的文件中。\n通过 javac 命令对该 java 文件进行编译。\n通过 java 命令对生成的 class 文件进行运行。\n\nC:\\Users\\24378\\Desktop\\Java>javac f1.java\nC:\\Users\\24378\\Desktop\\Java>java f1\nhello Java\n一些规范Java命名规范\n\n\n\n类型(名)\n约束\n列\n\n\n\n\n项目\n全部小写，画线-分隔\nspring-cloud\n\n\n包\n全部小写\ncom.yfr.softmax\n\n\n类\n单次首字母大写\nNewWorld\n\n\n变量/方法\n首字母小写\nuserName\n\n\n常量\n全部大写，下划线_分隔\nINT_MAX\n\n\n\n\nJava代码编写规范public class HelloJava &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"2333\");\n    &#125;\n&#125;\n\n注意大括号的风格\n二元三元运算符两边用一个空格隔开\n逗号语句后如不换行，紧跟一个空格\n将类似操作，或一组操作放在一起不用空行隔开，而用空行隔开不同组的代码\n每个if while for等语句，都不要省略大括号{}\n\nJava注释\n\n\n\n注释类型\n\n\n\n\n\n\n单行注释\n//注释文字\n\n\n\n多行注释\n/  注释文字 /\n\n\n\n文档注释：\n/*@author  指定java程序的作者@version  指定源文件的版本/\n\n\n\n\n# 生成注释文档\nPS C:\\Users\\24378\\Desktop\\Java&gt; javadoc -d mydoc -author -version .\\f1.java\n正在加载源文件.\\f1.java...\n正在构造 Javadoc 信息...\n...\nJava注意事项\nJava源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本例中的HelloWorld类。\n\nJava应用程序的执行入口是main()方法。它有固定的书写格式：\npublic static void main(String[] args)  &#123;...&#125;\n\n\n\nJava语言严格区分大小写。\n\nJava方法由一条条语句构成，每个语句以“;”结束。\n\n大括号都是成对出现的，缺一不可。\n\n一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。\n\n\n","slug":"J0-Java概述","date":"2021-11-04T06:41:20.000Z","categories_index":"JAVA","tags_index":"java","author_index":"YFR718"},{"id":"07213b6ca5497f88ac351468e0325797","title":"Hexo 个人博客搭建","content":"Hexo 个人博客搭建安装步骤\ngithub创建yfr718.github.io项目\n\n安装git、设置用户名和邮箱、ssh连接github\ngit config --global user.name &quot;你的GitHub用户名&quot;\ngit config --global user.email &quot;你的GitHub注册邮箱&quot;\nssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;\n#打开GitHub_Settings_keys 页面，新建new SSH Key\n#Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 \nssh git@github.com\n\n\n\n安装Node.js\n# 安装后，检测Node.js是否安装成功，在命令行中输入 \nnode -v\n\n安装Hexo\n# 在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。\n# 在相应文件夹安装Hexo\nnpm install -g hexo-cli \n# 初始化博客\nhexo init blog\n# 查看博客网页\nhexo g #生成网页\nhexo s #运行网页\n# 完成后，打开浏览器输入地址：\nlocalhost:4000\n\n\nHexo 常用命令博客管理npm install hexo -g # 安装Hexo\nnpm update hexo -g # 升级\nhexo init # 初始化博客\nhexo clean # 清除缓存文件 db.json 和已生成的静态文件 public\nhexo g # 自动生成网站静态文件，并部署到设定的仓库\nhexo s # 启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;\nhexo d # 自动生成网站静态文件，并部署到设定的仓库\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d # 本地更新后重新部署到github上\n文章管理# 新建文章\nhexo new 文章文件名\n一些markdown格式\n\n\n\n\n\n提示\nNormal Tips Container\n\n\n\n\n\n\n\n\n注意\nWarning!!!\n\n\n\n\n\n\n\n\naaa\nWarning!!!\n\n\n\n\n\n\n\n\n特别注意\nDanger!!!\n\n\nClick to see more\n\n隐藏内容\n\n\n\n引用块\n\n","slug":"0.Hexo个人博客搭建","date":"2021-11-02T09:47:00.000Z","categories_index":"前端","tags_index":"hexo","author_index":"YFR718"}]