{"title":"常用类、枚举、注解","uid":"d0396f84e2a9cf009e1f2a35f0f836dd","slug":"J3-常用类、枚举、注解","date":"2021-11-12T02:30:10.000Z","updated":"2021-11-22T08:57:16.597Z","comments":true,"path":"api/articles/J3-常用类、枚举、注解.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/eef428568dd84069a9e6a30263ad6b00.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","content":"<h1 id=\"1-Java常用类\"><a href=\"#1-Java常用类\" class=\"headerlink\" title=\"1. Java常用类\"></a>1. Java常用类</h1><h2 id=\"0-Wapper包装类\"><a href=\"#0-Wapper包装类\" class=\"headerlink\" title=\"0. Wapper包装类\"></a>0. Wapper包装类</h2><p>ing</p>\n<h2 id=\"1-1-字符串相关的类\"><a href=\"#1-1-字符串相关的类\" class=\"headerlink\" title=\"1.1 字符串相关的类\"></a>1.1 字符串相关的类</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p><strong>String的特性</strong></p>\n<ul>\n<li>String类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</li>\n<li>String是一个final类，代表不可变的字符序列。</li>\n<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li>\n<li>String对象的字符内容是存储在一个字符数组value[]中的。</li>\n</ul>\n<p><strong>String对象的创建</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//本质上this.value = new char[0];</span>\n<span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">//this.value = original.value;</span>\n<span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> original<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">//this.value = Arrays.copyOf(value, value.length);</span>\n<span class=\"token class-name\">String</span> s3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token class-name\">String</span> s4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"字符串对象是如何存储的\"><a href=\"#字符串对象是如何存储的\" class=\"headerlink\" title=\"字符串对象是如何存储的\"></a>字符串对象是如何存储的</h4><p><strong>结论</strong>：</p>\n<ol>\n<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li>\n<li>只要其中有一个是变量，结果就在堆中</li>\n<li>如果拼接的结果调用intern()方法，返回值就在常量池中</li>\n</ol>\n<p><strong>String使用陷阱</strong></p>\n<ul>\n<li>String s1 = “a”;<br>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</li>\n<li>s1 = s1 + “b”;<br>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</li>\n<li>String s2 = “ab”;<br>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</li>\n<li>String s3 = “a” + “b”;<br>说明：s3指向字符串常量池中已经创建的”ab”的字符串。<br>String s4 = s1.intern();<br>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</li>\n</ul>\n<h4 id=\"String常用方法\"><a href=\"#String常用方法\" class=\"headerlink\" title=\"String常用方法\"></a>String常用方法</h4><ul>\n<li>int length()：返回字符串的长度： return value.length</li>\n<li>char charAt(int index)： 返回某索引处的字符return value[index]</li>\n<li>boolean isEmpty()：判断是否是空字符串：return value.length == 0</li>\n<li>String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写</li>\n<li>String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写</li>\n<li>String trim()：返回字符串的副本，忽略前导空白和尾部空白</li>\n<li>boolean equals(Object obj)：比较字符串的内容是否相同</li>\n<li>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写</li>\n<li>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”</li>\n<li>int compareTo(String anotherString)：比较两个字符串的大小</li>\n<li>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</li>\n<li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</li>\n<li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</li>\n<li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</li>\n<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</li>\n<li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</li>\n<li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</li>\n<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>\n<li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</li>\n<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</li>\n<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar 替换此字符串中出现的所有oldChar 得到的。</li>\n<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</li>\n<li>String replaceAll(String regex, String replacement) ： 使用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</li>\n<li>String replaceFirst(String regex, String replacement) ：使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li>\n<li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</li>\n<li>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</li>\n<li>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</li>\n</ul>\n<h4 id=\"String与字符数组转换\"><a href=\"#String与字符数组转换\" class=\"headerlink\" title=\"String与字符数组转换\"></a>String与字符数组转换</h4><ul>\n<li><p>字符数组-&gt;字符串<br>    String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</p>\n</li>\n<li><p>字符串-&gt;字符数组<br>    public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。<br>    public void getChars(int srcBegin, int srcEnd, char[] dst,<br>int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</p>\n</li>\n<li><p>字节数组-&gt;字符串<br>    String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。<br>    String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</p>\n</li>\n<li><p>字符串-&gt;字节数组<br>    public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。<br>    public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</p>\n</li>\n</ul>\n<h3 id=\"StringBuffer类\"><a href=\"#StringBuffer类\" class=\"headerlink\" title=\"StringBuffer类\"></a>StringBuffer类</h3><ul>\n<li>java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。</li>\n<li>很多方法与String相同。</li>\n<li>作为参数传递时，方法内部可以改变值。</li>\n</ul>\n<p><strong>StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器：</strong><br>    StringBuffer()：初始容量为16的字符串缓冲区<br>    StringBuffer(int size)：构造指定容量的字符串缓冲区<br>    StringBuffer(String str)：将内容初始化为指定字符串内容</p>\n<h4 id=\"StringBuffer类的常用方法\"><a href=\"#StringBuffer类的常用方法\" class=\"headerlink\" title=\"StringBuffer类的常用方法\"></a>StringBuffer类的常用方法</h4><ul>\n<li>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</li>\n<li>StringBuffer delete(int start,int end)：删除指定位置的内容</li>\n<li>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str </li>\n<li>StringBuffer insert(int offset, xxx)：在指定位置插入xxx</li>\n<li>StringBuffer reverse() ：把当前字符序列逆转</li>\n<li>public int indexOf(String str)</li>\n<li>public String substring(int start,int end) public int length()</li>\n<li>public char charAt(int n )</li>\n<li>public void setCharAt(int n ,char ch)</li>\n</ul>\n<h3 id=\"StringBuilder类\"><a href=\"#StringBuilder类\" class=\"headerlink\" title=\"StringBuilder类\"></a>StringBuilder类</h3><p>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样<br><strong>面试题：对比String、StringBuffer、StringBuilder</strong>⭐⭐</p>\n<p>    String(JDK1.0)：不可变字符序列<br>    StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全<br>    StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全</p>\n<p>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</p>\n<h2 id=\"1-2-JDK-8之前的日期时间API\"><a href=\"#1-2-JDK-8之前的日期时间API\" class=\"headerlink\" title=\"1.2 JDK 8之前的日期时间API\"></a>1.2 JDK 8之前的日期时间API</h2><h4 id=\"1-java-lang-System类\"><a href=\"#1-java-lang-System类\" class=\"headerlink\" title=\"1. java.lang.System类\"></a>1. java.lang.System类</h4><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p>\n<p>此方法适于计算时间差。</p>\n<ul>\n<li>计算世界时间的主要标准有：<br>    UTC(Coordinated Universal Time)<br>    GMT(Greenwich Mean Time)<br>    CST(Central Standard Time)</li>\n</ul>\n<h3 id=\"2-java-util-Date类\"><a href=\"#2-java-util-Date类\" class=\"headerlink\" title=\"2. java.util.Date类\"></a>2. java.util.Date类</h3><p>表示特定的瞬间，精确到毫秒</p>\n<ul>\n<li>构造器：<br>    Date()：使用无参构造器创建的对象可以获取本地当前时间。<br>    Date(long date)</li>\n<li>常用方法<br>    getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。<br>    toString():把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。<br>    其它很多方法都过时了。</li>\n</ul>\n<h3 id=\"3-java-text-SimpleDateFormat类\"><a href=\"#3-java-text-SimpleDateFormat类\" class=\"headerlink\" title=\"3. java.text.SimpleDateFormat类\"></a>3. java.text.SimpleDateFormat类</h3><ul>\n<li><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>\n</li>\n<li><p>它允许进行格式化：日期文本、解析：文本日期</p>\n</li>\n<li><p>格式化</p>\n<p>    SimpleDateFormat() ：默认的模式和语言环境创建对象<br>    public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：<br>    public String format(Date date)：方法格式化时间对象date</p>\n</li>\n<li><p>解析：public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/fbf1fe368e9e4b87bddf07de755e17db.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<h3 id=\"4-java-util-Calendar-日历-类\"><a href=\"#4-java-util-Calendar-日历-类\" class=\"headerlink\" title=\"4. java.util.Calendar(日历)类\"></a>4. java.util.Calendar(日历)类</h3><ul>\n<li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li>\n<li>获取Calendar实例的方法<br>    使用Calendar.getInstance()方法<br>    调用它的子类GregorianCalendar的构造器。</li>\n<li>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、 MINUTE、SECOND<br>    public void set(int field,int value)<br>    public void add(int field,int amount)<br>    public final Date getTime()<br>    public final void setTime(Date date)</li>\n<li>注意:<br>    获取月份时：一月是0，二月是1，以此类推，12月是11<br>    获取星期时：周日是1，周二是2 ， 。。。。周六是7</li>\n</ul>\n<h2 id=\"1-3-JDK-8中新日期时间API\"><a href=\"#1-3-JDK-8中新日期时间API\" class=\"headerlink\" title=\"1.3 JDK 8中新日期时间API\"></a>1.3 JDK 8中新日期时间API</h2><p>新时间日期API</p>\n<p>    第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。<br>    Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间<br>（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。</p>\n<ul>\n<li>java.time – 包含值对象的基础包</li>\n<li>java.time.chrono – 提供对不同的日历系统的访问</li>\n<li>java.time.format – 格式化和解析时间和日期</li>\n<li>java.time.temporal – 包括底层框架和扩展特性</li>\n<li>java.time.zone – 包含时区支持的类</li>\n</ul>\n<p>    LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。<br>    LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。<br>    LocalTime表示一个时间，而不是日期。<br>    LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>now() / *  now(ZoneId zone)</td>\n<td>静态方法，根据当前时间创建对象/指定时区的对象</td>\n</tr>\n<tr>\n<td>of()</td>\n<td>静态方法，根据指定日期/时间创建对象</td>\n</tr>\n<tr>\n<td>getDayOfMonth()/getDayOfYear()</td>\n<td>获得月份天数(1-31) /获得年份天数(1-366)</td>\n</tr>\n<tr>\n<td>getDayOfWeek()</td>\n<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>\n</tr>\n<tr>\n<td>getMonth()</td>\n<td>获得月份, 返回一个 Month 枚举值</td>\n</tr>\n<tr>\n<td>getMonthValue() / getYear()</td>\n<td>获得月份(1-12) /获得年份</td>\n</tr>\n<tr>\n<td>getHour()/getMinute()/getSecond()</td>\n<td>获得当前对象对应的小时、分钟、秒</td>\n</tr>\n<tr>\n<td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td>\n<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>\n</tr>\n<tr>\n<td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td>\n<td>向当前对象添加几天、几周、几个月、几年、几小时</td>\n</tr>\n<tr>\n<td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td>\n<td>从当前对象减去几月、几周、几天、几年、几小时</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"瞬时：Instant\"><a href=\"#瞬时：Instant\" class=\"headerlink\" title=\"瞬时：Instant\"></a>瞬时：Instant</h3><p>    Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。<br>    在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。<br>    java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。<br>    (1 ns = 10-9 s)   1秒 = 1000毫秒 =10^6微秒=10^9纳秒</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>now()</td>\n<td>静态方法，返回默认UTC时区的Instant类的对象</td>\n</tr>\n<tr>\n<td>ofEpochMilli(long epochMilli)</td>\n<td>静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td>\n</tr>\n<tr>\n<td>atOffset(ZoneOffset offset)</td>\n<td>结合即时的偏移来创建一个OffsetDateTime</td>\n</tr>\n<tr>\n<td>toEpochMilli()</td>\n<td>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p>\n<h3 id=\"格式化与解析日期或时间\"><a href=\"#格式化与解析日期或时间\" class=\"headerlink\" title=\"格式化与解析日期或时间\"></a>格式化与解析日期或时间</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>\n<p>    预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME<br>    本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)<br>    自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方 法</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ofPattern(String pattern)</td>\n<td>静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 的DateTimeFormatter</td>\n</tr>\n<tr>\n<td>format(TemporalAccessor t)</td>\n<td>格式化一个日期、时间，返回字符串</td>\n</tr>\n<tr>\n<td>parse(CharSequence text)</td>\n<td>将指定格式的字符序列解析为一个日期、时间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"其它API\"><a href=\"#其它API\" class=\"headerlink\" title=\"其它API\"></a>其它API</h3><ul>\n<li>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</li>\n<li>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</li>\n<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等</li>\n<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</li>\n<li>持续时间：Duration，用于计算两个“时间”间隔</li>\n<li>日期间隔：Period，用于计算两个“日期”间隔</li>\n<li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</li>\n<li>TemporalAdjusters : 该类通过静态方法<br>(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。</li>\n</ul>\n<h3 id=\"与传统日期处理的转换\"><a href=\"#与传统日期处理的转换\" class=\"headerlink\" title=\"与传统日期处理的转换\"></a>与传统日期处理的转换</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>To 遗留类</th>\n<th>From 遗留类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>java.time.Instant与java.util.Date</td>\n<td>Date.from(instant)</td>\n<td>date.toInstant()</td>\n</tr>\n<tr>\n<td>java.time.Instant与java.sql.Timestamp</td>\n<td>Timestamp.from(instant)</td>\n<td>timestamp.toInstant()</td>\n</tr>\n<tr>\n<td>java.time.ZonedDateTime与java.util.GregorianCalendar</td>\n<td>GregorianCalendar.from(zonedDateTime)</td>\n<td>cal.toZonedDateTime()</td>\n</tr>\n<tr>\n<td>java.time.LocalDate与java.sql.Time</td>\n<td>Date.valueOf(localDate)</td>\n<td>date.toLocalDate()</td>\n</tr>\n<tr>\n<td>java.time.LocalTime与java.sql.Time</td>\n<td>Date.valueOf(localDate)</td>\n<td>date.toLocalTime()</td>\n</tr>\n<tr>\n<td>java.time.LocalDateTime与java.sql.Timestamp</td>\n<td>Timestamp.valueOf(localDateTime)</td>\n<td>timestamp.toLocalDateTime()</td>\n</tr>\n<tr>\n<td>java.time.ZoneId与java.util.TimeZone</td>\n<td>Timezone.getTimeZone(id)</td>\n<td>timeZone.toZoneId()</td>\n</tr>\n<tr>\n<td>java.time.format.DateTimeFormatter与java.text.DateFormat</td>\n<td>formatter.toFormat()</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"1-4-Java比较器\"><a href=\"#1-4-Java比较器\" class=\"headerlink\" title=\"1.4 Java比较器\"></a>1.4 Java比较器</h2><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。<br><strong>Java实现对象排序的方式有两种：</strong></p>\n<ol>\n<li>自然排序：java.lang.Comparable</li>\n<li>定制排序：java.util.Comparator</li>\n</ol>\n<h3 id=\"自然排序：java-lang-Comparable\"><a href=\"#自然排序：java-lang-Comparable\" class=\"headerlink\" title=\"自然排序：java.lang.Comparable\"></a>自然排序：java.lang.Comparable</h3><p>    Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。<br>    实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。<br>    实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。<br>    对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。</p>\n<p><strong>Comparable 的典型实现：(默认都是从小到大排列的)</strong><br>    String：按照字符串中字符的Unicode值进行比较<br>    Character：按照字符的Unicode值来进行比较<br>    数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较<br>    Boolean：true 对应的包装类实例大于 false 对应的包装类实例<br>    Date、Time等：后面的日期时间比前面的日期时间大</p>\n<h3 id=\"定制排序：java-util-Comparator\"><a href=\"#定制排序：java-util-Comparator\" class=\"headerlink\" title=\"定制排序：java.util.Comparator\"></a>定制排序：java.util.Comparator</h3><p>    当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。<br>    重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。<br>    可以将 Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort），从而允许在排序顺序上实现精确控制。<br>    还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>\n<h2 id=\"1-5-System类\"><a href=\"#1-5-System类\" class=\"headerlink\" title=\"1.5 System类\"></a>1.5 System类</h2><p>    System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。<br>    由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。<br><strong>成员变量</strong><br>    System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。<br><strong>成员方法</strong><br>    native long currentTimeMillis()：<br>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。<br>    void exit(int status)：<br>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>\n<ul>\n<li>void gc()：<br>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>\n<li>String getProperty(String key)：<br>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</li>\n</ul>\n<h2 id=\"1-6-Math类\"><a href=\"#1-6-Math类\" class=\"headerlink\" title=\"1.6 Math类\"></a>1.6 Math类</h2><p>ava.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abs</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>acos,asin,atan,cos,sin,tan</td>\n<td>三角函数</td>\n</tr>\n<tr>\n<td>sqrt</td>\n<td>平方根</td>\n</tr>\n<tr>\n<td>pow(double a,doble b)</td>\n<td>a的b次幂</td>\n</tr>\n<tr>\n<td>log</td>\n<td>自然对数</td>\n</tr>\n<tr>\n<td>exp</td>\n<td>e为底指数</td>\n</tr>\n<tr>\n<td>max(double a,double b)</td>\n<td></td>\n</tr>\n<tr>\n<td>min(double a,double b)</td>\n<td></td>\n</tr>\n<tr>\n<td>random()</td>\n<td>返回0.0到1.0的随机数</td>\n</tr>\n<tr>\n<td>long round(double a)</td>\n<td>double型数据a转换为long型（四舍五入）</td>\n</tr>\n<tr>\n<td>toDegrees(double angrad)</td>\n<td>弧度—&gt;角度</td>\n</tr>\n<tr>\n<td>toRadians(double angdeg)</td>\n<td>角度—&gt;弧度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"1-7-BigInteger与BigDecimal\"><a href=\"#1-7-BigInteger与BigDecimal\" class=\"headerlink\" title=\"1.7 BigInteger与BigDecimal\"></a>1.7 BigInteger与BigDecimal</h2><h3 id=\"BigInteger类\"><a href=\"#BigInteger类\" class=\"headerlink\" title=\"BigInteger类\"></a>BigInteger类</h3><p>    Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。<br>    java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。<br>    构造器：BigInteger(String val)：根据字符串构建BigInteger对象</p>\n<p><strong>常用方法</strong></p>\n<ul>\n<li>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。</li>\n<li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>\n<li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>\n<li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>\n<li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li>\n<li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li>\n<li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。</li>\n<li>BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。</li>\n</ul>\n<h3 id=\"BigDecimal类\"><a href=\"#BigDecimal类\" class=\"headerlink\" title=\"BigDecimal类\"></a>BigDecimal类</h3><p>​        一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。<br>​        BigDecimal类支持不可变的、任意精度的有符号十进制定点数。<br><strong>构造器</strong><br>    public BigDecimal(double val)<br>    public BigDecimal(String val)<br><strong>常用方法</strong><br>    public BigDecimal add(BigDecimal augend)<br>    public BigDecimal subtract(BigDecimal subtrahend)<br>    public BigDecimal multiply(BigDecimal multiplicand)<br>    public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p>\n<h1 id=\"2-枚举类与注解\"><a href=\"#2-枚举类与注解\" class=\"headerlink\" title=\"2. 枚举类与注解\"></a>2. 枚举类与注解</h1><p><strong>枚举类的实现</strong><br>    JDK1.5之前需要自定义枚举类<br>    JDK 1.5 新增的 enum 关键字用于定义枚举类</p>\n<ul>\n<li>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</li>\n<li>枚举类的属性<br>    枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰<br>    枚举类的使用 private final 修饰的属性应该在构造器中为其赋值<br>    若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</li>\n</ul>\n<h2 id=\"2-1-枚举类的使用\"><a href=\"#2-1-枚举类的使用\" class=\"headerlink\" title=\"2.1 枚举类的使用\"></a>2.1 枚举类的使用</h2><h3 id=\"自定义枚举类\"><a href=\"#自定义枚举类\" class=\"headerlink\" title=\"自定义枚举类\"></a>自定义枚举类</h3><ol>\n<li>私有化类的构造器，保证不能在类的外部创建其对象</li>\n<li>在类的内部创建枚举类的实例。声明为：public static final</li>\n<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li>\n</ol>\n<h3 id=\"使用关键字enum定义枚举类\"><a href=\"#使用关键字enum定义枚举类\" class=\"headerlink\" title=\"使用关键字enum定义枚举类\"></a>使用关键字enum定义枚举类</h3><p><strong>使用说明</strong><br>    使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类<br>    枚举类的构造器只能使用 private 权限修饰符<br>    枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰<br>    必须在枚举类的第一行声明枚举类对象</p>\n<ul>\n<li>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。</li>\n</ul>\n<h3 id=\"Enum类的主要方法\"><a href=\"#Enum类的主要方法\" class=\"headerlink\" title=\"Enum类的主要方法\"></a>Enum类的主要方法</h3><p>    values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。<br>    valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。<br>    toString()：返回当前枚举类对象常量的名称</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2f825118ea784e088725fe127ce60194.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<h3 id=\"实现接口的枚举类\"><a href=\"#实现接口的枚举类\" class=\"headerlink\" title=\"实现接口的枚举类\"></a>实现接口的枚举类</h3><ul>\n<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>\n<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>\n<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法</li>\n</ul>\n<h2 id=\"2-2-注解的使用\"><a href=\"#2-2-注解的使用\" class=\"headerlink\" title=\"2.2 注解的使用\"></a>2.2 注解的使用</h2><h3 id=\"注解-Annotation-概述\"><a href=\"#注解-Annotation-概述\" class=\"headerlink\" title=\"注解(Annotation)概述\"></a>注解(Annotation)概述</h3><p>    从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)<br>    Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。<br>    Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在Annotation的 “name=value” 对中。</p>\n<p>    在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。<br>    未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。</p>\n<h3 id=\"常见的Annotation示例\"><a href=\"#常见的Annotation示例\" class=\"headerlink\" title=\"常见的Annotation示例\"></a>常见的Annotation示例</h3><p>    使用Annotation 时要在其前面增加 @ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素<br>    示例一：生成文档相关的注解</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@author</span> 标明开发该类模块的作者，多个作者之间使用<span class=\"token punctuation\">,</span>分割\n<span class=\"token annotation punctuation\">@version</span> 标明该类模块的版本\n<span class=\"token annotation punctuation\">@see</span> 参考转向，也就是相关主题\n<span class=\"token annotation punctuation\">@since</span> 从哪个版本开始增加的\n<span class=\"token annotation punctuation\">@param</span> 对方法中某参数的说明，如果没有参数就不能写\n<span class=\"token annotation punctuation\">@return</span> 对方法返回值的说明，如果方法的返回值类型是<span class=\"token keyword\">void</span>就不能写\n<span class=\"token annotation punctuation\">@exception</span> 对方法可能抛出的异常进行说明，如果方法没有用<span class=\"token keyword\">throws</span>显式抛出的异常就不能写其中<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>@param @return 和@exception 这三个标记都是只用于方法的。 @param的格式要求：@param 形参名形参类型 形参说明</li>\n<li>@return 的格式要求：@return 返回值类型返回值说明</li>\n<li>@exception的格式要求：@exception 异常类型异常说明</li>\n<li>@param和@exception可以并列多个</li>\n</ul>\n<p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)<br>    @Override: 限定重写父类方法, 该注解只能用于方法<br>    @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择<br>    @SuppressWarnings: 抑制编译器警告</p>\n<h3 id=\"自定义Annotation\"><a href=\"#自定义Annotation\" class=\"headerlink\" title=\"自定义Annotation\"></a>自定义Annotation</h3><ul>\n<li>定义新的Annotation 类型使用@interface 关键字</li>\n<li>自定义注解自动继承了java.lang.annotation.Annotation接口</li>\n<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。</li>\n<li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用default 关键字</li>\n<li>如果只有一个参数成员，建议使用参数名为value</li>\n<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”</li>\n<li>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据Annotation</li>\n</ul>\n<h3 id=\"JDK中的元注解\"><a href=\"#JDK中的元注解\" class=\"headerlink\" title=\"JDK中的元注解\"></a>JDK中的元注解</h3><p>JDK 的元Annotation 用于修饰其他Annotation 定义</p>\n<p>JDK5.0提供了4个标准的meta-annotation类型，分别是：<br>    Retention<br>    Target<br>    Documented<br>    Inherited</p>\n<ul>\n<li><p>@Retention: 只能用于修饰一个Annotation 定义, 用于指定该Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用<br>@Rentention 时必须为该 value 成员变量指定值:<br>    RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释<br>    RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值<br>    RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。</p>\n</li>\n<li><p>@Target: 用于修饰Annotation 定义, 用于指定被修饰的Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f3dd722cac9e484693f35214d16ef5bd.png\" alt=\"\"></p>\n</li>\n<li><p>@Documented: 用于指定被该元Annotation 修饰的Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。<br>    定义为Documented的注解必须设置Retention值为RUNTIME。</p>\n</li>\n<li><p>@Inherited: 被它修饰的Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的Annotation, 则其子类将自动具有该注解。<br>    比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解<br>    实际应用中，使用较少</p>\n</li>\n</ul>\n<h3 id=\"利用反射获取注解信息（在反射部分涉及）\"><a href=\"#利用反射获取注解信息（在反射部分涉及）\" class=\"headerlink\" title=\"利用反射获取注解信息（在反射部分涉及）\"></a>利用反射获取注解信息（在反射部分涉及）</h3><ul>\n<li>JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素</li>\n<li>当一个Annotation 类型被定义为运行时Annotation 后, 该注解才是运行时可见, 当 class 文件被载入时保存在 class 文件中的Annotation 才会被虚拟机读取</li>\n<li>程序可以调用AnnotatedElement对象的如下方法来访问Annotation 信息</li>\n</ul>\n<h3 id=\"JDK-8中注解的新特性\"><a href=\"#JDK-8中注解的新特性\" class=\"headerlink\" title=\"JDK 8中注解的新特性\"></a>JDK 8中注解的新特性</h3><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。</p>\n<p><strong>类型注解：</strong></p>\n<ul>\n<li>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE。</li>\n<li>在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方。<br>    ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。<br>    ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 </li>\n</ul>\n","text":"1. Java常用类0. Wapper包装类ing 1.1 字符串相关的类StringString的特性 String类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 String是一个final类，代表不可变的字符序列。 字符串是常量...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Java%E5%B8%B8%E7%94%A8%E7%B1%BB\"><span class=\"toc-text\">1. Java常用类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-Wapper%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">0. Wapper包装类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">1.1 字符串相关的类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#String\"><span class=\"toc-text\">String</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84\"><span class=\"toc-text\">字符串对象是如何存储的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">String常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#String%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">String与字符数组转换</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#StringBuffer%E7%B1%BB\"><span class=\"toc-text\">StringBuffer类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#StringBuffer%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">StringBuffer类的常用方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#StringBuilder%E7%B1%BB\"><span class=\"toc-text\">StringBuilder类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-JDK-8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API\"><span class=\"toc-text\">1.2 JDK 8之前的日期时间API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-java-lang-System%E7%B1%BB\"><span class=\"toc-text\">1. java.lang.System类</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-java-util-Date%E7%B1%BB\"><span class=\"toc-text\">2. java.util.Date类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-java-text-SimpleDateFormat%E7%B1%BB\"><span class=\"toc-text\">3. java.text.SimpleDateFormat类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-java-util-Calendar-%E6%97%A5%E5%8E%86-%E7%B1%BB\"><span class=\"toc-text\">4. java.util.Calendar(日历)类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-JDK-8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API\"><span class=\"toc-text\">1.3 JDK 8中新日期时间API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9E%AC%E6%97%B6%EF%BC%9AInstant\"><span class=\"toc-text\">瞬时：Instant</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F%E6%88%96%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">格式化与解析日期或时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83API\"><span class=\"toc-text\">其它API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">与传统日期处理的转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-Java%E6%AF%94%E8%BE%83%E5%99%A8\"><span class=\"toc-text\">1.4 Java比较器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%9Ajava-lang-Comparable\"><span class=\"toc-text\">自然排序：java.lang.Comparable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%9Ajava-util-Comparator\"><span class=\"toc-text\">定制排序：java.util.Comparator</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-System%E7%B1%BB\"><span class=\"toc-text\">1.5 System类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-Math%E7%B1%BB\"><span class=\"toc-text\">1.6 Math类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-BigInteger%E4%B8%8EBigDecimal\"><span class=\"toc-text\">1.7 BigInteger与BigDecimal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BigInteger%E7%B1%BB\"><span class=\"toc-text\">BigInteger类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BigDecimal%E7%B1%BB\"><span class=\"toc-text\">BigDecimal类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">2. 枚举类与注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.1 枚举类的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">自定义枚举类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">使用关键字enum定义枚举类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Enum%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Enum类的主要方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">实现接口的枚举类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2 注解的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3-Annotation-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">注解(Annotation)概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84Annotation%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">常见的Annotation示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89Annotation\"><span class=\"toc-text\">自定义Annotation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDK%E4%B8%AD%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">JDK中的元注解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF%EF%BC%88%E5%9C%A8%E5%8F%8D%E5%B0%84%E9%83%A8%E5%88%86%E6%B6%89%E5%8F%8A%EF%BC%89\"><span class=\"toc-text\">利用反射获取注解信息（在反射部分涉及）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDK-8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">JDK 8中注解的新特性</span></a></li></ol></li></ol></li></ol>","author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"集合、泛型","uid":"a3bf914b929f60f3127d07c8144366a0","slug":"J4-集合、泛型","date":"2021-11-12T02:30:35.000Z","updated":"2021-11-23T03:15:52.841Z","comments":true,"path":"api/articles/J4-集合、泛型.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/2cd6d6a421f1455fb6a93e78ffeefd47.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"1. Java集合1.1 Java集合框架概述Java 集合可分为 Collection 和 Map 两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合List：元素有序、可重复的集合Set：元素无序、不可重复的集合 Map接口：双列数据，保存具有映射关...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"异常与多线程","uid":"8dfa68efe4979ccc3a00434835ec3a9a","slug":"J2-异常与多线程","date":"2021-11-12T02:28:44.000Z","updated":"2021-11-12T06:22:50.497Z","comments":true,"path":"api/articles/J2-异常与多线程.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/3e16bbd9c78544ff8c14fd55fb02aa4f.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"1. 异常处理1.1 异常概述与异常体系结构异常：在Java语言中，将程序执行中发生的不正常情况 异常事件可分为两类： Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}}}