{"title":"反射、新特性","uid":"9a9e7d03fd63b8b9dd7648918fd31ad5","slug":"J6-反射、新特性","date":"2021-11-12T02:31:21.000Z","updated":"2021-11-25T06:40:58.918Z","comments":true,"path":"api/articles/J6-反射、新特性.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/64f64be78a9b4ed28b7623027f591b4b.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","content":"<h1 id=\"1-Java反射机制\"><a href=\"#1-Java反射机制\" class=\"headerlink\" title=\"1. Java反射机制\"></a>1. Java反射机制</h1><h2 id=\"1-1-Java反射机制概述\"><a href=\"#1-1-Java反射机制概述\" class=\"headerlink\" title=\"1.1 Java反射机制概述\"></a>1.1 Java反射机制概述</h2><ul>\n<li>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 </li>\n<li>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li>\n</ul>\n<p>正常方式：引入需要的”包类”名称—&gt;通过new实例化–&gt;取得实例化对象<br>反射方式：实例化对象–&gt;getClass()方法–&gt;得到完整的“包类”名称</p>\n<h3 id=\"补充：动态语言-vs-静态语言\"><a href=\"#补充：动态语言-vs-静态语言\" class=\"headerlink\" title=\"补充：动态语言 vs 静态语言\"></a>补充：动态语言 vs 静态语言</h3><ol>\n<li><p>动态语言</p>\n<pre><code>    是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n</code></pre><p>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>\n</li>\n<li><p>静态语言</p>\n<pre><code>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。\n</code></pre></li>\n</ol>\n<p>​        Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！</p>\n<h3 id=\"Java反射机制研究及应用\"><a href=\"#Java反射机制研究及应用\" class=\"headerlink\" title=\"Java反射机制研究及应用\"></a>Java反射机制研究及应用</h3><p> <strong>Java反射机制提供的功能</strong></p>\n<ul>\n<li>在运行时判断任意一个对象所属的类</li>\n<li>在运行时构造任意一个类的对象</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法</li>\n<li>在运行时获取泛型信息</li>\n<li>在运行时调用任意一个对象的成员变量和方法</li>\n<li>在运行时处理注解</li>\n<li>生成动态代理</li>\n</ul>\n<p><strong>反射相关的主要API</strong></p>\n<ul>\n<li>java.lang.Class:代表一个类 </li>\n<li>java. lang.reflect.Method:代表类的方法</li>\n<li>java.lang.reflect.Field:代表类的成员变量</li>\n<li>java.lang.reflect.Constructor:代表类的构造器 </li>\n</ul>\n<h2 id=\"1-2-理解Class类并获取Class实例\"><a href=\"#1-2-理解Class类并获取Class实例\" class=\"headerlink\" title=\"1.2 理解Class类并获取Class实例\"></a>1.2 理解Class类并获取Class实例</h2><p><strong>Class 类 在Object类中定义了以下的方法，此方法将被所有子类继承：</strong><br>● public final Class getClass()</p>\n<p>​        以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</p>\n<p>​        对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。 </p>\n<ul>\n<li>Class本身也是一个类</li>\n<li>Class 对象只能由系统建立对象</li>\n<li>一个加载的类在 JVM 中只会有一个Class实例</li>\n<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>\n<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>\n<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>\n<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Class类的常用方法</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static Class forName(String name)</td>\n<td>返回指定类名 name 的 Class 对象</td>\n</tr>\n<tr>\n<td>Object newInstance()</td>\n<td>调用缺省构造函数，返回该Class对象的一个实例</td>\n</tr>\n<tr>\n<td>getName()</td>\n<td>返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称</td>\n</tr>\n<tr>\n<td>Class getSuperClass()</td>\n<td>返回当前Class对象的父类的Class对象</td>\n</tr>\n<tr>\n<td>Class [] getInterfaces()</td>\n<td>获取当前Class对象的接口</td>\n</tr>\n<tr>\n<td>ClassLoader getClassLoader()</td>\n<td>返回该类的类加载器</td>\n</tr>\n<tr>\n<td>Class getSuperclass()</td>\n<td>返回该类的类加载器</td>\n</tr>\n<tr>\n<td>Constructor[] getConstructors()</td>\n<td>返回一个包含某些Constructor对象的数组</td>\n</tr>\n<tr>\n<td>Field[] getDeclaredFields()</td>\n<td>返回Field对象的一个数组</td>\n</tr>\n<tr>\n<td>Method getMethod(String name,Class … paramTypes)</td>\n<td>返回一个Method对象，此对象的形参类型为paramType</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>反射的应用举例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"test4.Person\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getField</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfield<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Peter\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> name <span class=\"token operator\">=</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注：test4.Person是test4包下的Person类</p>\n<p><strong>获取Class类的实例(四种方法)</strong> </p>\n<p>1）前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高<br>        实例：Class clazz = String.class; </p>\n<p>2）前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象<br>        实例：Class clazz = “www.atguigu.com”.getClass();<br>3）前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException<br>        实例：Class clazz = Class.forName(“java.lang.String”);<br>4）其他方式(不做要求)<br>        ClassLoader cl = this.getClass().getClassLoader();<br>        Class clazz4 = cl.loadClass(“类的全类名”);<br><strong>哪些类型可以有Class对象？</strong><br>（1）class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类<br>（2）interface：接口<br>（3）[]：数组<br>（4）enum：枚举<br>（5）annotation：注解@interface<br>（6）primitive type：基本数据类型<br>（7）void</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span> c1 <span class=\"token operator\">=</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c3 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c4 <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c5 <span class=\"token operator\">=</span> <span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c6 <span class=\"token operator\">=</span> <span class=\"token class-name\">Override</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c7 <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c8 <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c9 <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c10 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c11 <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 只要元素类型与维度一样，就是同一个Class</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c10 <span class=\"token operator\">==</span> c11<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-3-类的加载与ClassLoader的理解\"><a href=\"#1-3-类的加载与ClassLoader的理解\" class=\"headerlink\" title=\"1.3 类的加载与ClassLoader的理解\"></a>1.3 类的加载与ClassLoader的理解</h2><p>了解：类的加载过程</p>\n<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>\n<ol>\n<li>类的加载(Load)将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</li>\n<li>类的链接(Link)将类的二进制数据合并到JRE中</li>\n<li>类的初始化(Initialize)JVM负责对类进行初始化</li>\n</ol>\n<p><strong>类的加载与ClassLoader的理解</strong></p>\n<ol>\n<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。 </li>\n<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ol>\n<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>\n<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 </li>\n<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 </li>\n</ol>\n</li>\n<li>初始化：<ol>\n<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 </clinit></clinit></li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 </li>\n<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>\n</ol>\n</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoadingTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span> \n        m <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//第二步：链接结束后m=0</span>\n<span class=\"token comment\">//第三步：初始化后，m的值由&lt;clinit&gt;()方法执行决定</span>\n<span class=\"token comment\">// 这个A的类构造器&lt;clinit&gt;()方法由类变量的赋值和静态代码块中的语句按照顺序合并</span>\n产生，类似于\n<span class=\"token comment\">// &lt;clinit&gt;(){</span>\n<span class=\"token comment\">// m = 300;</span>\n<span class=\"token comment\">// m = 100;</span>\n<span class=\"token comment\">// }</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>什么时候会发生类初始化？</strong> </p>\n<ol>\n<li>类的主动引用（一定会发生类的初始化） <ul>\n<li>当虚拟机启动，先初始化main方法所在的类  new一个类的对象</li>\n<li>调用类的静态成员（除了final常量）和静态方法</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>\n</ul>\n</li>\n<li>类的被动引用（不会发生类的初始化）  当访问一个静态域时，只有真正声明这个域的类才会被初始化<ul>\n<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>\n<li>通过数组定义类引用，不会触发此类的初始化</li>\n<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoadingTest</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 主动引用：一定会导致A和Father的初始化</span>\n    <span class=\"token comment\">// A a = new A();</span>\n    <span class=\"token comment\">// System.out.println(A.m);</span>\n    <span class=\"token comment\">// Class.forName(\"com.atguigu.java2.A\");</span>\n    <span class=\"token comment\">// 被动引用</span>\n    <span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//不会导致A和Father的初始化</span>\n    <span class=\"token comment\">// System.out.println(A.b);//只会初始化Father</span>\n    <span class=\"token comment\">// System.out.println(A.M);//不会导致A和Father的初始化</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n    \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main所在的类\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n    \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"父类被加载\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子类被加载\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        m <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token class-name\">M</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>类加载的作用</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 </p>\n<p><strong>类缓存</strong>：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p>\n<p><strong>了解：ClassLoader</strong></p>\n<p>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器。<br>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取<br>扩展类加载器：负责jre/lib/ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库<br>系统类加载器：负责java –classpath 或 –D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//1.获取一个系统类加载器</span>\n<span class=\"token class-name\">ClassLoader</span> classloader <span class=\"token operator\">=</span> <span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//2.获取系统类加载器的父类加载器，即扩展类加载器</span>\nclassloader <span class=\"token operator\">=</span> classloader<span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//3.获取扩展类加载器的父类加载器，即引导类加载器</span>\nclassloader <span class=\"token operator\">=</span> classloader<span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//4.测试当前类由哪个类加载器进行加载</span>\nclassloader <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"exer2.ClassloaderDemo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//5.测试JDK提供的Object类由哪个类加载器加载</span>\nclassloader <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"java.lang.Object\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//*6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流</span>\n<span class=\"token class-name\">InputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nin <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResourceAsStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"exer2\\\\test.properties\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-4-创建运行时类的对象\"><a href=\"#1-4-创建运行时类的对象\" class=\"headerlink\" title=\"1.4 创建运行时类的对象\"></a>1.4 创建运行时类的对象</h2><p><strong>创建类的对象：调用Class对象的newInstance()方法</strong><br>要 求： </p>\n<p>1）类必须有一个无参数的构造器。<br>2）类的构造器的访问权限需要足够。</p>\n<p><strong>难道没有无参的构造器就不能创建对象了吗？</strong><br>不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。步骤如下：<br>1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<br>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。<br>3）通过Constructor实例化对象。</p>\n<p><strong>有了Class对象，能做什么？</strong><br>以上是反射机制应用最多的地方。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//1.根据全类名获取对应的Class对象</span>\n<span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> “<span class=\"token class-name\"><span class=\"token namespace\">atguigu<span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">.</span></span>Person</span>\"<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nclazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//2.调用指定参数结构的构造器，生成Constructor的实例</span>\n<span class=\"token class-name\">Constructor</span> con <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getConstructor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//3.通过Constructor的实例创建对应类的对象，并初始化类属性</span>\n<span class=\"token class-name\">Person</span> p2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> con<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Peter\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-5-获取运行时类的完整结构\"><a href=\"#1-5-获取运行时类的完整结构\" class=\"headerlink\" title=\"1.5 获取运行时类的完整结构\"></a>1.5 获取运行时类的完整结构</h2><p>通过反射获取运行时类的完整结构<br>Field、Method、Constructor、Superclass、Interface、Annotation</p>\n<ul>\n<li>实现的全部接口</li>\n<li>所继承的父类</li>\n<li>全部的构造器</li>\n<li>全部的方法</li>\n<li>全部的Field</li>\n</ul>\n<p>使用反射可以取得：</p>\n<ol>\n<li>实现的全部接口<br>public Class&lt;?&gt;[] getInterfaces()<br>确定此对象所表示的类或接口实现的接口。</li>\n<li>所继承的父类<br>public Class&lt;? Super T&gt; getSuperclass()<br>返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。</li>\n<li>全部的构造器<br>public Constructor<t>[] getConstructors()<br>返回此 Class 对象所表示的类的所有public构造方法。<br>public Constructor<t>[] getDeclaredConstructors()<br>返回此 Class 对象表示的类声明的所有构造方法。</t></t></li>\n</ol>\n<p>Constructor类中：</p>\n<ul>\n<li>取得修饰符: public int getModifiers();</li>\n<li><p>取得方法名称: public String getName();</p>\n</li>\n<li><p>取得参数的类型：public Class&lt;?&gt;[] getParameterTypes();</p>\n</li>\n</ul>\n<ol>\n<li>全部的方法<br>public Method[] getDeclaredMethods()<br>返回此Class对象所表示的类或接口的全部方法<br>public Method[] getMethods()<br>返回此Class对象所表示的类或接口的public的方法</li>\n</ol>\n<ul>\n<li>Method类中：<br>public Class&lt;?&gt; getReturnType()取得全部的返回值<br>public Class&lt;?&gt;[] getParameterTypes()取得全部的参数<br>public int getModifiers()取得修饰符<br>public Class&lt;?&gt;[] getExceptionTypes()取得异常信息</li>\n</ul>\n<ol>\n<li><p>全部的Field<br>public Field[] getFields()<br>返回此Class对象所表示的类或接口的public的Field。 </p>\n<p>public Field[] getDeclaredFields()<br>返回此Class对象所表示的类或接口的全部Field。</p>\n</li>\n</ol>\n<ul>\n<li>Field方法中：<br>public int getModifiers() 以整数形式返回此Field的修饰符<br>public Class&lt;?&gt; getType() 得到Field的属性类型<br>public String getName() 返回Field的名称。</li>\n</ul>\n<ol>\n<li><p>Annotation相关</p>\n<p>get Annotation(Class<t> annotationClass)<br>getDeclaredAnnotations() </t></p>\n</li>\n<li><p>泛型相关<br>获取父类泛型类型：Type getGenericSuperclass()<br>泛型类型：ParameterizedType<br>获取实际的泛型类型参数数组：getActualTypeArguments()</p>\n</li>\n<li>类所在的包 Package getPackage() </li>\n</ol>\n<p>小 结：</p>\n<ol>\n<li>在实际的操作中，取得类的信息的操作代码，并不会经常开发。</li>\n<li>一定要熟悉java.lang.reflect包的作用，反射机制。</li>\n<li>如何取得属性、方法、构造器的名称，修饰符等。</li>\n</ol>\n<h2 id=\"1-6-调用运行时类的指定结构\"><a href=\"#1-6-调用运行时类的指定结构\" class=\"headerlink\" title=\"1.6 调用运行时类的指定结构\"></a>1.6 调用运行时类的指定结构</h2><h3 id=\"调用指定方法\"><a href=\"#调用指定方法\" class=\"headerlink\" title=\"调用指定方法\"></a>调用指定方法</h3><p>通过反射，调用类中的方法，通过Method类完成。步骤：</p>\n<ol>\n<li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li>\n<li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li>\n</ol>\n<p>Object invoke(Object obj, Object … args)<br>说明：</p>\n<ol>\n<li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li>\n<li>若原方法若为静态方法，此时形参Object obj可为null</li>\n<li>若原方法形参列表为空，则Object[] args为null</li>\n<li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li>\n</ol>\n<h3 id=\"调用指定属性\"><a href=\"#调用指定属性\" class=\"headerlink\" title=\"调用指定属性\"></a>调用指定属性</h3><p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</p>\n<ul>\n<li>public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。 </li>\n<li>public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 </li>\n</ul>\n<p>在Field中：</p>\n<ul>\n<li>public Object get(Object obj) 取得指定对象obj上此Field的属性内容</li>\n<li>public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容</li>\n</ul>\n<p><strong>关于setAccessible方法的使用</strong></p>\n<ul>\n<li>Method和Field、Constructor对象都有setAccessible()方法。</li>\n<li>setAccessible启动和禁用访问安全检查的开关。 </li>\n<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</li>\n<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 </li>\n<li>使得原本无法访问的私有成员也可以访问</li>\n<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>\n</ul>\n<h2 id=\"1-7-反射的应用：动态代理\"><a href=\"#1-7-反射的应用：动态代理\" class=\"headerlink\" title=\"1.7 反射的应用：动态代理\"></a>1.7 反射的应用：动态代理</h2><p>代理设计模式的原理:<br>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原<br>始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原<br>始对象上。  之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标<br>对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代<br>理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最<br>好可以通过一个代理类完成全部的代理功能。<br>15.7 反射的应用：动态代理<br>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时<br>根据需要动态创建目标类的代理对象。<br>动态代理使用场合: 调试<br>远程方法调用<br>动态代理相比于静态代理的优点：<br>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中<br>处理，这样，我们可以更加灵活和统一的处理众多的方法。<br> Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一<br>个或多个接口动态地生成实现类。<br> 提供用于创建动态代理类和动态代理对象的静态方法<br>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 创建<br>一个动态代理类所对应的Class对象<br>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,<br>InvocationHandler h) 直接创建一个动态代理对象<br>Java动态代理相关API<br>类加载器 得到被代理类实<br>现的全部接口<br>得到InvocationHandler接 口的实现类实例<br>15.7 反射的应用：动态代理<br>动态代理步骤<br>1.创建一个实现接口InvocationHandler的类，它必须实现invoke方<br>法，以完成代理的具体操作。<br>public Object invoke(Object theProxy, Method method, Object[] params)<br>throws Throwable{<br>try{<br>Object retval = method.invoke(targetObj, params);<br>// Print out the result<br>System.out.println(retval);<br>return retval;<br>}catch (Exception exc){}<br>}<br>代理类的对象<br>要调用的方法<br>方法调用时所<br>需要的参数<br>15.7 反射的应用：动态代理<br>动态代理步骤<br>2.创建被代理的类以及接口<br>Subject RealSubject implements<br>say(String name,int age)<br>15.7 反射的应用：动态代理<br>15.7 反射的应用：动态代理<br>动态代理步骤<br>3.通过Proxy的静态方法<br>newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建<br>一个Subject接口代理<br>RealSubject target = new RealSubject();<br>// Create a proxy to wrap the original implementation<br>DebugProxy proxy = new DebugProxy(target);<br>// Get a reference to the proxy through the Subject interface<br>Subject sub = (Subject) Proxy.newProxyInstance(<br>Subject.class.getClassLoader(),new Class[] { Subject.class }, proxy);<br>15.7 反射的应用：动态代理<br>动态代理步骤<br>4.通过 Subject代理调用RealSubject实现类的方法<br>String info = sub.say(“Peter”, 24);<br>System.out.println(info);<br>动态代理与AOP（Aspect Orient Programming)<br>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下<br>面介绍一种更实用的动态代理机制<br>相同的代<br>码段<br>相同的代<br>码段<br>相同的代<br>码段<br>代码段2<br>代码段3<br>代码段1<br>通过复制、<br>粘贴的部分<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br>调用方法<br>调用方法<br>调用方法<br>代码段2<br>代码段3<br>代码段1<br>相同的代<br>码段<br>方法A<br>改进后的说明：代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和<br>一个特定的方法A耦合了！最理想的效果是：代码块1、2、3既可以执行方法A，又无须在程序<br>中以硬编码的方式直接调用深色代码的方法<br>15.7 反射的应用：动态代理<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br>public interface Dog{<br>void info();<br>void run();<br>}<br>public class HuntingDog implements Dog{<br>public void info(){<br>System.out.println(“我是一只猎狗”);<br>}<br>public void run(){<br>System.out.println(“我奔跑迅速”);<br>} }<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br>public class DogUtil{<br>public void method1(){<br>System.out.println(“=====模拟通用方法一=====”);<br>}<br>public void method2(){<br>System.out.println(“=====模拟通用方法二=====”);<br>} }<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br>public class MyInvocationHandler implements InvocationHandler{<br>// 需要被代理的对象<br>private Object target;<br>public void setTarget(Object target){<br>this.target = target;}<br>// 执行动态代理对象的所有方法时，都会被替换成执行如下的invoke方法<br>public Object invoke(Object proxy, Method method, Object[] args)<br>throws Exception{<br>DogUtil du = new DogUtil();<br>// 执行DogUtil对象中的method1。<br>du.method1();<br>// 以target作为主调来执行method方法<br>Object result = method.invoke(target , args);<br>// 执行DogUtil对象中的method2。<br>du.method2();<br>return result;}}<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br>public class MyProxyFactory{<br>// 为指定target生成动态代理对象<br>public static Object getProxy(Object target)<br>throws Exception{<br>// 创建一个MyInvokationHandler对象<br>MyInvokationHandler handler =<br>new MyInvokationHandler();<br>// 为MyInvokationHandler设置target对象<br>handler.setTarget(target);<br>// 创建、并返回一个动态代理对象<br>return<br>Proxy.newProxyInstance(target.getClass().getClassLoader()<br>, target.getClass().getInterfaces() , handler);<br>} }<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br>public class Test{<br>public static void main(String[] args)<br>throws Exception{<br>// 创建一个原始的HuntingDog对象，作为target<br>Dog target = new HuntingDog();<br>// 以指定的target来创建动态代理<br>Dog dog = (Dog)MyProxyFactory.getProxy(target);<br>dog.info();<br>dog.run();<br>} }<br>15.7 反射的应用：动态代理<br>动态代理与AOP（Aspect Orient Programming)<br> 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有<br>太大的意义。通常都是为指定的目标对象生成动态代理<br> 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理<br>包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：<br>AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理<br>动态代理与AOP (Aspect Orient Programming)<br>动态代理增加的通用方法1<br>回调目标对象的方法<br>动态代理增加的通用方法2</p>\n<h1 id=\"2-Java8的其它新特性\"><a href=\"#2-Java8的其它新特性\" class=\"headerlink\" title=\"2. Java8的其它新特性\"></a>2. Java8的其它新特性</h1><h2 id=\"2-1-Lambda表达式\"><a href=\"#2-1-Lambda表达式\" class=\"headerlink\" title=\"2.1 Lambda表达式\"></a>2.1 Lambda表达式</h2><p>为什么使用 Lambda 表达式<br>Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以<br>传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更<br>灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了<br>提升。<br>16.1 Lambda 表达式<br> 从匿名类到 Lambda 的转换举例1<br>16.1 Lambda 表达式<br> 从匿名类到 Lambda 的转换举例2<br>16.1 Lambda 表达式：语法<br>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操<br>作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符<br>或箭头操作符。它将 Lambda 分为两个部分：<br>左侧：指定了 Lambda 表达式需要的参数列表<br>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即<br>Lambda 表达式要执行的功能。<br>16.1 Lambda 表达式：语法<br>语法格式一：无参，无返回值<br>语法格式二：Lambda 需要一个参数，但是没有返回值。<br>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”<br>16.1 Lambda 表达式：语法<br>语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略<br>语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值<br>语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略<br>16.1 Lambda 表达式<br>类型推断<br>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda<br>表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序<br>的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于<br>上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。</p>\n<h2 id=\"2-2-函数式-Functional-接口\"><a href=\"#2-2-函数式-Functional-接口\" class=\"headerlink\" title=\"2.2 函数式(Functional)接口\"></a>2.2 函数式(Functional)接口</h2><p>什么是函数式(Functional)接口<br> 只包含一个抽象方法的接口，称为函数式接口。  你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式<br>抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽<br>象方法上进行声明）。<br> 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检<br>查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个<br>接口是一个函数式接口。<br> 在java.util.function包下定义了Java 8 的丰富的函数式接口<br>16.2 函数式接口<br>如何理解函数式接口<br> Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)<br>编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不<br>得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还<br>可以支持OOF（面向函数编程）  在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的<br>编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在<br>Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的<br>对象类型——函数式接口。  简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是<br>Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口<br>的实例，那么该对象就可以用Lambda表达式来表示。<br> 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。<br>16.2 函数式接口<br>函数式接口举例<br>16.2 函数式接口<br>自定义函数式接口<br>函数式接口中使用泛型：<br>16.2 函数式接口<br>作为参数传递 Lambda 表达式<br>实例化<br>作为参数传递 Lambda 表达式：<br>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda<br>表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。<br>Java 内置四大核心函数式接口<br>函数式接口 参数类型 返回类型 用途<br>Consumer<t><br>消费型接口 T void 对类型为T的对象应用操作，包含方法：<br>void accept(T t)<br>Supplier<t><br>供给型接口 无 T 返回类型为T的对象，包含方法：T get()<br>Function<t, R=\"\"><br>函数型接口 T R<br>对类型为T的对象应用操作，并返回结果。结<br>果是R类型的对象。包含方法：R apply(T t)<br>Predicate<t><br>断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回<br>boolean 值。包含方法：boolean test(T t)<br>16.2 函数式接口<br>其他接口<br>函数式接口 参数类型 返回类型 用途<br>BiFunction<t, U,=\"\" R=\"\"> T, U R<br>对类型为 T, U 参数应用操作，返回 R 类型的结<br>果。包含方法为： R apply(T t, U u);<br>UnaryOperator<t><br>(Function子接口) T T<br>对类型为T的对象进行一元运算，并返回T类型的<br>结果。包含方法为：T apply(T t);<br>BinaryOperator<t><br>(BiFunction 子接口)<br>T, T T<br>对类型为T的对象进行二元运算，并返回T类型的<br>结果。包含方法为： T apply(T t1, T t2);<br>BiConsumer<t, U=\"\"> T, U void 对类型为T, U 参数应用操作。<br>包含方法为： void accept(T t, U u)<br>BiPredicate<t,u> T,U boolean 包含方法为： boolean test(T t,U u)<br>ToIntFunction<t><br>ToLongFunction<t><br>ToDoubleFunction<t><br>T<br>int<br>long<br>double<br>分别计算int、long、double值的函数<br>IntFunction<r><br>LongFunction<r><br>DoubleFunction<r><br>int<br>long<br>double<br>R 参数分别为int、long、double 类型的函数</r></r></r></t></t></t></t,u></t,></t></t></t,></t></t,></t></t></p>\n<h2 id=\"2-3-方法引用与构造器引用\"><a href=\"#2-3-方法引用与构造器引用\" class=\"headerlink\" title=\"2.3 方法引用与构造器引用\"></a>2.3 方法引用与构造器引用</h2><p>方法引用(Method References)<br> 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br> 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就<br>是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向<br>一个方法，可以认为是Lambda表达式的一个语法糖。<br> 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的<br>方法的参数列表和返回值类型保持一致！<br> 格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。<br> 如下三种主要使用情况：  对象::实例方法名<br> 类::静态方法名<br> 类::实例方法名<br>16.3 方法引用与构造器引用<br>方法引用<br>例如：<br>等同于：<br>例如：<br>等同于：<br>16.3 方法引用与构造器引用<br>方法引用<br>例如：<br>等同于：<br>注意：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二<br>个参数是需要引用方法的参数(或无参数)时：ClassName::methodName<br>16.3 方法引用与构造器引用<br>构造器引用<br>格式： ClassName::new<br>与函数式接口相结合，自动与函数式接口中方法兼容。<br>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象<br>方法的参数列表一致！且方法的返回值即为构造器对应类的对象。<br>例如：<br>等同于：<br>16.3 方法引用与构造器引用<br>数组引用<br>格式： type[] :: new<br>例如：<br>等同于：<br>16-4 强大的Stream AP</p>\n<h2 id=\"2-4-强大的Stream-API\"><a href=\"#2-4-强大的Stream-API\" class=\"headerlink\" title=\"2.4 强大的Stream API\"></a>2.4 强大的Stream API</h2><p>Stream API说明<br> Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则<br>是 Stream API。  Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这<br>是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程<br>序员的生产力，让程序员写出高效率、干净、简洁的代码。<br> Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进<br>行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用<br>Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。<br>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种<br>高效且易于使用的处理数据的方式。<br>16.4 强大的Stream API<br>为什么要使用Stream API<br> 实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数<br>据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要<br>Java层面去处理。  Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据<br>结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，<br>后者主要是面向 CPU，通过 CPU 实现计算。<br>16.4 强大的Stream API<br>什么是 Stream<br>Stream到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，Stream讲的是计算！”<br>注意：<br>①Stream 自己不会存储元素。<br>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。<br>16.4 强大的Stream API<br>Stream 的操作三个步骤<br> 1- 创建 Stream<br>一个数据源（如：集合、数组），获取一个流<br> 2- 中间操作<br>一个中间操作链，对数据源的数据进行处理<br> 3- 终止操作(终端操作) 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用<br>16.4 强大的Stream API<br>创建 Stream方式一：通过集合<br>Java8 中的 Collection 接口被扩展，提供了两个获取流<br>的方法：  default Stream<e> stream() : 返回一个顺序流<br> default Stream<e> parallelStream() : 返回一个并行流<br>16.4 强大的Stream API<br>创建 Stream方式二：通过数组<br>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<br> static <t> Stream<t> stream(T[] array): 返回一个流<br>重载形式，能够处理对应基本类型的数组：<br> public static IntStream stream(int[] array)<br> public static LongStream stream(long[] array)<br> public static DoubleStream stream(double[] array)<br>16.4 强大的Stream API<br>创建 Stream方式三：通过Stream的of()<br>可以调用Stream类静态方法 of(), 通过显示值创建一个<br>流。它可以接收任意数量的参数。<br> public static<t> Stream<t> of(T… values) : 返回一个流<br>16.4 强大的Stream API<br>创建 Stream方式四：创建无限流<br>可以使用静态方法 Stream.iterate() 和 Stream.generate(),<br>创建无限流。<br> 迭代<br>public static<t> Stream<t> iterate(final T seed, final UnaryOperator<t> f)<br> 生成<br>public static<t> Stream<t> generate(Supplier<t> s)<br>16.4 强大的Stream API<br>// 方式四：创建无限流<br>@Test<br>public void test4() {<br>// 迭代<br>// public static<t> Stream<t> iterate(final T seed, final<br>// UnaryOperator<t> f)<br>Stream<integer> stream = Stream.iterate(0, x -&gt; x + 2);<br>stream.limit(10).forEach(System.out::println);<br>// 生成<br>// public static<t> Stream<t> generate(Supplier<t> s)<br>Stream<double> stream1 = Stream.generate(Math::random);<br>stream1.limit(10).forEach(System.out::println);<br>}<br>Stream 的中间操作<br>1-筛选与切片<br>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止<br>操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全<br>部处理，称为“惰性求值”。 方 法 描 述<br>filter(Predicate p) 接收 Lambda ， 从流中排除某些元素<br>distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素<br>limit(long maxSize) 截断流，使其元素不超过给定数量<br>skip(long n)<br>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一<br>个空流。与 limit(n) 互补<br>16.4 强大的Stream API<br>Stream 的中间操作<br>2-映 射<br>方法 描述<br>map(Function f)<br>接收一个函数作为参数，该函数会被应用到每个元<br>素上，并将其映射成一个新的元素。<br>mapToDouble(ToDoubleFunction f)<br>接收一个函数作为参数，该函数会被应用到每个元<br>素上，产生一个新的 DoubleStream。<br>mapToInt(ToIntFunction f)<br>接收一个函数作为参数，该函数会被应用到每个元<br>素上，产生一个新的 IntStream。<br>mapToLong(ToLongFunction f)<br>接收一个函数作为参数，该函数会被应用到每个元<br>素上，产生一个新的 LongStream。<br>flatMap(Function f)<br>接收一个函数作为参数，将流中的每个值都换成另<br>一个流，然后把所有流连接成一个流<br>16.4 强大的Stream API<br>Stream 的中间操作<br>3-排序<br>方法 描述<br>sorted() 产生一个新流，其中按自然顺序排序<br>sorted(Comparator com) 产生一个新流，其中按比较器顺序排序<br>16.4 强大的Stream API<br>Stream 的终止操作<br>1-匹配与查找<br> 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例<br>如：List、Integer，甚至是 void 。  流进行了终止操作后，不能再次使用。<br>方法 描述<br>allMatch(Predicate p) 检查是否匹配所有元素<br>anyMatch(Predicate p) 检查是否至少匹配一个元素<br>noneMatch(Predicate p) 检查是否没有匹配所有元素<br>findFirst() 返回第一个元素<br>findAny() 返回当前流中的任意元素<br>16.4 强大的Stream API<br>Stream 的终止操作<br>方法 描述<br>count() 返回流中元素总数<br>max(Comparator c) 返回流中最大值<br>min(Comparator c) 返回流中最小值<br>forEach(Consumer c)<br>内部迭代(使用 Collection 接口需要用户去做迭代，<br>称为外部迭代。相反，Stream API 使用内部迭<br>代——它帮你把迭代做了)<br>16.4 强大的Stream API<br>Stream 的终止操作<br>2-归约<br>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google<br>用它来进行网络搜索而出名。<br>方法 描述<br>reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一<br>个值。返回 T<br>reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一<br>个值。返回 Optional<t><br>16.4 强大的Stream API<br>Stream 的终止操作<br>3-收集<br>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、<br>Map)。<br>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，<br>具体方法与实例如下表：<br>方 法 描 述<br>collect(Collector c)<br>将流转换为其他形式。接收一个 Collector<br>接口的实现，用于给Stream中元素做汇总<br>的方法<br>16.4 强大的Stream API<br>方法 返回类型 作用<br>toList List<t> 把流中元素收集到List<br>List<employee> emps= list.stream().collect(Collectors.toList());<br>toSet Set<t> 把流中元素收集到Set<br>Set<employee> emps= list.stream().collect(Collectors.toSet());<br>toCollection Collection<t> 把流中元素收集到创建的集合<br>Collection<employee> emps =list.stream().collect(Collectors.toCollection(ArrayList::new));<br>counting Long 计算流中元素的个数<br>long count = list.stream().collect(Collectors.counting());<br>summingInt Integer 对流中元素的整数属性求和<br>int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));<br>averagingInt Double 计算流中元素Integer属性的平均值<br>double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));<br>summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平<br>均值<br>int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));<br>16.4 强大的Stream API： Collectors<br>joining String 连接流中每个字符串<br>String str= list.stream().map(Employee::getName).collect(Collectors.joining());<br>maxBy Optional<t> 根据比较器选择最大值<br>Optional<emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));<br>minBy Optional<t> 根据比较器选择最小值<br>Optional<emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));<br>reducing 归约产生的类型<br>从一个作为累加器的初始值开始，<br>利用BinaryOperator与流中元素逐<br>个结合，从而归约成单个值<br>int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));<br>collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转<br>换函数<br>int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));<br>groupingBy Map<k, List<T=\"\">&gt; 根据某属性值对流分组，属性为K，<br>结果为V<br>Map<emp.status, List<Emp=\"\">&gt; map= list.stream()<br>.collect(Collectors.groupingBy(Employee::getStatus));<br>partitioningBy Map<boolean, List<T=\"\">&gt; 根据true或false进行分区<br>Map<boolean,list<emp>&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</boolean,list<emp></boolean,></emp.status,></k,></emp></t></emp></t></employee></t></employee></t></employee></t></t></double></t></t></t></integer></t></t></t></t></t></t></t></t></t></t></t></t></t></e></e></p>\n<h2 id=\"2-5-Optional类\"><a href=\"#2-5-Optional类\" class=\"headerlink\" title=\"2.5 Optional类\"></a>2.5 Optional类</h2><p> 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。<br>以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，<br>Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代<br>码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。<br> Optional<t> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表<br>这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不<br>存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。  Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在<br>则isPresent()方法会返回true，调用get()方法会返回该对象。<br>16.5 Optional 类  Optional提供很多有用的方法，这样我们就不用显式进行空值检测。  创建Optional类对象的方法：<br> Optional.of(T t) : 创建一个 Optional 实例，t必须非空；  Optional.empty() : 创建一个空的 Optional 实例<br> Optional.ofNullable(T t)：t可以为null<br> 判断Optional容器中是否包含对象：<br> boolean isPresent() : 判断是否包含对象<br> void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer<br>接口的实现代码，并且该值会作为参数传给它。<br> 获取Optional容器的对象：<br> T get(): 如果调用对象包含值，返回该值，否则抛异常<br> T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。<br> T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由<br>Supplier接口实现提供的对象。<br> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返<br>回，否则抛出由Supplier接口实现提供的异常。<br>16.5 Optional 类<br>@Test<br>public void test1() {<br>Boy b = new Boy(“张三”);<br>Optional<girl> opt = Optional.ofNullable(b.getGrilFriend());<br>// 如果女朋友存在就打印女朋友的信息<br>opt.ifPresent(System.out::println);<br>}<br>@Test<br>public void test2() {<br>Boy b = new Boy(“张三”);<br>Optional<girl> opt = Optional.ofNullable(b.getGrilFriend());<br>// 如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了<br>Girl girl = opt.orElse(new Girl(“嫦娥”));<br>System.out.println(“他的女朋友是：” + girl.getName());<br>}<br>16.5 Optional 类<br>@Test<br>public void test3(){<br>Optional<employee> opt = Optional.of(new Employee(“张三”, 8888));<br>//判断opt中员工对象是否满足条件，如果满足就保留，否则返回空<br>Optional<employee> emp = opt.filter(e -&gt; e.getSalary()&gt;10000);<br>System.out.println(emp);<br>}<br>@Test<br>public void test4(){<br>Optional<employee> opt = Optional.of(new Employee(“张三”, 8888));<br>//如果opt中员工对象不为空，就涨薪10%<br>Optional<employee> emp = opt.map(e -&gt;<br>{e.setSalary(e.getSalary()%1.1);return e;});<br>System.out.println(emp);<br>}</employee></employee></employee></employee></girl></girl></t></p>\n<h1 id=\"Java9-amp-Java10-amp-Java11新特性\"><a href=\"#Java9-amp-Java10-amp-Java11新特性\" class=\"headerlink\" title=\"Java9&Java10& Java11新特性\"></a>Java9&amp;Java10&amp; Java11新特性</h1><h2 id=\"3-1-Java-9-的新特性\"><a href=\"#3-1-Java-9-的新特性\" class=\"headerlink\" title=\"3.1 Java 9 的新特性\"></a>3.1 Java 9 的新特性</h2><p>JDK 9 的发布<br> 经过4次跳票，历经曲折的Java 9 终于终于在2017年9月21日发布。  从Java 9 这个版本开始，Java 的计划发布周期是 6 个月，下一个 Java 的主版<br>本将于 2018 年 3 月发布，命名为 Java 18.3，紧接着再过六个月将发布 Java<br>18.9。  这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的 （6 个月为周期）发布模式，并逐步的将 Oracle JDK 原商业特性进行开源。<br> 针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term<br>support）。  Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互<br>的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安<br>全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程，<br>完全做了一个整体改变。<br>Java 9 中有哪些不得不说的新特性？<br> 模块化系统<br> jShell命令<br> 多版本兼容jar包  接口的私有方法<br> 钻石操作符的使用升级<br> 语法改进：try语句<br> String存储结构变更<br> 便利的集合特性：of()<br> 增强的Stream API<br> 全新的HTTP客户端API<br> Deprecated的相关API<br> javadoc的HTML 5支持<br> Javascript引擎升级：Nashorn<br> java的动态编译器<br>Java 9 中有哪些不得不说的新特性？<br> 官方提供的新特性列表：<br><a href=\"https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-\">https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-</a> C23AFD78-C777-460B-8ACE-58BE5EA681F6  或参考 Open JDK<br><a href=\"http://openjdk.java.net/projects/jdk9/\">http://openjdk.java.net/projects/jdk9/</a>  在线Oracle JDK 9 Documentation<br><a href=\"https://docs.oracle.com/javase/9/\">https://docs.oracle.com/javase/9/</a><br>一、JDK 和 JRE 目录结构的改变<br>JDK 8 的目录结构<br>bin 目录 包含命令行开发和调试工具，如javac，jar和javadoc。<br>include目录 包含在编译本地代码时使用的C/C++头文件<br>lib 目录 包含JDK工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包<br>含javac编译器的Java类<br>jre/bin 目录 包含基本命令，如java命令。 在Windows平台上，它包含系统的运行时动态链<br>接库（DLL）。<br>jre/lib 目录 包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。<br>rt.jar文件包含运行时的Java类和资源文件。<br>JDK 9 的目录结构<br>没有名为jre的子目录<br>bin 目录 包含所有命令。 在Windows平台上，它继续包含系统的运行时动态链接库。<br>conf 目录 包含用户可编辑的配置文件，例如以前位于jre\\lib目录中的.properties和.policy文件<br>include 目录 包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于JDK中<br>jmods 目录 包含JMOD格式的平台模块。 创建自定义运行时映像时需要它。 它只存在于JDK中<br>legal 目录 包含法律声明<br>lib 目录 包含非Windows平台上的动态链接本地库。 其子目录和文件不应由开发人员直接编辑或使用<br>一、JDK 和 JRE 目录结构的改变<br>二、模块化系统: Jigsaw  Modularity<br> 谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。众所周知，Java 已经<br>发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越<br>来越暴露出一些问题：  Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存<br>加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第<br>一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程<br>序运行需要的class）  当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的<br>增长。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和<br>运行效率的提升。  很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间<br>的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共<br>类所访问到，这样就会导致无意中使用了并不想被公开访问的 API。<br>二、模块化系统: Jigsaw  Modularity<br> 本质上讲也就是说，用模块来管理各个package，通过声明某个package<br>暴露，，模块(module)的概念，其实就是package外再裹一层，不声明默<br>认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪<br>些部分可以暴露，哪些部分隐藏。  实现目标<br> 模块化的主要目的在于减少内存的开销<br> 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开<br>发和维护<br> 改进 Java SE 平台，使其可以适应不同大小的计算设备<br> 改进其安全性，可维护性，提高性能<br>二、模块化系统: Jigsaw  Modularity<br>模块将由通常的类和新的模块声明文件（module-info.java）组成。该文件是位于<br>java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系，<br>以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在<br>模块中，不能在外部使用。<br>二、模块化系统: Jigsaw  Modularity<br>要想在java9demo模块中调用java9test模块下包中的结构，需要在java9test<br>的module-info.java中声明：<br>/**</p>\n<ul>\n<li>@author songhongkang</li>\n<li>@create 2019 下午 11:57<br><em>/<br>module java9test {<br>//package we export<br>exports com.atguigui.bean;<br>}<br>exports：控制着哪些包可以被其它模块访问到。所有不被导出的包默认<br>都被封装在模块里面。<br>二、模块化系统: Jigsaw  Modularity<br>对应在java 9demo 模块的src 下创建module-info.java文件：<br>/*</em></li>\n<li>@author songhongkang</li>\n<li>@create 2019 下午 11:51<br>*/<br>module java9demo {<br>requires java9test;<br>}<br>requires：指明对其它模块的依赖。<br>三、Java的REPL工具： jShell命令<br> 产生背景<br>像Python 和 Scala 之类的语言早就有交互式编程环境 REPL (read - evaluate - print -<br>loop)了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，<br>就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文<br>件、声明类、提供测试方法方可实现。  设计理念<br>即写即得、快速运行<br> 实现目标<br> Java 9 中终于拥有了 REPL工具：jShell。让Java可以像脚本语言一样运行，从<br>控制台启动jShell，利用jShell在没有创建类的情况下直接声明变量，计算表达式，<br>执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文<br>件，无需跟人解释”public static void main(String[] args)”这句废话。<br> jShell也可以从文件中加载语句或者将语句保存到文件中。<br> jShell也可以是tab键进行自动补全和自动添加分号。<br>三、Java的REPL工具： jShell命令<br>调出jShell<br>获取帮助<br>基本使用<br>Tips：在 JShell 环境下，语句末尾的“;” 是可<br>选的。但推荐还是最好加上。提高代码可读<br>性。<br>导入指定的包<br>默认已经导入如下的所有包：(包含java.lang包)<br>三、Java的REPL工具： jShell命令<br>三、Java的REPL工具： jShell命令<br>只需按下 Tab 键，就能自动补全代码<br>列出当前 session 里所有有效的代码片段<br>三、Java的REPL工具： jShell命令<br>查看当前 session 下所有创建过的变量<br>Tips：我们还可以重新定义相同方法名和参<br>数列表的方法，即为对现有方法的修改（或<br>覆盖）。<br>查看当前 session 下所有创建过的方法<br>使用外部代码编辑器来编写 Java 代码<br>三、Java的REPL工具： jShell命令<br>使用/open命令调用：<br>没有受检异常（编译时异常）<br>说明：本来应该强迫我们捕获一个IOException，但却没有出现。因为jShell在<br>后台为我们隐藏了。<br>退出jShell<br>四、语法改进：接口的私有方法<br>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法<br>和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是<br>一个抽象类。 在Java 9中，接口更加的灵活和强大，连方法的访问权限修饰符都可<br>以声明为private的了，此时方法将不会成为你对外暴露的API的一部分。<br>四、语法改进：接口的私有方法<br>interface MyInterface {<br>void normalInterfaceMethod();<br>default void methodDefault1() {<br>init();<br>}<br>public default void methodDefault2() {<br>init();<br>}<br>// This method is not part of the public API exposed by MyInterface<br>private void init() {<br>System.out.println(“默认方法中的通用操作”);<br>} }<br>四、语法改进：接口的私有方法<br>class MyInterfaceImpl implements MyInterface {<br>@Override<br>public void normalInterfaceMethod() {<br>System.out.println(“实现接口的方法”);<br>} }<br>public class MyInterfaceTest {<br>public static void main(String[] args) {<br>MyInterfaceImpl impl = new MyInterfaceImpl();<br>impl.methodDefault1();<br>// impl.init();//不能调用<br>} }<br>五、语法改进:钻石操作符使用升级<br>我们将能够与匿名实现类共同使用钻石操作符（diamond operator）在Java 8<br>中如下的操作是会报错的：<br>Comparator<object> com = new Comparator&lt;&gt;(){<br>@Override<br>public int compare(Object o1, Object o2) {<br>return 0; }<br>};<br>编译报错信息：Cannot use “&lt;&gt;” with anonymous inner classes.<br>五、语法改进:钻石操作符使用升级<br>Java 9中如下操作可以正常执行通过：<br>// anonymous classes can now use type inference<br>Comparator<object> com = new Comparator&lt;&gt;(){<br>@Override<br>public int compare(Object o1, Object o2) {<br>return 0; }<br>};<br>六、语法改进：try语句<br>Java 8 中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必<br>须在try子句中初始化，否则编译不通过。如下例所示：<br>try(InputStreamReader reader = new InputStreamReader(System.in)){<br>//读取数据细节省略<br>}catch (IOException e){<br>e.printStackTrace();<br>}<br>六、语法改进：try语句<br>Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始<br>化过的资源，此时的资源是final的：<br>InputStreamReader reader = new InputStreamReader(System.in);<br>OutputStreamWriter writer = new OutputStreamWriter(System.out);<br>try (reader; writer) {<br>//reader是final的，不可再被赋值<br>//reader = null;<br>//具体读写操作省略<br>} catch (IOException e) {<br>e.printStackTrace();<br>}<br>七、String存储结构变更<br>Motivation<br>The current implementation of the String class stores characters in a char<br>array, using two bytes (sixteen bits) for each character. Data gathered from<br>many different applications indicates that strings are a major component of<br>heap usage and, moreover, that most String objects contain only Latin-1<br>characters. Such characters require only one byte of storage, hence half of the<br>space in the internal char arrays of such String objects is going unused.<br>Description<br>We propose to change the internal representation of the String class from a<br>UTF-16 char array to a byte array plus an encoding-flag field. The new String<br>class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per<br>character), or as UTF-16 (two bytes per character), based upon the contents<br>of the string. The encoding flag will indicate which encoding is used.<br>七、String存储结构变更<br>结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约<br>了一些空间。<br>public final class String<br>implements java.io.Serializable, Comparable<string>, CharSequence {<br>@Stable<br>private final byte[] value; }那StringBuffer 和 StringBuilder 是否仍无动于衷呢？<br>String-related classes such as AbstractStringBuilder, StringBuilder,<br>and StringBuffer will be updated to use the same representation, as will the<br>HotSpot VM‘s intrinsic(固有的、内置的) string operations.<br>八、集合工厂方法：快速创建只读集合<br>要创建一个只读、不可改变的集合，必须构造和分配它，然后添加元素，最后<br>包装成一个不可修改的集合。<br>List<string> namesList = new ArrayList &lt;&gt;();<br>namesList.add(“Joe”);<br>namesList.add(“Bob”);<br>namesList.add(“Bill”);<br>namesList = Collections.unmodifiableList(namesList);<br>System.out.println(namesList);<br>缺点：我们一下写了五行。即：它不能表达为单个表达式。<br>八、集合工厂方法：快速创建只读集合<br>List<string> list = Collections.unmodifiableList(Arrays.asList(“a”, “b”, “c”));<br>Set<string> set = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(“a”,<br>“b”, “c”)));<br>// 如下操作不适用于jdk 8 及之前版本,适用于jdk 9<br>Map<string, Integer=\"\"> map = Collections.unmodifiableMap(new HashMap&lt;&gt;() {<br>{<br>put(“a”, 1);<br>put(“b”, 2);<br>put(“c”, 3);<br>}<br>});<br>map.forEach((k, v) -&gt; System.out.println(k + “:” + v));<br>八、集合工厂方法：快速创建只读集合<br>Java 9因此引入了方便的方法，这使得类似的事情更容易表达。<br>八、集合工厂方法：快速创建只读集合<br>List firsnamesList = List.of(“Joe”,”Bob”,”Bill”);<br>调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能<br>可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的：在<br>创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。<br>由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法，<br>便于调用。<br>List<string> list = List.of(“a”, “b”, “c”);<br>Set<string> set = Set.of(“a”, “b”, “c”);<br>Map<string, Integer=\"\"> map1 = Map.of(“Tom”, 12, “Jerry”, 21, “Lilei”, 33,<br>“HanMeimei”, 18);<br>Map<string, Integer=\"\"> map2 = Map.ofEntries(Map.entry(“Tom”, 89),<br>Map.entry(“Jim”, 78), Map.entry(“Tim”, 98));<br>九、InputStream 加强<br>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接<br>传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下<br>示例。<br>ClassLoader cl = this.getClass().getClassLoader();<br>try (InputStream is = cl.getResourceAsStream(“hello.txt”);<br>OutputStream os = new FileOutputStream(“src<span>\\</span>hello1.txt”)) {<br>is.transferTo(os); // 把输入流中的所有数据直接自动地复制到输出流中<br>} catch (IOException e) {<br>e.printStackTrace();<br>}<br>十、增强的 Stream API<br> Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算，<br>从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构<br>实现声明式的数据处理。<br> 在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法：<br>takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法，可以<br>让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。  除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。<br>现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个<br>(可能是空的) Stream 对象。<br>十、增强的 Stream API<br>takeWhile()的使用<br>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的<br>Stream 中，takeWhile 返回从开头开始的尽量多的元素。<br>List<integer> list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88);<br>list.stream().takeWhile(x -&gt; x &lt; 50).forEach(System.out::println);<br>System.out.println();<br>list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);<br>list.stream().takeWhile(x -&gt; x &lt; 5).forEach(System.out::println);<br>十、增强的 Stream API<br>dropWhile()的使用<br>dropWhile 的行为与 takeWhile 相反，返回剩余的元素。<br>List<integer> list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88);<br>list.stream().dropWhile(x -&gt; x &lt; 50).forEach(System.out::println);<br>System.out.println();<br>list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);<br>list.stream().dropWhile(x -&gt; x &lt; 5).forEach(System.out::println);<br>十、增强的 Stream API<br>ofNullable()的使用<br>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方<br>法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空<br>Stream。<br>// 报NullPointerException<br>// Stream<object> stream1 = Stream.of(null);<br>// System.out.println(stream1.count());<br>// 不报异常，允许通过<br>Stream<string> stringStream = Stream.of(“AA”, “BB”, null);<br>System.out.println(stringStream.count());// 3<br>// 不报异常，允许通过<br>List<string> list = new ArrayList&lt;&gt;();<br>list.add(“AA”);<br>list.add(null);<br>System.out.println(list.stream().count());// 2<br>// ofNullable()：允许值为null<br>Stream<object> stream1 = Stream.ofNullable(null);<br>System.out.println(stream1.count());// 0<br>Stream<string> stream = Stream.ofNullable(“hello world”);<br>System.out.println(stream.count());// 1<br>十、增强的 Stream API<br>iterate()重载的使用<br>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什<br>么时候结束迭代。<br>// 原来的控制终止方式：<br>Stream.iterate(1, i -&gt; i + 1).limit(10).forEach(System.out::println);<br>// 现在的终止方式：<br>Stream.iterate(1, i -&gt; i &lt; 100, i -&gt; i + 1).forEach(System.out::println);<br>十一、Optional获取Stream的方法<br>Optional类中stream()的使用<br>List<string> list = new ArrayList&lt;&gt;();<br>list.add(“Tom”);<br>list.add(“Jerry”);<br>list.add(“Tim”);<br>Optional<list<string>&gt; optional = Optional.ofNullable(list);<br>Stream<list<string>&gt; stream = optional.stream();<br>stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);<br>十二、Javascript引擎升级：Nashorn<br> Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。<br>Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高<br>性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入<br>Javascript。它在 JDK 8 中为 Java 提供一个 Javascript 引擎。  JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得<br>IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析<br>ECMAScript 代码</list<string></list<string></string></string></object></string></string></object></integer></integer></string,></string,></string></string></string,></string></string></string></string></object></object></li>\n</ul>\n<h2 id=\"3-2-Java-10-的新特性\"><a href=\"#3-2-Java-10-的新特性\" class=\"headerlink\" title=\"3.2 Java 10 的新特性\"></a>3.2 Java 10 的新特性</h2><p> 2018年3月21日，Oracle官方宣布Java10正式发布。  需要注意的是 Java 9 和 Java 10 都不是 LTS (Long-Term-Support) 版本。和<br>过去的 Java 大版本升级不同，这两个只有半年左右的开发和维护期。而未<br>来的 Java 11，也就是 18.9 LTS，才是 Java 8 之后第一个 LTS 版本。  JDK10一共定义了109个新特性，其中包含12个JEP（对于程序员来讲，真<br>正的新特性其实就一个），还有一些新API和JVM规范以及JAVA语言规范上<br>的改动。  JDK10的12个JEP（JDK Enhancement Proposal特性加强提议）参阅官方<br>文档：<a href=\"http://openjdk.java.net/projects/jdk/10/\">http://openjdk.java.net/projects/jdk/10/</a><br>JDK10的12个JEP<br>286: Local-Variable Type Inference 局部变量类型推断<br>296: Consolidate the JDK Forest into a Single Repository JDK库的合并<br>304: Garbage-Collector Interface 统一的垃圾回收接口<br>307: Parallel Full GC for G1 为G1提供并行的Full GC<br>310: Application Class-Data Sharing 应用程序类数据（AppCDS）共享<br>312: Thread-Local Handshakes ThreadLocal握手交互<br>313: Remove the Native-Header Generation Tool (javah) 移除JDK中附带的javah工具<br>314: Additional Unicode Language-Tag Extensions 使用附加的Unicode语言标记扩展<br>316: Heap Allocation on Alternative Memory Devices 能将堆内存占用分配给用户指定<br>的备用内存设备<br>317: Experimental Java-Based JIT Compiler 使用基于Java的JIT编译器<br>319: Root Certificates 根证书<br>322: Time-Based Release Versioning 基于时间的发布版本<br>一、局部变量类型推断<br> 产生背景<br>开发者经常抱怨Java中引用代码的程度。局部变量的显示类型声明，常常被认为<br>是不必须的，给一个好听的名字经常可以很清楚的表达出下面应该怎样继续。  好处：<br>减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！<br> 举例如下：<br> 场景一：类实例化时<br>作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第<br>一次用于声明变量类型，第二次用于构造器。<br>LinkedHashSet<integer> set = new LinkedHashSet&lt;&gt;();<br> 场景二：返回值类型含复杂泛型结构<br>变量的声明类型书写复杂且较长，尤其是加上泛型的使用<br>Iterator<map.entry<integer, Student=\"\">&gt; iterator = set.iterator();<br>一、局部变量类型推断<br> 场景三：<br>我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，<br>比如：<br>URL url = new URL(“<a href=\"http://www.atguigu.com\">http://www.atguigu.com</a>“);<br>URLConnection connection = url.openConnection();<br>Reader reader = new BufferedReader(new<br>InputStreamReader(connection.getInputStream()));<br>尽管 IDE可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读<br>性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且，<br>有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意<br>力，不会带来额外的好处。<br>一、局部变量类型推断<br>适用于以下情况：<br>//1.局部变量的初始化<br>var list = new ArrayList&lt;&gt;();<br>//2.增强for循环中的索引<br>for(var v : list) {<br>System.out.println(v);<br>}<br>//3.传统for循环中<br>for(var i = 0;i &lt; 100;i++) {<br>System.out.println(i);<br>}<br>初始值为null<br>Lambda表达式<br>为数组静态初始化<br>一、局部变量类型推断<br>在局部变量中使用时，如下情况不适用：<br>方法引用<br>一、局部变量类型推断<br>不适用以下的结构中：  情况1：没有初始化的局部变量声明<br> 情况2：方法的返回类型<br> 情况3：方法的参数类型<br> 情况4：构造器的参数类型<br> 情况5：属性<br> 情况6：catch块<br>一、局部变量类型推断<br>工作原理<br>在处理 var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行<br>推断，作为左边变量的类型，然后将该类型写入字节码当中。 注 意  var不是一个关键字<br>你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字，<br>而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它<br>就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，<br>但极少人会用它作为类名。  这不是JavaScript<br>首先我要说明的是，var并不会改变Java是一门静态类型语言的事实。编译器负责推<br>断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。<br>下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：<br>一、局部变量类型推断<br>var url = new URL(“<a href=\"http://www.atguigu.com\">http://www.atguigu.com</a>“);<br>var connection = url.openConnection();<br>var reader = new BufferedReader(<br>new InputStreamReader(connection.getInputStream()));<br>反编译后<br>URL url = new URL(“<a href=\"http://www.atguigu.com\">http://www.atguigu.com</a>“);<br>URLConnection connection = url.openConnection();<br>BufferedReader reader = new BufferedReader(<br>new InputStreamReader(connection.getInputStream()));<br>从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发<br>生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所<br>以请放心，这不是 JavaScript。<br>二、集合新增创建不可变集合的方法<br>自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和<br>copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合，来看下它们的<br>使用和区别。<br>//示例1：<br>var list1 = List.of(“Java”, “Python”, “C”);<br>var copy1 = List.copyOf(list1);<br>System.out.println(list1 == copy1); // true<br>//示例2：<br>var list2 = new ArrayList<string>();<br>var copy2 = List.copyOf(list2);<br>System.out.println(list2 == copy2); // false<br>//示例1和2代码基本一致，为什么一个为true,一个为false?<br>从 源 码 分 析 ， 可 以 看 出 copyOf 方 法 会 先 判 断 来 源 集 合 是 不 是<br>AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创<br>建一个新的集合。<br>示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，<br>所以 copyOf 方法又创建了一个新的实例，所以为false。<br>注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、<br>排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。<br>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</string></map.entry<integer,></integer></p>\n<h2 id=\"3-3-Java-11-的新特性\"><a href=\"#3-3-Java-11-的新特性\" class=\"headerlink\" title=\"3.3 Java 11 的新特性\"></a>3.3 Java 11 的新特性</h2><p>北京时间 2018年9 月 26 日，<br>Oracle 官方宣布 Java 11 正式发<br>布。这是 Java 大版本周期变化<br>后的第一个长期支持版本，非<br>常值得关注。从官网即可下载,<br>最新发布的 Java11 将带来 ZGC、<br>Http Client 等重要特性，一共包<br>含 17 个 JEP（JDK Enhancement<br>Proposals，JDK 增强提案）。其 实，总共更新不止17个，只是<br>我们更关注如下的17个JEP更新。<br>JDK 11 将是一个 企业不可忽视的版本。从时间节点来看，JDK 11 的发布正<br>好处在 JDK 8 免费更新到期的前夕，同时 JDK 9、10 也陆续成为“历史版<br>本”，下面是 Oracle JDK 支持路线图：<br>JDK 11 是一个长期支持版本（LTS, Long-Term-Support）  对于企业来说，选择 11 将意味着长期的、可靠的、可预测的技术路线图。<br>其中免费的OpenJDK11 确定将得到 OpenJDK 社区的长期支持， LTS 版本将<br>是可以放心选择的版本。  从 JVM GC 的角度，JDK11 引入了两种新的 GC，其中包括也许是划时代意义<br>的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 JDK 的一个巨<br>大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部<br>分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会<br>上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的<br>问题。<br>按照官方的说法，新的发布周<br>期会严格遵循时间点，将于每<br>年的3月份和9月份发布。所<br>以 Java 11 的版本号是<br>18.9(LTS)。<br>不过与 Java 9 和 Java 10 这<br>两个被称为“功能性的版本”<br>不同（两者均只提供半年的技<br>术支持），Java 11 不仅提供<br>了长期支持服务，还将作为<br>Java 平台的参考实现。<br>Oracle 直到2023年9月都会为<br>Java 11 提供技术支持，而补<br>丁和安全警告等扩展支持将持<br>续到2026年。<br>新的长期支持版本每三年发布一次，根据后续的发布计划，下一<br>个长期支持版 Java 17 将于2021年发布。<br>官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）<br>181: Nest-Based Access Control（基于嵌套的访问控制）<br>309: Dynamic Class-File Constants（动态的类文件常量）<br>315: Improve Aarch64 Intrinsics（改进 Aarch64 Intrinsics）<br>318: Epsilon: A No-Op Garbage Collector（Epsilon 垃圾回收器，又被称为”No-Op（无操作）<br>“回收器）<br>320: Remove the Java EE and CORBA Modules（移除 Java EE 和 CORBA 模块，JavaFX<br>也已被移除）<br>321: HTTP Client (Standard)<br>323: Local-Variable Syntax for Lambda Parameters（用于 Lambda 参数的局部变量语法）<br>324: Key Agreement with Curve25519 and Curve448（采用 Curve25519 和 Curve448 算法<br>实现的密钥协议）<br>官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）<br>327: Unicode 10<br>328: Flight Recorder（飞行记录仪）<br>329: ChaCha20 and Poly1305 Cryptographic Algorithms（实现 ChaCha20 和 Poly1305 加密<br>算法）<br>330: Launch Single-File Source-Code Programs（启动单个 Java 源代码文件的程序）<br>331: Low-Overhead Heap Profiling（低开销的堆分配采样方法）<br>332: Transport Layer Security (TLS) 1.3（对 TLS 1.3 的支持）<br>333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)（ZGC：可伸缩的低延<br>迟垃圾回收器，处于实验性阶段）<br>335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）<br>336: Deprecate the Pack200 Tools and API（弃用 Pack200 工具及其 API）<br>一、新增了一系列字符串处理方法<br>描述 举例<br>判断字符串是否为空白 “ “.isBlank(); // true<br>去除首尾空白 “ Javastack “.strip(); // “Javastack”<br>去除尾部空格 “ Javastack “.stripTrailing(); // “ Javastack”<br>去除首部空格 “ Javastack “.stripLeading(); // “Javastack “<br>复制字符串 “Java”.repeat(3);// “JavaJavaJava”<br>行数统计 “A\\nB\\nC”.lines().count(); // 3<br>二、Optional 加强<br>Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换<br>成一个 Stream, 或者当一个空 Optional 时给它一个替代的。<br>新增方法 描述 新增的版本<br>boolean isEmpty() 判断value是否为空 JDK 11<br>ifPresentOrElse(Consumer&lt;?<br>super T&gt; action, Runnable emptyAction)<br>value非空，执行参数1功能；如果value<br>为空，执行参数2功能 JDK 9<br>Optional<t> or(Supplier&lt;?<br>extends Optional&lt;? extends T&gt;&gt; supplier)<br>value非空，返回对应的Optional；<br>value为空，返回形参封装的Optional<br>JDK 9<br>Stream<t> stream() value非空，返回仅包含此value的<br>Stream；否则，返回一个空的Stream JDK 9<br>T orElseThrow() value非空，返回value；否则抛异常<br>NoSuchElementException JDK 10<br>三、局部变量类型推断升级<br>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样<br>的语法。<br>//错误的形式: 必须要有类型, 可以加上var<br>//Consumer<string> con1 = (@Deprecated t) -&gt;<br>System.out.println(t.toUpperCase());<br>//正确的形式:<br>//使用var的好处是在使用lambda表达式时给参数加上注解。<br>Consumer<string> con2 = (@Deprecated var t) -&gt;<br>System.out.println(t.toUpperCase());<br>四、全新的HTTP 客户端API<br> HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直<br>到2015年，HTTP2才成为标准。  HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。<br>HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发<br>送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载<br>网页至关重要的数据。  这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该<br>API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在<br>java.net 包中找到这个 API。  它 将 替 代 仅 适 用 于 blocking 模式的 HttpURLConnection<br>（HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的<br>方法），并提供对WebSocket 和 HTTP/2的支持。<br>四、全新的HTTP 客户端API<br>HttpClient client = HttpClient.newHttpClient();<br>HttpRequest request =<br>HttpRequest.newBuilder(URI.create(“<a href=\"http://127.0.0.1:8080/test/&quot;)).build(\">http://127.0.0.1:8080/test/\")).build(</a>);<br>BodyHandler<string> responseBodyHandler = BodyHandlers.ofString();<br>HttpResponse<string> response = client.send(request, responseBodyHandler);<br>String body = response.body();<br>System.out.println(body);<br>HttpClient client = HttpClient.newHttpClient();<br>HttpRequest request =<br>HttpRequest.newBuilder(URI.create(“<a href=\"http://127.0.0.1:8080/test/&quot;)).build(\">http://127.0.0.1:8080/test/\")).build(</a>);<br>BodyHandler<string> responseBodyHandler = BodyHandlers.ofString();<br>CompletableFuture<httpresponse<string>&gt; sendAsync =<br>client.sendAsync(request, responseBodyHandler);<br>sendAsync.thenApply(t -&gt; t.body()).thenAccept(System.out::println);<br>//HttpResponse<string> response = sendAsync.get();<br>//String body = response.body();<br>//System.out.println(body);<br>五、更简化的编译运行程序<br>看下面的代码。<br>// 编译<br>javac Javastack.java<br>// 运行<br>java Javastack<br>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。<br>而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示：<br>java Javastack.java<br>一个命令编译运行源代码的注意点：<br> 执行源文件中的第一个类, 第一个类必须包含主方法。  并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的。<br>六、废弃Nashorn引擎<br>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的<br>可以考虑使用GraalVM。<br>七、ZGC<br> GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时<br>间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力<br>的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高<br>效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。  ZGC, A Scalable Low-Latency Garbage Collector(Experimental)<br>ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 但是后面带了Experimental,<br>说明这还不建议用到生产环境。  ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会<br>STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长<br>而变长。<br>七、ZGC<br> 优势：<br> GC暂停时间不会超过10ms<br> 既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)<br> 和G1相比, 应用吞吐能力不会下降超过15%  为未来的GC功能和利用colord指针以及Load barriers优化奠定基础<br> 初始只支持64位系统<br> ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个<br>程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人<br>兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），<br>或压缩堆。<br>八、其它新特性<br> Unicode 10<br> Deprecate the Pack200 Tools and API<br> 新的Epsilon垃圾收集器<br> 完全支持Linux容器（包括Docker）  支持G1上的并行完全垃圾收集<br> 最新的HTTPS安全协议TLS 1.3<br> Java Flight Recorder<br>在当前JDK中看不到什么？<br>一个标准化和轻量级的JSON API<br>一个标准化和轻量级的JSON API被许多Java开发人员所青睐。但是由于资金问<br>题无法在Java当前版本中见到，但并不会削减掉。Java平台首席架构师Mark<br>Reinhold在JDK 9邮件列中说：“这个JEP将是平台上的一个有用的补充，但是在<br>计划中，它并不像Oracle资助的其他功能那么重要，可能会重新考虑JDK 10或<br>更高版本中实现。 ”<br> 对许多应用而言货币价值都是一个关键的特性，但JDK对此却几乎没有任何支持。<br>严格来讲，现有的java.util.Currency类只是代表了当前ISO 4217货币的一个数据结构，<br>但并没有关联的值或者自定义货币。JDK对货币的运算及转换也没有内建的支持，<br>更别说有一个能够代表货币值的标准类型了。  此前，Oracle 公布的JSR 354定义了一套新的Java货币API：JavaMoney，计划会在Java<br>9中正式引入。但是目前没有出现在JDK 新特性 中。  不过，如果你用的是Maven的话，可以做如下的添加，即可使用相关的API处理货币：<br>新的货币 API</string></httpresponse<string></string></string></string></string></string></t></t></p>\n<p><dependency></dependency></p>\n<p><groupid>org.javamoney</groupid></p>\n<p><artifactid>moneta</artifactid></p>\n<p><version>0.9</version><br>&lt;/dependency&gt;<br>在当前JDK中看不到什么？<br>展 望  随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变<br>化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展<br>方向。传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微<br>服务甚至是函数(FaaS， Function-as-a-Service)所替代。  Java虽然标榜面向对象编程，却毫不顾忌的加入面向接口编程思想，又扯出匿<br>名对象之概念，每增加一个新的东西，对Java的根本所在的面向对象思想的一<br>次冲击。反观Python，抓住面向对象的本质，又能在函数编程思想方面游刃有<br>余。Java对标C/C++，以抛掉内存管理为卖点，却又陷入了JVM优化的噩梦。选<br>择比努力更重要，选择Java的人更需要对它有更清晰的认识。<br> Java 需要在新的计算场景下，改进开发效率。这话说的有点笼统，我谈一些自<br>己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，<br>但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。</p>\n","text":"1. Java反射机制1.1 Java反射机制概述 Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类...","link":"","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"41 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":10,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1. Java反射机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 Java反射机制概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80-vs-%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">补充：动态语言 vs 静态语言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">Java反射机制研究及应用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">1.2 理解Class类并获取Class实例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1.3 类的加载与ClassLoader的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.4 创建运行时类的对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.5 获取运行时类的完整结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.6 调用运行时类的指定结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">调用指定方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">调用指定属性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">1.7 反射的应用：动态代理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Java8%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">2. Java8的其它新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">2.1 Lambda表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%87%BD%E6%95%B0%E5%BC%8F-Functional-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.2 函数式(Functional)接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2.3 方法引用与构造器引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%BC%BA%E5%A4%A7%E7%9A%84Stream-API\"><span class=\"toc-text\">2.4 强大的Stream API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-Optional%E7%B1%BB\"><span class=\"toc-text\">2.5 Optional类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java9-amp-Java10-amp-Java11%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Java9&amp;Java10&amp; Java11新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Java-9-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3.1 Java 9 的新特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Java-10-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3.2 Java 10 的新特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Java-11-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3.3 Java 11 的新特性</span></a></li></ol></li></ol>","author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"meta","uid":"047a0157ce631e99397979ea9f68fcda","slug":"000meta","date":"2021-11-12T06:22:18.000Z","updated":"2021-12-10T12:08:05.744Z","comments":true,"path":"api/articles/000meta.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/728718d7b95643cfafdbac6f3ebf65f8.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"学习规划","slug":"学习规划","count":2,"path":"api/categories/学习规划.json"}],"tags":[],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"IO、网络编程","uid":"8bbd211a4ba9676d95abee1aaae0937f","slug":"J5-IO、网络编程","date":"2021-11-12T02:31:03.000Z","updated":"2021-11-24T09:33:10.589Z","comments":true,"path":"api/articles/J5-IO、网络编程.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/b0800299144a42068df6728fac896d25.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"1. IO流1.1 File类的使用 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关 File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。  想要在Java程序中表示一个真实存...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":10,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}}}