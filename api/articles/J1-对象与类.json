{"title":"J5.对象与类","uid":"f8534e8f12d0bc66698739d3b7153c65","slug":"J1-对象与类","date":"2021-11-05T06:23:36.000Z","updated":"2021-11-12T08:30:37.088Z","comments":true,"path":"api/articles/J1-对象与类.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/3e16bbd9c78544ff8c14fd55fb02aa4f.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","content":"<p><img src=\"https://img-blog.csdnimg.cn/87b7d959374e443db80c21a475817749.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<h1 id=\"面向对象编程OOP\"><a href=\"#面向对象编程OOP\" class=\"headerlink\" title=\"面向对象编程OOP\"></a>面向对象编程OOP</h1><p>类(Class)和对象(Object)是面向对象的核心概念。</p>\n<ul>\n<li>类是对一类事物的描述，是抽象的、概念上的定义</li>\n<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>\n<li>属 性：对应类中的成员变量</li>\n<li>行 为：对应类中的成员方法</li>\n<li>由类构造（construct）对象的过程称为创建类的实例（instance）。</li>\n</ul>\n<p><strong>创建Java自定义类</strong></p>\n<ol>\n<li>定义类（考虑修饰符、类名）</li>\n<li>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</li>\n<li>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）</li>\n</ol>\n<p><strong>对象的创建和使用</strong></p>\n<p>创建对象语法： 类名 对象名 = new 类名();<br>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a><strong>属性</strong></h2><p>修饰符 数据类型 属性名 = 初始化值 ; </p>\n<ol>\n<li>修饰符：常用的权限修饰符有：private、缺省、protected、public，其他修饰符：static、final (暂不考虑)</li>\n<li>数据类型：任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li>\n<li>属性名：属于标识符，符合命名规则和规范即可。</li>\n</ol>\n<p><strong>变量的分类：成员变量与局部变量</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/79283e0561fa499c90823c4447a3579b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>声明的位置</td>\n<td>直接声明在类中</td>\n<td>方法形参或内部、代码块内、构造器内等</td>\n</tr>\n<tr>\n<td>修饰符</td>\n<td>private、public、static、final等</td>\n<td>不能用权限修饰符修饰，可以用final修饰</td>\n</tr>\n<tr>\n<td>初始化值</td>\n<td>有默认初始化值</td>\n<td>没有默认初始化值，必须显式赋值，方可使用</td>\n</tr>\n<tr>\n<td>内存加载位置</td>\n<td>堆空间 或 静态域内</td>\n<td>栈空间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ul>\n<li>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。</li>\n<li>将功能封装为方法的目的是，可以实现代码重用，简化代码</li>\n<li>Java里的方法不能独立存在，所有的方法必须定义在类里。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 方法的声明格式：</span>\n修饰符  返回值类型  方法名（参数类型形参<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> 参数类型形参<span class=\"token number\">2</span><span class=\"token punctuation\">,</span> …<span class=\"token punctuation\">.</span>）｛\n    方法体程序代码\n    <span class=\"token keyword\">return</span> 返回值<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>修饰符：public,缺省,private, protected等返回值类型：</p>\n<p>返回值类型：没有返回值：void，有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用</p>\n<p>方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” </p>\n<p>形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开返回值：方法在执行完毕后返还给调用它的程序的数据。</p>\n<h3 id=\"main方法\"><a href=\"#main方法\" class=\"headerlink\" title=\"main方法\"></a>main方法</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>main方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</td>\n</tr>\n<tr>\n<td>static</td>\n<td>因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的</td>\n</tr>\n<tr>\n<td>String[] args</td>\n<td>该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>代码块(或初始化块)的作用： 对Java类或对象进行初始化<br>代码块(或初始化块)的分类：一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// static代码块通常用于初始化static的属性</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> total<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        total <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//为total赋初值</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>静态代码块：用static 修饰的代码块</li>\n</ul>\n<ol>\n<li>可以有输出语句。</li>\n<li>可以对类的属性、类的声明进行初始化操作。</li>\n<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>\n<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>\n<li>静态代码块的执行要先于非静态代码块。</li>\n<li>静态代码块随着类的加载而加载，且只执行一次。</li>\n</ol>\n<ul>\n<li>非静态代码块：没有static修饰的代码块</li>\n</ul>\n<ol>\n<li>可以有输出语句。</li>\n<li>可以对类的属性、类的声明进行初始化操作。</li>\n<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>\n<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>\n<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>\n</ol>\n<p><strong>⭐程序中成员变量赋值的执行顺序</strong></p>\n<ol>\n<li>声明成员变量的默认初始化</li>\n<li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li>\n<li>构造器再对成员进行初始化操作</li>\n<li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li>\n</ol>\n<h3 id=\"重载-overload\"><a href=\"#重载-overload\" class=\"headerlink\" title=\"重载 overload\"></a>重载 overload</h3><p>在同一个类中，允许存在一个以上的==同名方法==，只要它们的==参数个数或者参数类型==不同即可。</p>\n<p>==与返回值类型无关==，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//返回两个整数的和</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> x<span class=\"token operator\">+</span>y<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//返回三个整数的和</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> x<span class=\"token operator\">+</span>y<span class=\"token operator\">+</span>z<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span> \n<span class=\"token comment\">//返回两个小数的和</span>\n<span class=\"token keyword\">double</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">double</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> x<span class=\"token operator\">+</span>y<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"可变个数的形参\"><a href=\"#可变个数的形参\" class=\"headerlink\" title=\"可变个数的形参\"></a>可变个数的形参</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a <span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span>…books<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ol>\n<li>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>\n<li>可变个数形参的方法与同名的方法之间，彼此构成重载</li>\n<li>可变参数方法的使用与方法参数部分使用数组是一致的</li>\n<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>\n<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>\n</ol>\n<h3 id=\"方法参数的值传递机制\"><a href=\"#方法参数的值传递机制\" class=\"headerlink\" title=\"方法参数的值传递机制\"></a>方法参数的值传递机制</h3><p>    形参：方法声明时的参数<br>    实参：方法调用时实际传给形参的参数值</p>\n<p>Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p>\n<p>    形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参<br>    形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//地址值</span>\n<span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//内容</span>\n<span class=\"token comment\">//源码解析</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> x<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"构造器-或构造方法\"><a href=\"#构造器-或构造方法\" class=\"headerlink\" title=\"构造器 (或构造方法)\"></a>构造器 (或构造方法)</h3><p>构造器的特征</p>\n<ol>\n<li>它具有与类相同的名称</li>\n<li>它不声明返回值类型。（与声明为void不同）</li>\n<li>不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</li>\n</ol>\n<p>构造器的作用：创建对象；给对象进行初始化</p>\n<ul>\n<li>如：Order o = new Order();    Person p = new Person(“Peter”,15);</li>\n<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 语法格式：</span>\n修饰符 类名 <span class=\"token punctuation\">(</span>参数列表<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    初始化语句<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>根据参数不同，构造器可以分为如下两类：<br>    隐式无参构造器（系统默认提供）<br>    显式定义一个或多个构造器（无参、有参）<br>注 意：<br>    Java语言中，每个类都至少有一个构造器<br>    默认构造器的修饰符与所属类的修饰符一致<br>    一旦显式定义了构造器，则系统不再提供默认构造器<br>    一个类可以创建多个重载的构造器<br>    父类的构造器不可被子类继承</p>\n<p><strong>构造器重载</strong></p>\n<p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 构造器重载举例：</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Date</span> d<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>…<span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>…<span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Date</span> d<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>…<span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>…<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"关键字—this\"><a href=\"#关键字—this\" class=\"headerlink\" title=\"关键字—this\"></a>关键字—this</h3><p>    它在方法内部使用，即这个方法所属对象的引用；<br>    它在构造器内部使用，表示该构造器正在初始化的对象。</p>\n<p>this 可以调用类的属性、方法和构造器</p>\n<p>什么时候使用this关键字呢？<br>    当在方法内需要用到调用该方法的对象时，就用this。<br>具体的：我们可以用this来区分属性和局部变量。比如：this.name = name;</p>\n<p>⭐this可以作为一个类中构造器相互调用的特殊格式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//定义Person类</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name <span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age <span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//无参构造器</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"新对象实例化\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//调用本类中的无参构造器</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 调用有一个参数的构造器</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"姓名: \"</span><span class=\"token operator\">+</span>name<span class=\"token operator\">+</span><span class=\"token string\">\"，年龄:\"</span><span class=\"token operator\">+</span>age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>    可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！<br>    明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器<br>    如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”<br>    “this(形参列表)”必须声明在类的构造器的首行！<br>    在类的一个构造器中，最多只能声明一个”this(形参列表)”</p>\n<h2 id=\"封装与隐藏\"><a href=\"#封装与隐藏\" class=\"headerlink\" title=\"封装与隐藏\"></a>封装与隐藏</h2><p>    高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；<br>    低耦合 ：仅对外暴露少量的方法用于使用。</p>\n<p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>\n<p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p>\n<p>    隐藏一个类中不需要对外提供的实现细节；<br>    使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；<br>    便于修改，增强代码的可维护性；</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>类内部</th>\n<th>同一个包</th>\n<th>不同包的子类</th>\n<th>同一个工程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(缺省)</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>protected</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>public</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"包-package-的管理与作用\"><a href=\"#包-package-的管理与作用\" class=\"headerlink\" title=\"包(package)的管理与作用\"></a>包(package)的管理与作用</h2><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：<br>package 顶层包名.子包名 ;</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//举例：pack1\\pack2\\PackageTest.java</span>\n<span class=\"token keyword\">package</span> <span class=\"token namespace\">pack1<span class=\"token punctuation\">.</span>pack2</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//指定类PackageTest属于包pack1.pack2 </span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PackageTest</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"in  method display()\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>    包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次；<br>    包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx</p>\n<p>包的作用：</p>\n<p>    包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式<br>    包可以包含类和子包，划分项目层次，便于管理<br>    解决类命名冲突的问题<br>    控制访问权限</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>JDK中主要的包介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>java.lang</td>\n<td>包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能</td>\n</tr>\n<tr>\n<td>java.net</td>\n<td>包含执行与网络相关的操作的类和接口</td>\n</tr>\n<tr>\n<td>java.io</td>\n<td>包含能提供多种输入/输出功能的类</td>\n</tr>\n<tr>\n<td>java.util</td>\n<td>包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数</td>\n</tr>\n<tr>\n<td>java.text</td>\n<td>包含了一些java格式化相关的类</td>\n</tr>\n<tr>\n<td>java.sql</td>\n<td>包含了java进行JDBC数据库编程的相关类/接口</td>\n</tr>\n<tr>\n<td>java.awt</td>\n<td>包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"继承-inheritance\"><a href=\"#继承-inheritance\" class=\"headerlink\" title=\"继承 (inheritance)\"></a>继承 (inheritance)</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p>\n<p>    此处的多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。可以理解为:“子类 is a 父类”</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 类继承语法规则:</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Subclass</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SuperClass</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>作用：<br>    继承的出现减少了代码冗余，提高了代码的复用性。<br>    继承的出现，更有利于功能的扩展。<br>    继承的出现让类与类之间产生了关系，提供了多态的前提。</p>\n<ul>\n<li>子类继承了父类，就继承了父类的方法和属性。</li>\n<li>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</li>\n<li>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。</li>\n</ul>\n<p>关于继承的规则：</p>\n<ol>\n<li>子类不能直接访问父类中私有的(private)的成员变量和方法。</li>\n<li>⭐Java只支持单继承和多层继承，不允许多重继承</li>\n</ol>\n<h2 id=\"方法的重写-override-overwrite\"><a href=\"#方法的重写-override-overwrite\" class=\"headerlink\" title=\"方法的重写 (override/overwrite)\"></a>方法的重写 (override/overwrite)</h2><p>定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>\n<p>要求：</p>\n<ol>\n<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>\n<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>\n<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<br>    子类不能重写父类中声明为private权限的方法</li>\n<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>\n<li>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</li>\n</ol>\n<p>子类继承父类</p>\n<p>    若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。<br>    对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</p>\n<h4 id=\"关键字—super\"><a href=\"#关键字—super\" class=\"headerlink\" title=\"关键字—super\"></a>关键字—super</h4><p>在Java类中使用super来调用父类中的指定操作：</p>\n<ul>\n<li>super可用于访问父类中定义的属性</li>\n<li>super可用于调用父类中定义的成员方法</li>\n<li>super可用于在子类构造器中调用父类的构造器</li>\n<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>\n<li>super的追溯不仅限于直接父类</li>\n<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>\n</ul>\n<p><strong>调用父类的构造器</strong></p>\n<p>    子类中所有的构造器默认都会访问父类中空参数的构造器<br>    当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行<br>    如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>No.</th>\n<th>区别点</th>\n<th>this</th>\n<th>super</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>访问属性</td>\n<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>\n<td>直接访问父类中的属性</td>\n</tr>\n<tr>\n<td>2</td>\n<td>调用方法</td>\n<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>\n<td>直接访问父类中的方法</td>\n</tr>\n<tr>\n<td>3</td>\n<td>调用构造器</td>\n<td>调用本类构造器，必须放在构造器的首行</td>\n<td>调用父类构造器，必须放在子类构造器的首行</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"子类对象的实例化过程\"><a href=\"#子类对象的实例化过程\" class=\"headerlink\" title=\"子类对象的实例化过程\"></a>子类对象的实例化过程</h4><p><img src=\"https://img-blog.csdnimg.cn/08e439d6c3c04cd3a65c8c266b7a2565.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<h2 id=\"多态性\"><a href=\"#多态性\" class=\"headerlink\" title=\"多态性\"></a>多态性</h2><p>对象的多态性：父类的引用指向子类的对象</p>\n<p>Java引用变量有两个类型：</p>\n<ol>\n<li><strong>编译时类型</strong>：由声明该变量时使用的类型决定。</li>\n<li><strong>运行时类型</strong>：由实际赋给该变量的对象决定。</li>\n</ol>\n<ul>\n<li>编译时，看左边；运行时，看右边。</li>\n<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>多态作用</td>\n<td>    提高了代码的通用性，常称作接口重用</td>\n</tr>\n<tr>\n<td>前提</td>\n<td>    需要存在继承或者实现关系<br>    有方法的重写</td>\n</tr>\n<tr>\n<td>成员方法</td>\n<td>    编译时：要查看引用变量所声明的类中是否有所调用的方法。<br>    运行时：调用实际new的对象所属的类中的重写方法。</td>\n</tr>\n<tr>\n<td>成员变量</td>\n<td>不具备多态性，只看引用变量所声明的类。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对象的多态：在Java中,子类的对象可以替代父类的对象使用<br>    一个变量只能有一种确定的数据类型<br>    一个引用类型变量可能指向(引用)多种不同类型的对象</p>\n<ul>\n<li>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</li>\n</ul>\n<p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就==不能==再访问子类中添加的属性和方法</p>\n<p><strong>虚拟方法调用</strong></p>\n<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>\n<h4 id=\"instanceof运算符\"><a href=\"#instanceof运算符\" class=\"headerlink\" title=\"instanceof运算符\"></a>instanceof运算符</h4><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型。</p>\n<p><strong>对象类型转换</strong></p>\n<p>    从子类到父类的类型转换可以自动进行<br>    从父类到子类的类型转换必须通过造型(强制类型转换)实现<br>    无继承关系的引用类型间的转换是非法的<br>    在造型前可以使用instanceof操作符测试一个对象的类型</p>\n<h4 id=\"对象类型转换-Casting\"><a href=\"#对象类型转换-Casting\" class=\"headerlink\" title=\"对象类型转换 (Casting )\"></a>对象类型转换 (Casting )</h4><p>基本数据类型的Casting：</p>\n<ul>\n<li>自动类型转换：小的数据类型可以自动转换成大的数据类型如long g=20; double d=12.0f</li>\n<li>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型如 float f=(float)12.0; int a=(int)1200L<br>    对Java对象的强制类型转换称为造型<br>    从子类到父类的类型转换可以自动进行<br>    从父类到子类的类型转换必须通过造型(强制类型转换)实现<br>    无继承关系的引用类型间的转换是非法的<br>    在造型前可以使用instanceof操作符测试一个对象的类型</li>\n</ul>\n<h3 id=\"方法的重载与重写\"><a href=\"#方法的重载与重写\" class=\"headerlink\" title=\"方法的重载与重写\"></a>方法的重载与重写</h3><p>从编译和运行的角度看：<br>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。<br>所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"Object类的结构与方法\"><a href=\"#Object类的结构与方法\" class=\"headerlink\" title=\"Object类的结构与方法\"></a>Object类的结构与方法</h2><p>Object类是所有Java类的根父类<br>    如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//等价于</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Object</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public Object()</td>\n<td>构造</td>\n<td>构造器</td>\n</tr>\n<tr>\n<td>public boolean equals(Object obj)</td>\n<td>普通</td>\n<td>对象比较</td>\n</tr>\n<tr>\n<td>public int hashCode()</td>\n<td>普通</td>\n<td>取得Hash码</td>\n</tr>\n<tr>\n<td>public String toString()</td>\n<td>普通</td>\n<td>对象打印时调用</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"操作符与equals方法\"><a href=\"#操作符与equals方法\" class=\"headerlink\" title=\"==操作符与equals方法\"></a>==操作符与equals方法</h4><p>基本类型比较值:只要两个变量的值相等，即为true。</p>\n<p>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。</p>\n<p>用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错</p>\n<p>equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。<br>    只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。<br>    格式:obj1.equals(obj2)<br>    特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；<br>    原因：在这些类中重写了Object类的equals()方法。<br>    当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</p>\n<h4 id=\"重写equals-方法的原则\"><a href=\"#重写equals-方法的原则\" class=\"headerlink\" title=\"重写equals()方法的原则\"></a>重写equals()方法的原则</h4><p>    对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是 “true”。<br>    自反性：x.equals(x)必须返回是“true”。<br>    传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br>    一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br>    任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。</p>\n<h4 id=\"⭐面试题：-和equals的区别\"><a href=\"#⭐面试题：-和equals的区别\" class=\"headerlink\" title=\"⭐面试题：==和equals的区别\"></a>⭐面试题：==和equals的区别</h4><ol>\n<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>\n<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>\n<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>\n<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>\n</ol>\n<h4 id=\"toString-方法\"><a href=\"#toString-方法\" class=\"headerlink\" title=\"toString() 方法\"></a>toString() 方法</h4><p>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。<br>在进行String与其它类型数据的连接操作时，自动调用toString()方法Date now=new Date();</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>“now<span class=\"token operator\">=</span>”<span class=\"token operator\">+</span>now<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//相当于</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>“now<span class=\"token operator\">=</span>”<span class=\"token operator\">+</span>now<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>可以根据需要在用户自定义类型中重写toString()方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//如String 类重写了toString()方法，返回字符串的值。</span>\ns1<span class=\"token operator\">=</span>“hello”<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//相当于System.out.println(s1.toString());</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>    基本类型数据转换为String类型时，调用了对应包装类的toString()方法<br>    int a=10; System.out.println(“a=”+a);</p>\n<h2 id=\"包装类的使用\"><a href=\"#包装类的使用\" class=\"headerlink\" title=\"包装类的使用\"></a>包装类的使用</h2><p>    针对八种基本数据类型定义相应的引用类型—包装类（封装类）</p>\n<p>Byte、Short、Integer、Long、Float、Double、Boolean、Character</p>\n<h3 id=\"基本数据类型包装成包装类的实例-—-装箱\"><a href=\"#基本数据类型包装成包装类的实例-—-装箱\" class=\"headerlink\" title=\"基本数据类型包装成包装类的实例 —-装箱\"></a>基本数据类型包装成包装类的实例 —-装箱</h3><p><strong>通过包装类的构造器实现：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span>   <span class=\"token class-name\">Integer</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>“<span class=\"token number\">12</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>通过字符串参数构造包装类对象：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Float</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Float</span><span class=\"token punctuation\">(</span>“<span class=\"token number\">4.56</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Long</span> l <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">(</span>“asdf”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//NumberFormatException</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"获得包装类对象中包装的基本类型变量-—-拆箱\"><a href=\"#获得包装类对象中包装的基本类型变量-—-拆箱\" class=\"headerlink\" title=\"获得包装类对象中包装的基本类型变量 —-拆箱\"></a>获得包装类对象中包装的基本类型变量 —-拆箱</h3><p><strong>调用包装类的.xxxValue()方法：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> b <span class=\"token operator\">=</span> bObj<span class=\"token punctuation\">.</span><span class=\"token function\">booleanValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>通过包装类的parseXxx(String s)静态方法：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 字符串转包装类</span>\n<span class=\"token class-name\">Float</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">Float</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseFloat</span><span class=\"token punctuation\">(</span>“<span class=\"token number\">12.1</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/69e569be91884af7b877d6342325146d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 基本数据类型包装成包装类的实例 ---装箱</span>\n<span class=\"token comment\">// 通过包装类的构造器实现：</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span>   <span class=\"token class-name\">Integer</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 通过字符串参数构造包装类对象：</span>\n<span class=\"token class-name\">Float</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Float</span><span class=\"token punctuation\">(</span>“<span class=\"token number\">4.56</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Long</span> l <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">(</span>“asdf”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//NumberFormatException</span>\n\n<span class=\"token comment\">//获得包装类对象中包装的基本类型变量 ---拆箱</span>\n<span class=\"token comment\">// 调用包装类的.xxxValue()方法：</span>\n<span class=\"token keyword\">boolean</span> b <span class=\"token operator\">=</span> bObj<span class=\"token punctuation\">.</span><span class=\"token function\">booleanValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 字符串转换成基本数据类型</span>\n<span class=\"token comment\">// 通过包装类的构造器实现：</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>“<span class=\"token number\">12</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 通过包装类的parseXxx(String s)静态方法：</span>\n<span class=\"token class-name\">Float</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">Float</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseFloat</span><span class=\"token punctuation\">(</span>“<span class=\"token number\">12.1</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 基本数据类型转换成字符串</span>\n<span class=\"token comment\">// 调用字符串重载的valueOf()方法：</span>\n<span class=\"token class-name\">String</span> fstr <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2.34f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//更直接的方式：</span>\n<span class=\"token class-name\">String</span> intStr <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token operator\">+</span> “”<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"关键字—static\"><a href=\"#关键字—static\" class=\"headerlink\" title=\"关键字—static\"></a>关键字—static</h2><p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，==只有通过new关键字才会产生出对象==，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，==某些特定的数据在内存空间里只有一份==。</p>\n<ul>\n<li>类属性作为该类==各个对象之间共享的变量==。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</li>\n<li>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</li>\n</ul>\n<p>    使用范围：在Java类中，可用static修饰属性、方法、代码块、内部类</p>\n<p>被修饰后的成员具备以下特点：<br>    随着类的加载而加载<br>    优先于对象存在<br>    修饰的成员，被所有对象所共享<br>    访问权限允许时，可不创建对象，直接被类调用</p>\n<p><strong>匿名对象</strong></p>\n<p>不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">shout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"类变量-class-Variable\"><a href=\"#类变量-class-Variable\" class=\"headerlink\" title=\"类变量(class Variable)\"></a>类变量(class Variable)</h5><p>类变量（类属性）由该类的所有实例共享</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> total <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>total <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不用创建对象就可以访问静态成员 </span>\n<span class=\"token comment\">//访问方式：类名.类属性，类名.类方法</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"类方法-class-method\"><a href=\"#类方法-class-method\" class=\"headerlink\" title=\"类方法(class method)\"></a>类方法(class method)</h5><p>没有对象的实例时，可以用类名.方法名()的形式访问由static修饰的类方法。<br>    在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。<br>    在static方法中不能有this，也不能有super</p>\n<h3 id=\"理解main方法的语法\"><a href=\"#理解main方法的语法\" class=\"headerlink\" title=\"理解main方法的语法\"></a>理解main方法的语法</h3><p>​        由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。</p>\n<p>​        又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p>\n<h3 id=\"关键字—final\"><a href=\"#关键字—final\" class=\"headerlink\" title=\"关键字—final\"></a>关键字—final</h3><ul>\n<li>final标记的类不能被继承。提高安全性，提高程序的可读性。String类、System类、StringBuffer类</li>\n<li>final标记的方法不能被子类重写。Object类中的getClass()。</li>\n<li>    final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>final</th>\n<th>在类、变量和方法时表示“最终的”</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类不能被继承</td>\n<td>提高安全性，提高程序的可读性。</td>\n</tr>\n<tr>\n<td>方法不能被子类重写</td>\n<td>    比如：Object类中的getClass()</td>\n</tr>\n<tr>\n<td>final标记的变量</td>\n<td>名称大写，且只能被赋值一次</td>\n</tr>\n</tbody>\n</table>\n</div>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// final修饰类</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// final修饰方法</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span> <span class=\"token punctuation\">.</span> out <span class=\"token punctuation\">.</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//final修饰变量——常量</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> INFO <span class=\"token operator\">=</span> <span class=\"token string\">\"atguigu\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//声明常量</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"抽象类与抽象方法—abstract\"><a href=\"#抽象类与抽象方法—abstract\" class=\"headerlink\" title=\"抽象类与抽象方法—abstract\"></a>抽象类与抽象方法—abstract</h3><p>类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>\n<p>用abstract关键字来修饰一个类，这个类叫做==抽象类==。<br>用abstract来修饰一个方法，该方法叫做==抽象方法==。<br>    抽象方法：只有方法的声明，没有方法的实现。以分号结束：<br>比如：public abstract void talk();<br>    含有抽象方法的类必须被声明为抽象类。<br>    抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。<br>    不能用abstract修饰变量、代码块、构造器；<br>    不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>\n<h4 id=\"关键字—interface\"><a href=\"#关键字—interface\" class=\"headerlink\" title=\"关键字—interface\"></a>关键字—interface</h4><p>接口(interface)是抽象方法和常量值定义的集合。<br>接口的特点：<br>    用interface来定义。<br>    接口中的所有成员变量都默认是由public static final修饰的。<br>    接口中的所有抽象方法都默认是由public abstract修饰的。<br>    接口中没有构造器。<br>    接口采用多继承机制。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Runner</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> ID <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>定义Java类的语法格式：先写extends，后写implements<br>    class SubClass extends SuperClass implements InterfaceA{ }<br>一个类可以实现多个接口，接口也可以继承其它接口。<br>    实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。<br>    接口的主要用途就是被实现类实现。（面向接口编程）<br>    与继承关系类似，接口与实现类之间存在多态性<br>    接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，(JDK7.0及之前)，而没有变量和方法的实现。</p>\n<ul>\n<li>一个类可以实现多个无关的接口</li>\n<li>与继承关系类似，接口与实现类之间存在多态性</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>区别点</th>\n<th>抽象类</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定义</td>\n<td>包含抽象方法的类</td>\n<td>主要是抽象方法和全局常量的集合</td>\n</tr>\n<tr>\n<td>组成</td>\n<td>构造方法、抽象方法、普通方法、常量、变量</td>\n<td>常量、抽象方法、(jdk8.0:默认方法、静态方法)</td>\n</tr>\n<tr>\n<td>使用</td>\n<td>子类继承抽象类(extends)</td>\n<td>子类实现接口(implements)</td>\n</tr>\n<tr>\n<td>关系</td>\n<td>抽象类可以实现多个接口</td>\n<td>接口不能继承抽象类，但允许继承多个接口</td>\n</tr>\n<tr>\n<td>常见设计模式</td>\n<td>模板方法</td>\n<td>简单工厂、工厂方法、代理模式</td>\n</tr>\n<tr>\n<td>对象</td>\n<td>都通过对象的多态性产生实例化对象</td>\n<td></td>\n</tr>\n<tr>\n<td>局限</td>\n<td>抽象类有单继承的局限</td>\n<td>接口没有此局限</td>\n</tr>\n<tr>\n<td>实际</td>\n<td>作为一个模板</td>\n<td>是作为一个标准或是表示一种能力</td>\n</tr>\n<tr>\n<td>选择</td>\n<td>如果抽象类和接口都可以使用的话，</td>\n<td>优先使用接口，因为避免单继承的局限</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p>\n<p><strong>Java 8中关于接口的改进</strong><br>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。<br><strong>静态方法</strong>：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。<br><strong>默认方法</strong>：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</p>\n<p><strong>接口中的默认方法</strong></p>\n<p>    若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。<br>    解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</p>\n<p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</p>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</p>\n<p>    Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。<br>    Inner class的名字不能与包含它的外部类类名相同；</p>\n<ul>\n<li><p>成员内部类（static成员内部类和非static成员内部类）</p>\n</li>\n<li><p>局部内部类（不谈修饰符）、匿名内部类</p>\n</li>\n</ul>\n<p>成员内部类作为类的成员的角色：<br>    和外部类不同，Inner class还可以声明为private或protected；<br>    可以调用外部类的结构<br>    Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；<br>成员内部类作为类的角色：<br>    可以在内部定义属性、方法、构造器等结构<br>    可以声明为abstract类 ，因此可以被其它的内部类继承<br>    可以声明为final的<br>    编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</p>\n<p>注意：</p>\n<ol>\n<li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。</li>\n<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>\n<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>\n<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span>外部类<span class=\"token punctuation\">{</span>\n    方法<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    \t<span class=\"token keyword\">class</span>局部内部类<span class=\"token punctuation\">{</span>\n    \t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">class</span>局部内部类<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>如何使用局部内部类</li>\n</ul>\n<p>    只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类<br>    但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型</p>\n<ul>\n<li>局部内部类的特点</li>\n</ul>\n<p>    内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。<br>    只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。<br>    局部内部类可以使用外部类的成员，包括私有的。<br>    局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。<br>    局部内部类和局部变量地位类似，不能使用public,protected,缺省,private<br>    局部内部类不能使用static修饰，因此也不能包含静态成员</p>\n<p><strong>匿名内部类</strong></p>\n<p>    匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">new</span> 父类构造器（实参列表）<span class=\"token operator\">|</span>实现接口<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//匿名内部类的类体部分</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>匿名内部类的特点<br>    匿名内部类必须继承父类或实现接口<br>    匿名内部类只能有一个对象<br>    匿名内部类对象只能使用多态形式引用</p>\n<h4 id=\"关键字—native\"><a href=\"#关键字—native\" class=\"headerlink\" title=\"关键字—native\"></a>关键字—native</h4><p>使用 native 关键字说明这个方法是==原生函数==，也就是这个方法是用 ==C/C++==等非Java 语言实现的，并且被编译成了 DLL，由 java 去调用。 </p>\n<p><strong>（1）为什么要用 native 方法</strong><br>java 使用起来非常方便，然而有些层次的任务用 java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。例如：有时 java 应用需要与 java 外面的环境交互。这是本地方法存在的主要原因，你可以想想 java 需要与一些底层系<br>统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 java 应用之外的繁琐的细节。<br><strong>（2）native 声明的方法，对于调用者，可以当做和其他 Java 方法一样使用</strong><br>一个native method 方法可以返回任何 java 类型，包括非基本类型，而且同样可以进行异常控制。<br>native method 的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM 将控制调用本地方法的所有细节。<br>如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用 java语言重写这个方法（如果需要的话）。 </p>\n","text":" 面向对象编程OOP类(Class)和对象(Object)是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。 属 性：对应类中的成员变量 行 为：对应类中的成员方法 由类构造（constr...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":9,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":8,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP\"><span class=\"toc-text\">面向对象编程OOP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#main%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">main方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">代码块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD-overload\"><span class=\"toc-text\">重载 overload</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">可变个数的形参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">方法参数的值传递机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%99%A8-%E6%88%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造器 (或构造方法)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94this\"><span class=\"toc-text\">关键字—this</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F\"><span class=\"toc-text\">封装与隐藏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85-package-%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">包(package)的管理与作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF-inheritance\"><span class=\"toc-text\">继承 (inheritance)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-override-overwrite\"><span class=\"toc-text\">方法的重写 (override&#x2F;overwrite)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94super\"><span class=\"toc-text\">关键字—super</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">子类对象的实例化过程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E6%80%A7\"><span class=\"toc-text\">多态性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#instanceof%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">instanceof运算符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-Casting\"><span class=\"toc-text\">对象类型转换 (Casting )</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法的重载与重写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"> </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Object类的结构与方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">&#x3D;&#x3D;操作符与equals方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99equals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">重写equals()方法的原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">⭐面试题：&#x3D;&#x3D;和equals的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#toString-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">toString() 方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">包装类的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B-%E2%80%94-%E8%A3%85%E7%AE%B1\"><span class=\"toc-text\">基本数据类型包装成包装类的实例 —-装箱</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%BE%97%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E8%A3%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E2%80%94-%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">获得包装类对象中包装的基本类型变量 —-拆箱</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94static\"><span class=\"toc-text\">关键字—static</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8F%98%E9%87%8F-class-Variable\"><span class=\"toc-text\">类变量(class Variable)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%96%B9%E6%B3%95-class-method\"><span class=\"toc-text\">类方法(class method)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">理解main方法的语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94final\"><span class=\"toc-text\">关键字—final</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E2%80%94abstract\"><span class=\"toc-text\">抽象类与抽象方法—abstract</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94interface\"><span class=\"toc-text\">关键字—interface</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94native\"><span class=\"toc-text\">关键字—native</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ASCII码","uid":"0e809b380a45c732473fb3fa1636bd4c","slug":"Z0-计算机基础","date":"2021-11-06T11:52:59.000Z","updated":"2021-11-06T12:03:03.129Z","comments":true,"path":"api/articles/Z0-计算机基础.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/0d2897569a5e4b65b5df9dc578566164.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 ...","link":"","photos":[],"count_time":{"symbolsCount":983,"symbolsTime":"1 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":1,"path":"api/categories/计算机基础.json"}],"tags":[],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Leetcode：1~100","uid":"30c2d1a91e3f3491d3662bdaaf39ffa5","slug":"l01","date":"2021-11-04T12:06:25.000Z","updated":"2021-11-22T07:05:53.298Z","comments":true,"path":"api/articles/l01.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-3cd4587b9b5710397e4f843ba34701d9_1200x500.jpg&refer=http%3A%2F%2Fpic2.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638619543&t=d96ab8217b035d9f4f538a3b47b2cf1b","text":"1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 输入：n...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"LeetCode","slug":"LeetCode","count":2,"path":"api/categories/LeetCode.json"}],"tags":[{"name":"哈希","slug":"哈希","count":1,"path":"api/tags/哈希.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}}}