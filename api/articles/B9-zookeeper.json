{"title":"Zookeeper","uid":"a21b04ca115a88f58bf8270c3847c249","slug":"B9-zookeeper","date":"2021-11-26T06:25:15.000Z","updated":"2021-12-06T07:36:49.255Z","comments":true,"path":"api/articles/B9-zookeeper.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/799dba0361cb4697a0776df265d40e21.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","content":"<h1 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h1><p>​        Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。</p>\n<p>​        Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然 后接受观察者的注 册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p>\n<p>​        Zookeeper=文件系统+通知机制</p>\n<p><strong>Zookeeper特点</strong></p>\n<p>1）Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。 </p>\n<p>2）集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。 </p>\n<p>3）全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。 </p>\n<p>4）更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。 </p>\n<p>5）数据更新原子性，一次数据更新要么成功，要么失败。 </p>\n<p>6）实时性，在一定时间范围内，Client能读到最新数据。</p>\n<p><strong>数据结构</strong></p>\n<p>​        ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识。</p>\n<p><strong>应用场景</strong></p>\n<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>\n<h1 id=\"安装与配置\"><a href=\"#安装与配置\" class=\"headerlink\" title=\"安装与配置\"></a>安装与配置</h1><p><strong>本地安装</strong></p>\n<p>（1）安装 JDK<br>（2）拷贝 apache-zookeeper-3.5.7-bin.tar.gz 安装包到 Linux 系统下<br>（3）解压到指定目录，修改名称，修改配置</p>\n<p><strong>操作 Zookeeper</strong></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">#启动 Zookeeper\n$ bin/zkServer.sh start\n#查看进程是否启动\n$ jps\n4020 Jps\n4001 QuorumPeerMain\n#查看状态\n$ bin/zkServer.sh status\nZooKeeper JMX enabled by default\nUsing config: /opt/module/zookeeper-3.5.7/bin/../conf/zoo.cfg\nMode: standalone\n#启动客户端\n$ bin/zkCli.sh\n#退出客户端：\nquit\n#停止 Zookeeper\n$ bin/zkServer.sh stop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>配置参数解读</strong></p>\n<p>Zookeeper中的配置文件zoo.cfg中参数含义解读如下： </p>\n<p>1）tickTime = 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p>\n<p>2）initLimit = 10：LF初始通信时限<br>        Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量）<br>3）syncLimit = 5：LF同步通信时限<br>        Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死<br>掉，从服务器列表中删除Follwer。 </p>\n<p>4）dataDir：保存Zookeeper中的数据<br>注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。 </p>\n<p>5）clientPort = 2181：客户端连接端口，通常不做修改。</p>\n<h2 id=\"Zookeeper-集群操作\"><a href=\"#Zookeeper-集群操作\" class=\"headerlink\" title=\"Zookeeper 集群操作\"></a>Zookeeper 集群操作</h2><h2 id=\"选举机制（面试重点）\"><a href=\"#选举机制（面试重点）\" class=\"headerlink\" title=\"选举机制（面试重点）\"></a>选举机制（面试重点）</h2><p><strong>Zookeeper选举机制——第一次启动</strong></p>\n<p><strong>SID</strong>：服务器ID。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致。</p>\n<p><strong>ZXID</strong>：事务ID。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑有关。</p>\n<p><strong>Epoch</strong>：每个Leader任期的代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</p>\n<p>（1）服务器1启 动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为<br>LOOKING； </p>\n<p>（2）服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1） 大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING</p>\n<p>（3）服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服<br>务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</p>\n<p>（4）服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为 1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING； </p>\n<p>（5）服务器5启动，同4一样当小弟。</p>\n<p><strong>Zookeeper选举机制——非第一次启动</strong></p>\n<p>（1）当ZooKeeper集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：</p>\n<p>• 服务器初始化启动。</p>\n<p> • 服务器运行期间无法和Leader保持连接。 </p>\n<p>（2）而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：<br>• 集群中本来就已经存在一个Leader。<br>        对于第一种已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和Leader机器建立连接，并进行状态同步即可。<br>• 集群中确实不存在Leader。<br>        假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。</p>\n<h2 id=\"客户端命令行操作\"><a href=\"#客户端命令行操作\" class=\"headerlink\" title=\"客户端命令行操作\"></a>客户端命令行操作</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令基本语法</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>help</td>\n<td>显示所有操作命令</td>\n</tr>\n<tr>\n<td>ls path</td>\n<td>使用 ls 命令来查看当前 znode 的子节点 [可监听] <br>-w 监听子节点变化<br>-s 附加次级信息</td>\n</tr>\n<tr>\n<td>create</td>\n<td>普通创建<br>-s 含有序列<br>-e 临时（重启或者超时消失）</td>\n</tr>\n<tr>\n<td>get path</td>\n<td>获得节点的值 [可监听] <br>-w 监听节点内容变化<br>-s 附加次级信息</td>\n</tr>\n<tr>\n<td>set</td>\n<td>设置节点的具体值</td>\n</tr>\n<tr>\n<td>stat</td>\n<td>查看节点状态</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除节点</td>\n</tr>\n<tr>\n<td>deletall</td>\n<td>递归删除节点</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"znode-节点数据信息\"><a href=\"#znode-节点数据信息\" class=\"headerlink\" title=\"znode 节点数据信息\"></a>znode 节点数据信息</h2><p>ls -s /</p>\n<p>（1）czxid：创建节点的事务 zxid<br>        每次修改 ZooKeeper 状态都会产生一个 ZooKeeper 事务 ID。事务 ID 是 ZooKeeper 中所有修改总的次序。每次修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。<br>（2）ctime：znode 被创建的毫秒数（从 1970 年开始）<br>（3）mzxid：znode 最后更新的事务 zxid<br>（4）mtime：znode 最后修改的毫秒数（从 1970 年开始）<br>（5）pZxid：znode 最后更新的子节点 zxid<br>（6）cversion：znode 子节点变化号，znode 子节点修改次数<br>（7）dataversion：znode 数据变化号<br>（8）aclVersion：znode 访问控制列表的变化号<br>（9）ephemeralOwner：如果是临时节点，这个是 znode 拥有者的 session id。如果不是临时节点则是 0。<br>（10）dataLength：znode 的数据长度<br>（11）numChildren：znode 子节点数量</p>\n","text":"Zookeeper简介​ Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。 ​ Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然 后接受观察者的注 册，一旦这些数据...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"大数据","slug":"大数据","count":8,"path":"api/categories/大数据.json"}],"tags":[{"name":"Zookeeper","slug":"Zookeeper","count":1,"path":"api/tags/Zookeeper.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Zookeeper%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">Zookeeper简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">安装与配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Zookeeper-%E9%9B%86%E7%BE%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Zookeeper 集群操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%EF%BC%88%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">选举机制（面试重点）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">客户端命令行操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#znode-%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">znode 节点数据信息</span></a></li></ol></li></ol>","author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Flume","uid":"f6c5ab269c53087419eb1c0be5e917d0","slug":"B10-Flume","date":"2021-11-26T06:25:34.000Z","updated":"2021-12-10T13:19:22.082Z","comments":true,"path":"api/articles/B10-Flume.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/8eed3c777efa48089151681355ae85e6.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"1. Flume 概述​ Flume 是 Cloudera 提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统。Flume 基于流式架构，灵活简单。 Flume 组成架构如下图所示： AgentAgent 是一个 JVM 进程，它以事件的形式将数据从源头送至目的...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"大数据","slug":"大数据","count":8,"path":"api/categories/大数据.json"}],"tags":[{"name":"Flume","slug":"Flume","count":1,"path":"api/tags/Flume.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"mysql刷题","uid":"4d4adb38002129eb79b23e1030e48e77","slug":"B8-mysql刷题","date":"2021-11-26T03:03:44.000Z","updated":"2021-12-07T09:34:28.982Z","comments":true,"path":"api/articles/B8-mysql刷题.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/5a00e96f5e504fcf98754e024e63506a.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"笔记空值输出nullselect ifnull((select ... from ...),null) as ans; 获取去重的第k名select ... from group by ... order by ... desc limit k-1,1 ; 删除操作，保留一部分d...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"数据库","slug":"数据库","count":4,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":3,"path":"api/tags/MySQL.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}}}