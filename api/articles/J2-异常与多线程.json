{"title":"异常与多线程","uid":"8dfa68efe4979ccc3a00434835ec3a9a","slug":"J2-异常与多线程","date":"2021-11-12T02:28:44.000Z","updated":"2021-11-12T06:22:50.497Z","comments":true,"path":"api/articles/J2-异常与多线程.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/3e16bbd9c78544ff8c14fd55fb02aa4f.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","content":"<h2 id=\"1-异常处理\"><a href=\"#1-异常处理\" class=\"headerlink\" title=\"1. 异常处理\"></a>1. 异常处理</h2><h2 id=\"1-1-异常概述与异常体系结构\"><a href=\"#1-1-异常概述与异常体系结构\" class=\"headerlink\" title=\"1.1 异常概述与异常体系结构\"></a>1.1 异常概述与异常体系结构</h2><p><strong>异常</strong>：在Java语言中，将程序执行中发生的不正常情况</p>\n<p>异常事件可分为两类：</p>\n<ol>\n<li>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。</li>\n<li>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：<br>    空指针访问<br>    试图读取不存在的文件<br>    网络连接中断<br>    数组角标越界</li>\n</ol>\n<p><strong>错误的处理方法</strong></p>\n<ol>\n<li>遇到错误就终止程序的运行。</li>\n<li>由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</li>\n</ol>\n<ul>\n<li>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等</li>\n<li>分类：编译时异常和运行时异常</li>\n</ul>\n<h3 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h3><p>    是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。<br>    对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p>\n<h3 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h3><p>    是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。<br>    对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p>\n<h2 id=\"1-2-常见异常\"><a href=\"#1-2-常见异常\" class=\"headerlink\" title=\"1.2 常见异常\"></a>1.2 常见异常</h2><p><img src=\"https://img-blog.csdnimg.cn/064e75d6dbda49d696284142666e27ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<h2 id=\"1-3-异常处理机制一：try-catch-finally\"><a href=\"#1-3-异常处理机制一：try-catch-finally\" class=\"headerlink\" title=\"1.3 异常处理机制一：try-catch-finally\"></a>1.3 异常处理机制一：try-catch-finally</h2><p>Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。</p>\n<p><strong>异常对象的生成</strong></p>\n<ol>\n<li>由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出</li>\n<li>由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</li>\n</ol>\n<p><strong>异常抛出流程</strong></p>\n<ul>\n<li>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。</li>\n<li>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</li>\n<li>程序员通常只能处理Exception，而对Error无能为力。</li>\n</ul>\n<p><strong>异常处理是通过try-catch-finally语句实现的。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n<span class=\"token comment\">//可能产生异常的代码</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span> <span class=\"token class-name\">ExceptionName1</span> e <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token comment\">//当产生ExceptionName1型异常时的处置措施</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span> <span class=\"token class-name\">ExceptionName2</span> e <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token comment\">//当产生ExceptionName2型异常时的处置措施</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">finally</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\">//无论是否发生异常，都无条件执行的语句</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>try</strong><br>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。<br><strong>catch (Exceptiontype e)</strong><br>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>\n<ul>\n<li>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。</li>\n</ul>\n<p><strong>捕获异常的有关信息：</strong></p>\n<p>getMessage() 获取异常信息，返回字符串<br>printStackTrace()  获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</p>\n<p><strong>finally</strong></p>\n<ul>\n<li>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。</li>\n<li>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return， finally块中的语句都会被执行。</li>\n<li>finally语句和catch语句是任选的</li>\n</ul>\n<h2 id=\"1-4-异常处理机制二：throws\"><a href=\"#1-4-异常处理机制二：throws\" class=\"headerlink\" title=\"1.4 异常处理机制二：throws\"></a>1.4 异常处理机制二：throws</h2><p>​        如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> file<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">FileNotFoundException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//读文件的操作可能产生FileNotFoundException类型的异常</span>\n    <span class=\"token class-name\">FilelnputStream</span> fis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FilelnputStream</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>重写方法声明抛出异常的原则</strong></p>\n<p>重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p>\n<h2 id=\"1-5-手动抛出异常：throw\"><a href=\"#1-5-手动抛出异常：throw\" class=\"headerlink\" title=\"1.5 手动抛出异常：throw\"></a>1.5 手动抛出异常：throw</h2><p>​        Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。<br><strong>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">IOException</span> e <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> e<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"want to throw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"1-6-用户自定义异常类\"><a href=\"#1-6-用户自定义异常类\" class=\"headerlink\" title=\"1.6 用户自定义异常类\"></a>1.6 用户自定义异常类</h2><ul>\n<li>一般地，用户自定义异常类都是RuntimeException的子类。</li>\n<li>自定义异常类通常需要编写几个重载的构造器。</li>\n<li>自定义异常需要提供serialVersionUID</li>\n<li>自定义的异常通过throw抛出。</li>\n<li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</li>\n</ul>\n<h1 id=\"2-多线程\"><a href=\"#2-多线程\" class=\"headerlink\" title=\"2 多线程\"></a>2 多线程</h1><h2 id=\"2-1-基本概念：程序、进程、线程\"><a href=\"#2-1-基本概念：程序、进程、线程\" class=\"headerlink\" title=\"2.1 基本概念：程序、进程、线程\"></a>2.1 基本概念：程序、进程、线程</h2><p><strong>程序(program)</strong>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。<br><strong>进程(process)</strong>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期<br>    如：运行中的QQ，运行中的MP3播放器<br>    程序是静态的，进程是动态的<br>    进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域<br><strong>线程(thread)</strong>，进程可进一步细化为线程，是一个程序内部的一条执行路径。<br>    若一个进程同一时间并行执行多个线程，就是支持多线程的<br>    线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小<br>    一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p>\n<p><strong>并行与并发</strong><br>    并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。<br>    并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</p>\n<p><strong>多线程程序的优点：</strong></p>\n<ol>\n<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>\n<li>提高计算机系统CPU的利用率</li>\n<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>\n</ol>\n<h2 id=\"2-2-线程的创建和使用⭐⭐\"><a href=\"#2-2-线程的创建和使用⭐⭐\" class=\"headerlink\" title=\"2.2 线程的创建和使用⭐⭐\"></a>2.2 线程的创建和使用⭐⭐</h2><p><strong>Thread类的特性</strong><br>    每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体<br>    通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p><strong>构造器</strong><br>    Thread()：创建新的Thread对象<br>    Thread(String threadname)：创建线程并指定线程实例名<br>    Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法<br>    Thread(Runnable target, String name)：创建新的Thread对象</p>\n<h3 id=\"API中创建线程的两种方式\"><a href=\"#API中创建线程的两种方式\" class=\"headerlink\" title=\"API中创建线程的两种方式\"></a>API中创建线程的两种方式</h3><p><strong>方式一：继承Thread类</strong></p>\n<p>1)    定义子类继承Thread类。<br>2)    子类中重写Thread类中的run方法。<br>3)    创建Thread子类对象，即创建了线程对象。<br>4)    调用线程对象start方法：启动线程，调用run方法。</p>\n<p>注意点：</p>\n<ol>\n<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>\n<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>\n<li>想要启动多线程，必须调用start方法。</li>\n<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。</li>\n</ol>\n<p><strong>方式二：实现Runnable接口</strong></p>\n<p>1)    定义子类，实现Runnable接口。<br>2)    子类中重写Runnable接口中的run方法。<br>3)    通过Thread类含参构造器创建线程对象。<br>4)    将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。<br>5)    调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p>\n<p><strong>继承方式和实现方式的联系与区别</strong></p>\n<p>区别<br>    继承Thread：线程代码存放Thread子类run方法中。<br>    实现Runnable：线程代码存在接口的子类的run方法。<br>实现方式的好处<br>    避免了单继承的局限性<br>    多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</p>\n<h3 id=\"Thread类的有关方法\"><a href=\"#Thread类的有关方法\" class=\"headerlink\" title=\"Thread类的有关方法\"></a>Thread类的有关方法</h3><ul>\n<li>void start():  启动线程，并执行对象的run()方法</li>\n<li>run():  线程在被调度时执行的操作</li>\n<li>String getName():  返回线程的名称</li>\n<li>void setName(String name):设置该线程名称</li>\n<li>static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实类</li>\n<li>static  void  yield()：线程让步<br>    暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程<br>    若队列中没有同优先级的线程，忽略此方法</li>\n<li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<br>    低优先级的线程也可以获得执行</li>\n<li>static  void  sleep(long millis)：(指定时间:毫秒)<br>    令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。<br>    抛出InterruptedException异常</li>\n<li>stop(): 强制线程生命期结束，不推荐使用</li>\n<li>boolean isAlive()：返回boolean，判断线程是否还活着</li>\n</ul>\n<h3 id=\"线程的调度\"><a href=\"#线程的调度\" class=\"headerlink\" title=\"线程的调度\"></a>线程的调度</h3><p>Java的调度方法<br>    同优先级线程组成先进先出队列（先到先服务），使用时间片策略<br>    对高优先级，使用优先调度的抢占式策略</p>\n<h3 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h3><p>线程的优先级等级<br>    MAX_PRIORITY：10<br>    MIN _PRIORITY：1<br>    NORM_PRIORITY：5<br>涉及的方法<br>    getPriority() ：返回线程优先值<br>    setPriority(int newPriority) ：改变线程的优先级<br>说明<br>    线程创建时继承父线程的优先级<br>    低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</p>\n<h3 id=\"线程的分类\"><a href=\"#线程的分类\" class=\"headerlink\" title=\"线程的分类\"></a>线程的分类</h3><p>Java中的线程分为两类：一种是守护线程，一种是用户线程。</p>\n<ul>\n<li>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</li>\n<li>守护线程是用来服务用户线程的，通过在start()方法前调用<br>thread.setDaemon(true)可以把一个用户线程变成一个守护线程。</li>\n<li>Java垃圾回收就是一个典型的守护线程。</li>\n<li>若JVM中都是守护线程，当前JVM将退出。</li>\n<li>形象理解：兔死狗烹，鸟尽弓藏</li>\n</ul>\n<h2 id=\"2-3-线程的生命周期\"><a href=\"#2-3-线程的生命周期\" class=\"headerlink\" title=\"2.3 线程的生命周期\"></a>2.3 线程的生命周期</h2><p><strong>JDK中用Thread.State类定义了线程的几种状态</strong></p>\n<p>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态<br>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源<br>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能<br>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态<br>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2498c68c6c924c3b85c796d2b3827047.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<h2 id=\"2-4-线程的同步\"><a href=\"#2-4-线程的同步\" class=\"headerlink\" title=\"2.4 线程的同步\"></a>2.4 线程的同步</h2><p><strong>问题的提出</strong><br>    多个线程执行的不确定性引起执行结果的不稳定<br>    多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</p>\n<h3 id=\"Synchronized的使用方法\"><a href=\"#Synchronized的使用方法\" class=\"headerlink\" title=\"Synchronized的使用方法\"></a>Synchronized的使用方法</h3><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p>\n<ol>\n<li>同步代码块：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>对象<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// 需要被同步的代码；</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ol>\n<li>synchronized还可以放在方法声明中，表示整个方法为同步方法。例如：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> show <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"同步机制中的锁\"><a href=\"#同步机制中的锁\" class=\"headerlink\" title=\"同步机制中的锁\"></a>同步机制中的锁</h3><p>当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>\n<p><strong>synchronized的锁</strong></p>\n<ul>\n<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</li>\n<li>同步方法的锁：静态方法（类名.class）、非静态方法（this）</li>\n<li>同步代码块：自己指定，很多时候也是指定为this或类名.class</li>\n<li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</li>\n<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>\n</ul>\n<h3 id=\"同步的范围\"><a href=\"#同步的范围\" class=\"headerlink\" title=\"同步的范围\"></a>同步的范围</h3><p>1、如何找问题，即代码是否存在线程安全？（非常重要）</p>\n<p>（1）    明确哪些代码是多线程运行的代码<br>（2）    明确多个线程是否有共享数据<br>（3）    明确多线程运行代码中是否有多条语句操作共享数据</p>\n<p>2、如何解决呢？（非常重要）<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。<br>即所有操作共享数据的这些语句都要放在同步范围中<br>3、切记：</p>\n<p>    范围太小：没锁住所有有安全问题的代码<br>    范围太大：没发挥多线程的功能。</p>\n<h3 id=\"释放锁的操作\"><a href=\"#释放锁的操作\" class=\"headerlink\" title=\"释放锁的操作\"></a>释放锁的操作</h3><p>    当前线程的同步方法、同步代码块执行结束。<br>    当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。<br>    当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。<br>    当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</p>\n<h3 id=\"不会释放锁的操作\"><a href=\"#不会释放锁的操作\" class=\"headerlink\" title=\"不会释放锁的操作\"></a>不会释放锁的操作</h3><ul>\n<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行</li>\n<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。<br>    应尽量避免使用suspend()和resume()来控制线程</li>\n</ul>\n<h3 id=\"线程的死锁问题\"><a href=\"#线程的死锁问题\" class=\"headerlink\" title=\"线程的死锁问题\"></a>线程的死锁问题</h3><p><strong>死锁</strong>:不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁,出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。<br><strong>解决方法</strong><br>    专门的算法、原则<br>    尽量减少同步资源的定义<br>    尽量避免嵌套同步</p>\n<h3 id=\"Lock-锁\"><a href=\"#Lock-锁\" class=\"headerlink\" title=\"Lock(锁)\"></a>Lock(锁)</h3><p>    从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。<br>    java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。<br>    ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReenTrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">m</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n        \t<span class=\"token number\">11</span>保证线程安全的代码<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span><span class=\"token punctuation\">{</span>\n        \tlock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//注意：如果同步代码有异常，要将unlock()写入finally语句块</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"synchronized-与-Lock-的对比\"><a href=\"#synchronized-与-Lock-的对比\" class=\"headerlink\" title=\"synchronized 与 Lock 的对比\"></a>synchronized 与 Lock 的对比</h3><ol>\n<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</li>\n<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>\n<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>\n</ol>\n<h2 id=\"2-5-线程的通信\"><a href=\"#2-5-线程的通信\" class=\"headerlink\" title=\"2.5 线程的通信\"></a>2.5 线程的通信</h2><ul>\n<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li>\n<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>\n<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.</li>\n</ul>\n<p>    这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。</p>\n<h3 id=\"wait-方法\"><a href=\"#wait-方法\" class=\"headerlink\" title=\"wait() 方法\"></a>wait() 方法</h3><p>    在当前线程中调用方法： 对象名.wait()<br>    使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify<br>(或notifyAll) 为止。<br>    调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）<br>    调用此方法后，当前线程将释放对象监控权 ，然后进入等待<br>    在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</p>\n<h3 id=\"notify-notifyAll\"><a href=\"#notify-notifyAll\" class=\"headerlink\" title=\"notify()/notifyAll()\"></a>notify()/notifyAll()</h3><p>    在当前线程中调用方法： 对象名.notify()<br>    功能：唤醒等待该对象监控权的一个/所有线程。<br>    调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p>\n<h2 id=\"2-6-JDK5-0新增线程创建方式\"><a href=\"#2-6-JDK5-0新增线程创建方式\" class=\"headerlink\" title=\"2.6 JDK5.0新增线程创建方式\"></a>2.6 JDK5.0新增线程创建方式</h2><h3 id=\"新增方式一：实现Callable接口\"><a href=\"#新增方式一：实现Callable接口\" class=\"headerlink\" title=\"新增方式一：实现Callable接口\"></a>新增方式一：实现Callable接口</h3><p><strong>与使用Runnable相比， Callable功能更强大些</strong><br>    相比run()方法，可以有返回值<br>    方法可以抛出异常<br>    支持泛型的返回值<br>    需要借助FutureTask类，比如获取返回结果</p>\n<p><strong>Future接口</strong><br>    可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。<br>    FutrueTask是Futrue接口的唯一的实现类<br>    FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p>\n<h3 id=\"新增方式二：使用线程池\"><a href=\"#新增方式二：使用线程池\" class=\"headerlink\" title=\"新增方式二：使用线程池\"></a>新增方式二：<strong>使用线程池</strong></h3><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。<br><strong>好处：</strong><br>    提高响应速度（减少了创建新线程的时间）<br>    降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>    便于线程管理<br>            corePoolSize：核心池的大小<br>            maximumPoolSize：最大线程数<br>            keepAliveTime：线程没有任务时最多保持多长时间后会终止</p>\n<h3 id=\"线程池相关API\"><a href=\"#线程池相关API\" class=\"headerlink\" title=\"线程池相关API\"></a>线程池相关API</h3><p>JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors<br>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<br>    void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable<br>    <t> Future<t> submit(Callable<t> task)：执行任务，有返回值，一般又来执行Callable<br>    void shutdown() ：关闭连接池<br>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<br>    Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池<br>    Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池<br>    Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池<br>    Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</t></t></t></p>\n","text":"1. 异常处理1.1 异常概述与异常体系结构异常：在Java语言中，将程序执行中发生的不正常情况 异常事件可分为两类： Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":8,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1. 异常处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.1 异常概述与异常体系结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">运行时异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">编译时异常</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">1.2 常见异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%80%EF%BC%9Atry-catch-finally\"><span class=\"toc-text\">1.3 异常处理机制一：try-catch-finally</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BA%8C%EF%BC%9Athrows\"><span class=\"toc-text\">1.4 异常处理机制二：throws</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9Athrow\"><span class=\"toc-text\">1.5 手动抛出异常：throw</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB\"><span class=\"toc-text\">1.6 用户自定义异常类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2 多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2.1 基本概念：程序、进程、线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E2%AD%90%E2%AD%90\"><span class=\"toc-text\">2.2 线程的创建和使用⭐⭐</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Thread%E7%B1%BB\"><span class=\"toc-text\">Thread类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#API%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">API中创建线程的两种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Thread%E7%B1%BB%E7%9A%84%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Thread类的有关方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">线程的调度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">线程的优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">线程的分类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">2.3 线程的生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">2.4 线程的同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Synchronized的使用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E9%94%81\"><span class=\"toc-text\">同步机制中的锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8C%83%E5%9B%B4\"><span class=\"toc-text\">同步的范围</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">释放锁的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">不会释放锁的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">线程的死锁问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Lock-%E9%94%81\"><span class=\"toc-text\">Lock(锁)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#synchronized-%E4%B8%8E-Lock-%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">synchronized 与 Lock 的对比</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2.5 线程的通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#wait-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">wait() 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#notify-notifyAll\"><span class=\"toc-text\">notify()&#x2F;notifyAll()</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.6 JDK5.0新增线程创建方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">新增方式一：实现Callable接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">新增方式二：使用线程池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3API\"><span class=\"toc-text\">线程池相关API</span></a></li></ol></li></ol>","author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"常用类、枚举、注解","uid":"d0396f84e2a9cf009e1f2a35f0f836dd","slug":"J3-常用类、枚举、注解","date":"2021-11-12T02:30:10.000Z","updated":"2021-11-22T08:57:16.597Z","comments":true,"path":"api/articles/J3-常用类、枚举、注解.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/eef428568dd84069a9e6a30263ad6b00.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"1. Java常用类0. Wapper包装类ing 1.1 字符串相关的类StringString的特性 String类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 String是一个final类，代表不可变的字符序列。 字符串是常量...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":8,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"环境与包管理","uid":"3c25c67d0781653798d002eeefd584b0","slug":"P3-Anaconda与jupyter notebook","date":"2021-11-11T10:25:42.000Z","updated":"2021-11-11T12:57:37.608Z","comments":true,"path":"api/articles/P3-Anaconda与jupyter notebook.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/23d499d2a47444b3b376f9f321c9ac8b.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWUZSNzE4,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","text":"1. Pip对 Python 包的查找、下载、安装、卸载的功能。 1.1 pip常用命令pip的更新 python -m pip install --upgrade pip pip安装包 pip install 包名==版本号 pip更新包 pip install --upgra...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[],"author":{"name":"YFR718","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/47553658?s=400&u=5e0a85700c66d7a2661c5664ec5f24d94e5ed01a&v=4","link":"/","description":"大数据萌新","socials":{"github":"https://github.com/YFR718","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"d","csdn":"","juejin":"","customs":{}}}}}